"""Code generation helper utilities."""

import re


def generate_file_header(spec_version: str) -> list[str]:
    """Generate standard file header."""
    return [
        f"// This file was autogenerated for Vulkan {spec_version}.",
        "// Do not edit manually!",
        "",
    ]


def build_extension_name_map(xml_root):
    """Build map of extension name to EXTENSION_NAME macro."""
    ext_name_map = {}

    for ext in xml_root.findall("extensions/extension"):
        ext_name = ext.get("name")
        ext_supported = ext.get("supported", "")
        if "vulkan" not in ext_supported.split(","):
            continue
        if ext.get("platform") is not None:
            continue

        ext_name_macro = None
        for req in ext.findall("require"):
            for enum_elem in req.findall("enum"):
                enum_name = enum_elem.get("name", "")
                if enum_name.endswith("_EXTENSION_NAME"):
                    ext_name_macro = enum_name
                    break
            if ext_name_macro:
                break

        if ext_name and ext_name_macro:
            ext_name_map[ext_name] = ext_name_macro

    return ext_name_map


def build_extension_type_map(xml_root):
    """
    Build map of type_name -> (ext_name_macro, ext_name, promotion_version).

    Returns a dict mapping struct names to tuple of (extension macro, extension name, promoted version).
    """
    ext_type_map = {}

    for ext in xml_root.findall("extensions/extension"):
        ext_supported = ext.get("supported", "")
        if "vulkan" not in ext_supported.split(","):
            continue
        if ext.get("platform") is not None:
            continue

        ext_name_macro = None
        for req in ext.findall("require"):
            for enum_elem in req.findall("enum"):
                enum_name = enum_elem.get("name", "")
                if enum_name.endswith("_EXTENSION_NAME"):
                    ext_name_macro = enum_name
                    break
            if ext_name_macro:
                break

        if not ext_name_macro:
            continue

        promotedto = ext.get("promotedto", "")
        promotion_version = None
        if promotedto:
            match = re.match(r"VK_VERSION_(\d+)_(\d+)", promotedto)
            if match:
                major, minor = match.groups()
                promotion_version = f"VK_API_VERSION_{major}_{minor}"

        for req in ext.findall("require"):
            for type_elem in req.findall("type"):
                type_name = type_elem.get("name")
                if type_name:
                    ext_type_map[type_name] = (ext_name_macro, ext.get("name"), promotion_version)

    return ext_type_map


def build_alias_maps(xml_root):
    """Build bidirectional alias maps for type aliasing."""
    alias_to_canonical = {}
    canonical_to_aliases = {}

    for type_elem in xml_root.findall("types/type"):
        alias = type_elem.get("alias")
        name = type_elem.get("name")
        if alias and name:
            alias_to_canonical[name] = alias
            canonical_to_aliases.setdefault(alias, []).append(name)

    return alias_to_canonical, canonical_to_aliases


def propagate_ext_map_through_aliases(ext_type_map, alias_to_canonical):
    """Propagate extension info through type aliases."""
    for alias_name, canonical_name in alias_to_canonical.items():
        if alias_name in ext_type_map and canonical_name not in ext_type_map:
            ext_type_map[canonical_name] = ext_type_map[alias_name]
        elif canonical_name in ext_type_map and alias_name not in ext_type_map:
            ext_type_map[alias_name] = ext_type_map[canonical_name]


def build_feature_version_map(xml_root):
    """Build map of struct_name -> VK_API_VERSION from <feature> tags."""
    feature_map = {}

    for feat in xml_root.findall("feature"):
        api = feat.get("api", "")
        if "vulkan" not in api.split(","):
            continue
        feat_name = feat.get("name", "")
        match = re.match(
            r"VK_(?:BASE_|COMPUTE_|GRAPHICS_)?VERSION_(\d+)_(\d+)", feat_name
        )
        if not match:
            continue
        major, minor = match.groups()
        api_version = f"VK_API_VERSION_{major}_{minor}"
        for req in feat.findall("require"):
            for type_elem in req.findall("type"):
                type_name = type_elem.get("name")
                if type_name:
                    feature_map[type_name] = api_version

    return feature_map


def propagate_extension_requirements_from_aliases(
    extension_map: dict[str, tuple[str, list[tuple], str | None]],
    xml_root
) -> None:
    """
    Propagate extension requirements from alias structs to canonical structs.

    When extensions define feature structs that get promoted to core, the XML
    often has the extension info on the alias (e.g., VkPhysicalDevice8BitStorageFeaturesKHR)
    but the generator processes the canonical struct (e.g., VkPhysicalDevice8BitStorageFeatures).

    This function copies extension info from aliases to their canonical structs.

    Args:
        extension_map: The extension map to modify (maps struct name to extension info)
        xml_root: The Vulkan XML root element
    """
    # Build alias -> canonical mapping
    alias_to_canonical = {}
    for type_elem in xml_root.findall("types/type"):
        alias = type_elem.get("alias")
        name = type_elem.get("name")
        if alias and name:
            alias_to_canonical[name] = alias

    # Copy extension info from aliases to canonical structs
    aliases_with_ext_info = []
    for alias, canonical in alias_to_canonical.items():
        if alias in extension_map and canonical not in extension_map:
            # Alias has extension info, but canonical doesn't
            extension_map[canonical] = extension_map[alias]
            aliases_with_ext_info.append(f"{alias} -> {canonical}")

    if aliases_with_ext_info:
        print(f"  Propagated extension info from {len(aliases_with_ext_info)} aliases to canonical structs")
