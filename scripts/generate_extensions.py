#!/usr/bin/env python3
"""
Generate C++ extension info system from the Vulkan specification.

Generates:
- ExtensionType enum (Instance, Device)
- DependencyInfo struct for representing dependencies
- ExtensionInfo struct with name, type, dependencies, promoted version, and property types
- Static storage of all extension info
- get_extension_info() lookup function
- get_api_version_property_types() helper function
"""

import datetime

from vulkan_codegen.parsing import enrich_extensions_with_struct_types, find_extensions
from vulkan_codegen.spec import (
    VULKAN_SPEC_VERSION,
    get_output_paths,
    load_vendor_tags,
    load_vulkan_spec,
)

out_path, include_path = get_output_paths()


def generate_header(extensions) -> str:
    """Generate the vulkan_extensions.hpp header file."""
    lines = [
        f"// This file was autogenerated for Vulkan {VULKAN_SPEC_VERSION}.",
        f"// Created: {datetime.datetime.now()}",
        "// Do not edit manually!",
        "",
        "#pragma once",
        "",
        '#include "vulkan/vulkan.hpp"',
        "",
        "#include <cstdint>",
        "#include <span>",
        "#include <vector>",
        "",
        "namespace merian {",
        "",
        "enum class ExtensionType : uint8_t {",
        "    Instance,",
        "    Device,",
        "};",
        "",
        "struct ExtensionInfo;",
        "",
        "struct ExtensionInfo {",
        "    const char* name;",
        "    ExtensionType type;",
        "    std::span<const ExtensionInfo* const> dependencies;",
        "    uint32_t promoted_to_version;",
        "    std::span<const vk::StructureType> property_types;",
        "    std::span<const vk::StructureType> feature_types;",
        "",
        "    bool is_device_extension() const { return type == ExtensionType::Device; }",
        "    bool is_instance_extension() const { return type == ExtensionType::Instance; }",
        "};",
        "",
        "const ExtensionInfo* get_extension_info(const char* name);",
        "",
    ]

    # Generate forward declarations for all extensions
    lines.append("// Forward declarations for all extensions")
    for ext in sorted(extensions, key=lambda e: e.name):
        var_name = sanitize_var_name(ext.name_macro)
        lines.append(f"extern const ExtensionInfo {var_name}_info;")

    lines.extend(["", "} // namespace merian", ""])
    return "\n".join(lines)


def sanitize_var_name(ext_macro: str) -> str:
    """Convert extension macro to a valid C++ variable name."""
    return ext_macro.lower().replace("_extension_name", "").replace("_", "")


def generate_static_extension_infos(extensions) -> list[str]:
    """Generate static ExtensionInfo objects."""
    lines = []

    # Build map of extension macro to variable name
    ext_to_var = {
        ext.name_macro: sanitize_var_name(ext.name_macro) for ext in extensions
    }

    # Generate dependency pointer arrays
    for ext in sorted(extensions, key=lambda e: e.name):
        if not ext.dependencies:
            continue

        var_name = sanitize_var_name(ext.name_macro)

        # Collect all unique dependencies from all OR groups
        all_deps = set()
        for and_group in ext.dependencies:
            for dep in and_group:
                if dep.extension:
                    all_deps.add(dep.extension)

        if all_deps:
            lines.append(f"const ExtensionInfo* const {var_name}_deps[] = {{")
            for dep_ext in sorted(all_deps):
                dep_var = ext_to_var.get(dep_ext)
                if dep_var:
                    lines.append(f"    &{dep_var}_info,")
            lines.append("};")

    lines.append("")

    # Generate property type arrays
    for ext in sorted(extensions, key=lambda e: e.name):
        if not ext.property_types:
            continue

        var_name = sanitize_var_name(ext.name_macro)
        lines.append(f"const vk::StructureType {var_name}_properties[] = {{")
        for stype in sorted(ext.property_types):
            lines.append(f"    vk::StructureType::{stype},")
        lines.append("};")

    lines.append("")

    # Generate feature type arrays
    for ext in sorted(extensions, key=lambda e: e.name):
        if not ext.feature_types:
            continue

        var_name = sanitize_var_name(ext.name_macro)
        lines.append(f"const vk::StructureType {var_name}_features[] = {{")
        for stype in sorted(ext.feature_types):
            lines.append(f"    vk::StructureType::{stype},")
        lines.append("};")

    lines.append("")

    # Generate ExtensionInfo objects
    for ext in sorted(extensions, key=lambda e: e.name):
        var_name = sanitize_var_name(ext.name_macro)
        ext_type = (
            "ExtensionType::Device"
            if ext.type == "device"
            else "ExtensionType::Instance"
        )
        promoted = ext.promotedto if ext.promotedto else "(uint32_t)-1"

        # Count unique dependencies
        all_deps = set()
        for and_group in ext.dependencies:
            for dep in and_group:
                if dep.extension:
                    all_deps.add(dep.extension)

        lines.append(f"const ExtensionInfo {var_name}_info = {{")
        lines.append(f"    {ext.name_macro},")
        lines.append(f"    {ext_type},")

        if all_deps:
            lines.append(
                f"    std::span<const ExtensionInfo* const>({var_name}_deps, {len(all_deps)}),"
            )
        else:
            lines.append("    {},")

        lines.append(f"    {promoted},")

        if ext.property_types:
            lines.append(
                f"    std::span<const vk::StructureType>({var_name}_properties, {len(ext.property_types)}),"
            )
        else:
            lines.append("    {},")

        if ext.feature_types:
            lines.append(
                f"    std::span<const vk::StructureType>({var_name}_features, {len(ext.feature_types)}),"
            )
        else:
            lines.append("    {},")

        lines.append("};")

    lines.append("")
    return lines


def generate_get_extension_info_impl(extensions) -> list[str]:
    """Generate get_extension_info() implementation."""
    lines = [
        "const ExtensionInfo* get_extension_info(const char* name) {",
    ]

    for ext in sorted(extensions, key=lambda e: e.name):
        var_name = sanitize_var_name(ext.name_macro)
        lines.append(f"    if (std::strcmp(name, {ext.name_macro}) == 0) {{")
        lines.append(f"        return &{var_name}_info;")
        lines.append("    }")

    lines.extend(["    return nullptr;", "}", ""])
    return lines


def generate_implementation(extensions) -> str:
    """Generate the vulkan_extensions.cpp implementation file."""
    lines = [
        f"// This file was autogenerated for Vulkan {VULKAN_SPEC_VERSION}.",
        f"// Created: {datetime.datetime.now()}",
        "// Do not edit manually!",
        "",
        '#include "merian/vk/utils/vulkan_extensions.hpp"',
        "",
        "#include <cstring>",
        "#include <vulkan/vulkan.h>",
        "",
        "namespace merian {",
        "",
    ]

    lines.extend(generate_static_extension_infos(extensions))
    lines.extend(generate_get_extension_info_impl(extensions))

    lines.extend(["} // namespace merian", ""])

    return "\n".join(lines)


def main():
    xml_root = load_vulkan_spec()
    tags = load_vendor_tags(xml_root)

    print("Finding extensions...")
    extensions = find_extensions(xml_root)
    print(f"Found {len(extensions)} extensions")

    print("Enriching extensions with property/feature types...")
    enrich_extensions_with_struct_types(extensions, xml_root, tags)

    device_exts = [e for e in extensions if e.type == "device"]
    instance_exts = [e for e in extensions if e.type == "instance"]
    with_deps = [e for e in extensions if e.dependencies]
    promoted = [e for e in extensions if e.promotedto]
    with_props = [e for e in extensions if e.property_types]
    with_features = [e for e in extensions if e.feature_types]

    print(f"  Device extensions: {len(device_exts)}")
    print(f"  Instance extensions: {len(instance_exts)}")
    print(f"  With dependencies: {len(with_deps)}")
    print(f"  Promoted to core: {len(promoted)}")
    print(f"  With property types: {len(with_props)}")
    print(f"  With feature types: {len(with_features)}")

    print(f"\nGenerating header file: {include_path / 'vulkan_extensions.hpp'}")
    header_content = generate_header(extensions)
    with open(include_path / "vulkan_extensions.hpp", "w") as f:
        f.write(header_content)

    print(f"Generating implementation file: {out_path / 'vulkan_extensions.cpp'}")
    impl_content = generate_implementation(extensions)
    with open(out_path / "vulkan_extensions.cpp", "w") as f:
        f.write(impl_content)

    print("\nDone!")
    print(f"Header lines: ~{len(header_content.splitlines())}")
    print(f"Implementation lines: ~{len(impl_content.splitlines())}")


if __name__ == "__main__":
    main()
