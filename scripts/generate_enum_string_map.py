import datetime
import xml.etree.ElementTree as ET
from pathlib import Path
from urllib.request import urlopen

VULKAN_SPEC_VERSION = "v1.3.275"
VULKAN_SPEC_URL = f"https://raw.githubusercontent.com/KhronosGroup/Vulkan-Docs/{VULKAN_SPEC_VERSION}/xml/vk.xml"
VULKAN_HEADER_URL = f"https://github.com/KhronosGroup/Vulkan-Headers/blob/{VULKAN_SPEC_VERSION}/include/vulkan/vulkan_core.h"

out_path = Path(__file__).parent.parent / "src" / "merian" / "vk" / "utils"
assert out_path.is_dir()

with urlopen(VULKAN_SPEC_URL) as response:
    xml = ET.parse(response).getroot()

with urlopen(VULKAN_HEADER_URL) as response:
    vulkan_h = str(response.read())

with open(out_path / "enums.hpp", "w") as header:
    header.write(
        f"""\
#pragma once
// This file was is autogenerated for Vulkan {VULKAN_SPEC_VERSION}.
// Created: {datetime.datetime.now()}

#include <cstdint>

namespace merian {{

template <typename VK_ENUM_TYPE> constexpr uint32_t enum_size();

template <typename VK_ENUM_TYPE> const VK_ENUM_TYPE* enum_values();

}}
"""
    )


with open(out_path / "enums.cpp", "w") as impl:
    impl.write(
        f"""\
// This file was is autogenerated for Vulkan {VULKAN_SPEC_VERSION}.
// Created: {datetime.datetime.now()}

#include "enums.hpp"

#include <vulkan/vulkan.hpp>

namespace merian {{

"""
    )

    done = []
    for enum in xml.findall("enums"):
        if enum.get("type") != "enum":
            continue
        enum_name = enum.get("name")
        assert enum_name
        # dirty but works
        if enum_name not in vulkan_h:
            continue
        if enum_name in done:
            continue
        done.append(enum_name)

        values = [i.get("name") for i in enum if i.get("name")]

        impl.write(
            f"static constexpr std::array<{enum_name}, {len(values)}> _{enum_name}_values = {{\n    {(',\n    '.join(values))}}};\n\n"
        )

        # print(enum.get("name"))
        # for i in enum:
        # print(i.get("value"))
        # print(i.get("name"))

        impl.write(
            f"""\
template<> constexpr uint32_t enum_size<{enum_name}>() {{
    return _{enum_name}_values.size();
}}

template<> const {enum_name}* enum_values<{enum_name}>() {{
    return _{enum_name}_values.data();
}}

"""
        )

    impl.write("""
}
""")
