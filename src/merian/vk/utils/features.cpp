// This file was autogenerated for Vulkan v1.4.338.
// Created: 2026-01-26 17:28:55.852602
// Do not edit manually!

#include "merian/vk/utils/features.hpp"

#include <optional>
#include <unordered_map>

namespace merian {

// ----------------------------------------------------------------------
// FeaturePhysicalDevice16BitStorage
// Wraps: vk::PhysicalDevice16BitStorageFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDevice16BitStorage : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "storageBuffer16BitAccess",
            "uniformAndStorageBuffer16BitAccess",
            "storagePushConstant16",
            "storageInputOutput16",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "storageBuffer16BitAccess") return features.storageBuffer16BitAccess == VK_TRUE;
        if (name == "uniformAndStorageBuffer16BitAccess") return features.uniformAndStorageBuffer16BitAccess == VK_TRUE;
        if (name == "storagePushConstant16") return features.storagePushConstant16 == VK_TRUE;
        if (name == "storageInputOutput16") return features.storageInputOutput16 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "storageBuffer16BitAccess") { features.storageBuffer16BitAccess = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "uniformAndStorageBuffer16BitAccess") { features.uniformAndStorageBuffer16BitAccess = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "storagePushConstant16") { features.storagePushConstant16 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "storageInputOutput16") { features.storageInputOutput16 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevice16BitStorageFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevice16BitStorageFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevice16BitStorageFeatures& get() { return features; }
    const vk::PhysicalDevice16BitStorageFeatures& get() const { return features; }

  private:
    vk::PhysicalDevice16BitStorageFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevice4444FormatsEXT
// Wraps: vk::PhysicalDevice4444FormatsFeaturesEXT
// Extension: VK_EXT_4444_FORMATS_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDevice4444FormatsEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_4444_FORMATS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "formatA4R4G4B4",
            "formatA4B4G4R4",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "formatA4R4G4B4") return features.formatA4R4G4B4 == VK_TRUE;
        if (name == "formatA4B4G4R4") return features.formatA4B4G4R4 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "formatA4R4G4B4") { features.formatA4R4G4B4 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "formatA4B4G4R4") { features.formatA4B4G4R4 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevice4444FormatsFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevice4444FormatsFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevice4444FormatsFeaturesEXT& get() { return features; }
    const vk::PhysicalDevice4444FormatsFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDevice4444FormatsFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevice8BitStorage
// Wraps: vk::PhysicalDevice8BitStorageFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDevice8BitStorage : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "storageBuffer8BitAccess",
            "uniformAndStorageBuffer8BitAccess",
            "storagePushConstant8",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "storageBuffer8BitAccess") return features.storageBuffer8BitAccess == VK_TRUE;
        if (name == "uniformAndStorageBuffer8BitAccess") return features.uniformAndStorageBuffer8BitAccess == VK_TRUE;
        if (name == "storagePushConstant8") return features.storagePushConstant8 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "storageBuffer8BitAccess") { features.storageBuffer8BitAccess = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "uniformAndStorageBuffer8BitAccess") { features.uniformAndStorageBuffer8BitAccess = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "storagePushConstant8") { features.storagePushConstant8 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevice8BitStorageFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevice8BitStorageFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevice8BitStorageFeatures& get() { return features; }
    const vk::PhysicalDevice8BitStorageFeatures& get() const { return features; }

  private:
    vk::PhysicalDevice8BitStorageFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceASTCDecodeEXT
// Wraps: vk::PhysicalDeviceASTCDecodeFeaturesEXT
// Extension: VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceASTCDecodeEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "decodeModeSharedExponent",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "decodeModeSharedExponent") return features.decodeModeSharedExponent == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "decodeModeSharedExponent") { features.decodeModeSharedExponent = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceASTCDecodeFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceAstcDecodeFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceASTCDecodeFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceASTCDecodeFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceASTCDecodeFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceAccelerationStructureKHR
// Wraps: vk::PhysicalDeviceAccelerationStructureFeaturesKHR
// Extension: VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceAccelerationStructureKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "accelerationStructure",
            "accelerationStructureCaptureReplay",
            "accelerationStructureIndirectBuild",
            "accelerationStructureHostCommands",
            "descriptorBindingAccelerationStructureUpdateAfterBind",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "accelerationStructure") return features.accelerationStructure == VK_TRUE;
        if (name == "accelerationStructureCaptureReplay") return features.accelerationStructureCaptureReplay == VK_TRUE;
        if (name == "accelerationStructureIndirectBuild") return features.accelerationStructureIndirectBuild == VK_TRUE;
        if (name == "accelerationStructureHostCommands") return features.accelerationStructureHostCommands == VK_TRUE;
        if (name == "descriptorBindingAccelerationStructureUpdateAfterBind") return features.descriptorBindingAccelerationStructureUpdateAfterBind == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "accelerationStructure") { features.accelerationStructure = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "accelerationStructureCaptureReplay") { features.accelerationStructureCaptureReplay = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "accelerationStructureIndirectBuild") { features.accelerationStructureIndirectBuild = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "accelerationStructureHostCommands") { features.accelerationStructureHostCommands = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBindingAccelerationStructureUpdateAfterBind") { features.descriptorBindingAccelerationStructureUpdateAfterBind = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceAccelerationStructureFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceAccelerationStructureFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceAccelerationStructureFeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceAccelerationStructureFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceAccelerationStructureFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceAddressBindingReportEXT
// Wraps: vk::PhysicalDeviceAddressBindingReportFeaturesEXT
// Extension: VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceAddressBindingReportEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "reportAddressBinding",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "reportAddressBinding") return features.reportAddressBinding == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "reportAddressBinding") { features.reportAddressBinding = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceAddressBindingReportFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceAddressBindingReportFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceAddressBindingReportFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceAddressBindingReportFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceAddressBindingReportFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceAmigoProfilingSEC
// Wraps: vk::PhysicalDeviceAmigoProfilingFeaturesSEC
// Extension: VK_SEC_AMIGO_PROFILING_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceAmigoProfilingSEC : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_SEC_AMIGO_PROFILING_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "amigoProfiling",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "amigoProfiling") return features.amigoProfiling == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "amigoProfiling") { features.amigoProfiling = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceAmigoProfilingFeaturesSEC";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceAmigoProfilingFeaturesSEC;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceAmigoProfilingFeaturesSEC& get() { return features; }
    const vk::PhysicalDeviceAmigoProfilingFeaturesSEC& get() const { return features; }

  private:
    vk::PhysicalDeviceAmigoProfilingFeaturesSEC features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceAntiLagAMD
// Wraps: vk::PhysicalDeviceAntiLagFeaturesAMD
// Extension: VK_AMD_ANTI_LAG_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceAntiLagAMD : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_AMD_ANTI_LAG_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "antiLag",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "antiLag") return features.antiLag == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "antiLag") { features.antiLag = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceAntiLagFeaturesAMD";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceAntiLagFeaturesAMD;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceAntiLagFeaturesAMD& get() { return features; }
    const vk::PhysicalDeviceAntiLagFeaturesAMD& get() const { return features; }

  private:
    vk::PhysicalDeviceAntiLagFeaturesAMD features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceAttachmentFeedbackLoopDynamicStateEXT
// Wraps: vk::PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT
// Extension: VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceAttachmentFeedbackLoopDynamicStateEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "attachmentFeedbackLoopDynamicState",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "attachmentFeedbackLoopDynamicState") return features.attachmentFeedbackLoopDynamicState == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "attachmentFeedbackLoopDynamicState") { features.attachmentFeedbackLoopDynamicState = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceAttachmentFeedbackLoopLayoutEXT
// Wraps: vk::PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT
// Extension: VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceAttachmentFeedbackLoopLayoutEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "attachmentFeedbackLoopLayout",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "attachmentFeedbackLoopLayout") return features.attachmentFeedbackLoopLayout == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "attachmentFeedbackLoopLayout") { features.attachmentFeedbackLoopLayout = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceBlendOperationAdvancedEXT
// Wraps: vk::PhysicalDeviceBlendOperationAdvancedFeaturesEXT
// Extension: VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceBlendOperationAdvancedEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "advancedBlendCoherentOperations",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "advancedBlendCoherentOperations") return features.advancedBlendCoherentOperations == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "advancedBlendCoherentOperations") { features.advancedBlendCoherentOperations = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceBlendOperationAdvancedFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceBlendOperationAdvancedFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceBlendOperationAdvancedFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceBlendOperationAdvancedFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceBlendOperationAdvancedFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceBorderColorSwizzleEXT
// Wraps: vk::PhysicalDeviceBorderColorSwizzleFeaturesEXT
// Extension: VK_EXT_BORDER_COLOR_SWIZZLE_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceBorderColorSwizzleEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_EXT_BORDER_COLOR_SWIZZLE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "borderColorSwizzle",
            "borderColorSwizzleFromImage",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "borderColorSwizzle") return features.borderColorSwizzle == VK_TRUE;
        if (name == "borderColorSwizzleFromImage") return features.borderColorSwizzleFromImage == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "borderColorSwizzle") { features.borderColorSwizzle = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "borderColorSwizzleFromImage") { features.borderColorSwizzleFromImage = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceBorderColorSwizzleFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceBorderColorSwizzleFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceBorderColorSwizzleFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceBorderColorSwizzleFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceBorderColorSwizzleFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceBufferDeviceAddress
// Wraps: vk::PhysicalDeviceBufferDeviceAddressFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceBufferDeviceAddress : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "bufferDeviceAddress",
            "bufferDeviceAddressCaptureReplay",
            "bufferDeviceAddressMultiDevice",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "bufferDeviceAddress") return features.bufferDeviceAddress == VK_TRUE;
        if (name == "bufferDeviceAddressCaptureReplay") return features.bufferDeviceAddressCaptureReplay == VK_TRUE;
        if (name == "bufferDeviceAddressMultiDevice") return features.bufferDeviceAddressMultiDevice == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "bufferDeviceAddress") { features.bufferDeviceAddress = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "bufferDeviceAddressCaptureReplay") { features.bufferDeviceAddressCaptureReplay = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "bufferDeviceAddressMultiDevice") { features.bufferDeviceAddressMultiDevice = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceBufferDeviceAddressFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceBufferDeviceAddressFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceBufferDeviceAddressFeatures& get() { return features; }
    const vk::PhysicalDeviceBufferDeviceAddressFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceBufferDeviceAddressFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceBufferDeviceAddressEXT
// Wraps: vk::PhysicalDeviceBufferDeviceAddressFeaturesEXT
// Extension: VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceBufferDeviceAddressEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "bufferDeviceAddress",
            "bufferDeviceAddressCaptureReplay",
            "bufferDeviceAddressMultiDevice",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "bufferDeviceAddress") return features.bufferDeviceAddress == VK_TRUE;
        if (name == "bufferDeviceAddressCaptureReplay") return features.bufferDeviceAddressCaptureReplay == VK_TRUE;
        if (name == "bufferDeviceAddressMultiDevice") return features.bufferDeviceAddressMultiDevice == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "bufferDeviceAddress") { features.bufferDeviceAddress = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "bufferDeviceAddressCaptureReplay") { features.bufferDeviceAddressCaptureReplay = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "bufferDeviceAddressMultiDevice") { features.bufferDeviceAddressMultiDevice = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceBufferDeviceAddressFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceBufferDeviceAddressFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceBufferDeviceAddressFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceBufferDeviceAddressFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceBufferDeviceAddressFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceClusterAccelerationStructureNV
// Wraps: vk::PhysicalDeviceClusterAccelerationStructureFeaturesNV
// Extension: VK_NV_CLUSTER_ACCELERATION_STRUCTURE_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceClusterAccelerationStructureNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_NV_CLUSTER_ACCELERATION_STRUCTURE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "clusterAccelerationStructure",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "clusterAccelerationStructure") return features.clusterAccelerationStructure == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "clusterAccelerationStructure") { features.clusterAccelerationStructure = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceClusterAccelerationStructureFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceClusterAccelerationStructureFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceClusterAccelerationStructureFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceClusterAccelerationStructureFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceClusterAccelerationStructureFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceClusterCullingShaderHUAWEI
// Wraps: vk::PhysicalDeviceClusterCullingShaderFeaturesHUAWEI
// Extension: VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceClusterCullingShaderHUAWEI : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "clustercullingShader",
            "multiviewClusterCullingShader",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "clustercullingShader") return features.clustercullingShader == VK_TRUE;
        if (name == "multiviewClusterCullingShader") return features.multiviewClusterCullingShader == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "clustercullingShader") { features.clustercullingShader = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "multiviewClusterCullingShader") { features.multiviewClusterCullingShader = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceClusterCullingShaderFeaturesHUAWEI";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceClusterCullingShaderFeaturesHUAWEI;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceClusterCullingShaderFeaturesHUAWEI& get() { return features; }
    const vk::PhysicalDeviceClusterCullingShaderFeaturesHUAWEI& get() const { return features; }

  private:
    vk::PhysicalDeviceClusterCullingShaderFeaturesHUAWEI features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceCoherentMemoryAMD
// Wraps: vk::PhysicalDeviceCoherentMemoryFeaturesAMD
// Extension: VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceCoherentMemoryAMD : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "deviceCoherentMemory",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "deviceCoherentMemory") return features.deviceCoherentMemory == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "deviceCoherentMemory") { features.deviceCoherentMemory = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceCoherentMemoryFeaturesAMD";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceCoherentMemoryFeaturesAMD;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceCoherentMemoryFeaturesAMD& get() { return features; }
    const vk::PhysicalDeviceCoherentMemoryFeaturesAMD& get() const { return features; }

  private:
    vk::PhysicalDeviceCoherentMemoryFeaturesAMD features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceColorWriteEnableEXT
// Wraps: vk::PhysicalDeviceColorWriteEnableFeaturesEXT
// Extension: VK_EXT_COLOR_WRITE_ENABLE_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceColorWriteEnableEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_COLOR_WRITE_ENABLE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "colorWriteEnable",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "colorWriteEnable") return features.colorWriteEnable == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "colorWriteEnable") { features.colorWriteEnable = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceColorWriteEnableFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceColorWriteEnableFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceColorWriteEnableFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceColorWriteEnableFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceColorWriteEnableFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceCommandBufferInheritanceNV
// Wraps: vk::PhysicalDeviceCommandBufferInheritanceFeaturesNV
// Extension: VK_NV_COMMAND_BUFFER_INHERITANCE_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceCommandBufferInheritanceNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_COMMAND_BUFFER_INHERITANCE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "commandBufferInheritance",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "commandBufferInheritance") return features.commandBufferInheritance == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "commandBufferInheritance") { features.commandBufferInheritance = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceCommandBufferInheritanceFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceCommandBufferInheritanceFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceCommandBufferInheritanceFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceCommandBufferInheritanceFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceCommandBufferInheritanceFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceComputeOccupancyPriorityNV
// Wraps: vk::PhysicalDeviceComputeOccupancyPriorityFeaturesNV
// Extension: VK_NV_COMPUTE_OCCUPANCY_PRIORITY_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceComputeOccupancyPriorityNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_COMPUTE_OCCUPANCY_PRIORITY_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "computeOccupancyPriority",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "computeOccupancyPriority") return features.computeOccupancyPriority == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "computeOccupancyPriority") { features.computeOccupancyPriority = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceComputeOccupancyPriorityFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceComputeOccupancyPriorityFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceComputeOccupancyPriorityFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceComputeOccupancyPriorityFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceComputeOccupancyPriorityFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceComputeShaderDerivativesKHR
// Wraps: vk::PhysicalDeviceComputeShaderDerivativesFeaturesKHR
// Extension: VK_KHR_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceComputeShaderDerivativesKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "computeDerivativeGroupQuads",
            "computeDerivativeGroupLinear",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "computeDerivativeGroupQuads") return features.computeDerivativeGroupQuads == VK_TRUE;
        if (name == "computeDerivativeGroupLinear") return features.computeDerivativeGroupLinear == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "computeDerivativeGroupQuads") { features.computeDerivativeGroupQuads = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "computeDerivativeGroupLinear") { features.computeDerivativeGroupLinear = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceComputeShaderDerivativesFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceComputeShaderDerivativesFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceComputeShaderDerivativesFeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceComputeShaderDerivativesFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceComputeShaderDerivativesFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceConditionalRenderingEXT
// Wraps: vk::PhysicalDeviceConditionalRenderingFeaturesEXT
// Extension: VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceConditionalRenderingEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "conditionalRendering",
            "inheritedConditionalRendering",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "conditionalRendering") return features.conditionalRendering == VK_TRUE;
        if (name == "inheritedConditionalRendering") return features.inheritedConditionalRendering == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "conditionalRendering") { features.conditionalRendering = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "inheritedConditionalRendering") { features.inheritedConditionalRendering = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceConditionalRenderingFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceConditionalRenderingFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceConditionalRenderingFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceConditionalRenderingFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceConditionalRenderingFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceCooperativeMatrix2NV
// Wraps: vk::PhysicalDeviceCooperativeMatrix2FeaturesNV
// Extension: VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceCooperativeMatrix2NV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "cooperativeMatrixWorkgroupScope",
            "cooperativeMatrixFlexibleDimensions",
            "cooperativeMatrixReductions",
            "cooperativeMatrixConversions",
            "cooperativeMatrixPerElementOperations",
            "cooperativeMatrixTensorAddressing",
            "cooperativeMatrixBlockLoads",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "cooperativeMatrixWorkgroupScope") return features.cooperativeMatrixWorkgroupScope == VK_TRUE;
        if (name == "cooperativeMatrixFlexibleDimensions") return features.cooperativeMatrixFlexibleDimensions == VK_TRUE;
        if (name == "cooperativeMatrixReductions") return features.cooperativeMatrixReductions == VK_TRUE;
        if (name == "cooperativeMatrixConversions") return features.cooperativeMatrixConversions == VK_TRUE;
        if (name == "cooperativeMatrixPerElementOperations") return features.cooperativeMatrixPerElementOperations == VK_TRUE;
        if (name == "cooperativeMatrixTensorAddressing") return features.cooperativeMatrixTensorAddressing == VK_TRUE;
        if (name == "cooperativeMatrixBlockLoads") return features.cooperativeMatrixBlockLoads == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "cooperativeMatrixWorkgroupScope") { features.cooperativeMatrixWorkgroupScope = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "cooperativeMatrixFlexibleDimensions") { features.cooperativeMatrixFlexibleDimensions = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "cooperativeMatrixReductions") { features.cooperativeMatrixReductions = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "cooperativeMatrixConversions") { features.cooperativeMatrixConversions = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "cooperativeMatrixPerElementOperations") { features.cooperativeMatrixPerElementOperations = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "cooperativeMatrixTensorAddressing") { features.cooperativeMatrixTensorAddressing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "cooperativeMatrixBlockLoads") { features.cooperativeMatrixBlockLoads = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceCooperativeMatrix2FeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceCooperativeMatrix2FeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceCooperativeMatrix2FeaturesNV& get() { return features; }
    const vk::PhysicalDeviceCooperativeMatrix2FeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceCooperativeMatrix2FeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceCooperativeMatrixKHR
// Wraps: vk::PhysicalDeviceCooperativeMatrixFeaturesKHR
// Extension: VK_KHR_COOPERATIVE_MATRIX_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceCooperativeMatrixKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_COOPERATIVE_MATRIX_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "cooperativeMatrix",
            "cooperativeMatrixRobustBufferAccess",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "cooperativeMatrix") return features.cooperativeMatrix == VK_TRUE;
        if (name == "cooperativeMatrixRobustBufferAccess") return features.cooperativeMatrixRobustBufferAccess == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "cooperativeMatrix") { features.cooperativeMatrix = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "cooperativeMatrixRobustBufferAccess") { features.cooperativeMatrixRobustBufferAccess = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceCooperativeMatrixFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceCooperativeMatrixFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceCooperativeMatrixFeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceCooperativeMatrixFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceCooperativeMatrixFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceCooperativeMatrixNV
// Wraps: vk::PhysicalDeviceCooperativeMatrixFeaturesNV
// Extension: VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceCooperativeMatrixNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "cooperativeMatrix",
            "cooperativeMatrixRobustBufferAccess",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "cooperativeMatrix") return features.cooperativeMatrix == VK_TRUE;
        if (name == "cooperativeMatrixRobustBufferAccess") return features.cooperativeMatrixRobustBufferAccess == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "cooperativeMatrix") { features.cooperativeMatrix = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "cooperativeMatrixRobustBufferAccess") { features.cooperativeMatrixRobustBufferAccess = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceCooperativeMatrixFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceCooperativeMatrixFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceCooperativeMatrixFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceCooperativeMatrixFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceCooperativeMatrixFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceCooperativeVectorNV
// Wraps: vk::PhysicalDeviceCooperativeVectorFeaturesNV
// Extension: VK_NV_COOPERATIVE_VECTOR_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceCooperativeVectorNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_COOPERATIVE_VECTOR_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "cooperativeVector",
            "cooperativeVectorTraining",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "cooperativeVector") return features.cooperativeVector == VK_TRUE;
        if (name == "cooperativeVectorTraining") return features.cooperativeVectorTraining == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "cooperativeVector") { features.cooperativeVector = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "cooperativeVectorTraining") { features.cooperativeVectorTraining = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceCooperativeVectorFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceCooperativeVectorFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceCooperativeVectorFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceCooperativeVectorFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceCooperativeVectorFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceCopyMemoryIndirectKHR
// Wraps: vk::PhysicalDeviceCopyMemoryIndirectFeaturesKHR
// Extension: VK_KHR_COPY_MEMORY_INDIRECT_EXTENSION_NAME
// Core in: VK_API_VERSION_1_2
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceCopyMemoryIndirectKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_2) {
            return {};
        }
        return {VK_KHR_COPY_MEMORY_INDIRECT_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "indirectMemoryCopy",
            "indirectMemoryToImageCopy",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "indirectMemoryCopy") return features.indirectMemoryCopy == VK_TRUE;
        if (name == "indirectMemoryToImageCopy") return features.indirectMemoryToImageCopy == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "indirectMemoryCopy") { features.indirectMemoryCopy = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "indirectMemoryToImageCopy") { features.indirectMemoryToImageCopy = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceCopyMemoryIndirectFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceCopyMemoryIndirectFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceCopyMemoryIndirectFeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceCopyMemoryIndirectFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceCopyMemoryIndirectFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceCopyMemoryIndirectNV
// Wraps: vk::PhysicalDeviceCopyMemoryIndirectFeaturesNV
// Extension: VK_NV_COPY_MEMORY_INDIRECT_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceCopyMemoryIndirectNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_COPY_MEMORY_INDIRECT_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "indirectCopy",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "indirectCopy") return features.indirectCopy == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "indirectCopy") { features.indirectCopy = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceCopyMemoryIndirectFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceCopyMemoryIndirectFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceCopyMemoryIndirectFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceCopyMemoryIndirectFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceCopyMemoryIndirectFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceCornerSampledImageNV
// Wraps: vk::PhysicalDeviceCornerSampledImageFeaturesNV
// Extension: VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceCornerSampledImageNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "cornerSampledImage",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "cornerSampledImage") return features.cornerSampledImage == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "cornerSampledImage") { features.cornerSampledImage = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceCornerSampledImageFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceCornerSampledImageFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceCornerSampledImageFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceCornerSampledImageFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceCornerSampledImageFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceCoverageReductionModeNV
// Wraps: vk::PhysicalDeviceCoverageReductionModeFeaturesNV
// Extension: VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceCoverageReductionModeNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "coverageReductionMode",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "coverageReductionMode") return features.coverageReductionMode == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "coverageReductionMode") { features.coverageReductionMode = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceCoverageReductionModeFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceCoverageReductionModeFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceCoverageReductionModeFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceCoverageReductionModeFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceCoverageReductionModeFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceCubicClampQCOM
// Wraps: vk::PhysicalDeviceCubicClampFeaturesQCOM
// Extension: VK_QCOM_FILTER_CUBIC_CLAMP_EXTENSION_NAME
// Core in: VK_API_VERSION_1_2
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceCubicClampQCOM : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_2) {
            return {};
        }
        return {VK_QCOM_FILTER_CUBIC_CLAMP_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "cubicRangeClamp",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "cubicRangeClamp") return features.cubicRangeClamp == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "cubicRangeClamp") { features.cubicRangeClamp = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceCubicClampFeaturesQCOM";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceCubicClampFeaturesQCOM;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceCubicClampFeaturesQCOM& get() { return features; }
    const vk::PhysicalDeviceCubicClampFeaturesQCOM& get() const { return features; }

  private:
    vk::PhysicalDeviceCubicClampFeaturesQCOM features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceCubicWeightsQCOM
// Wraps: vk::PhysicalDeviceCubicWeightsFeaturesQCOM
// Extension: VK_QCOM_FILTER_CUBIC_WEIGHTS_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceCubicWeightsQCOM : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_QCOM_FILTER_CUBIC_WEIGHTS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "selectableCubicWeights",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "selectableCubicWeights") return features.selectableCubicWeights == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "selectableCubicWeights") { features.selectableCubicWeights = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceCubicWeightsFeaturesQCOM";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceCubicWeightsFeaturesQCOM;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceCubicWeightsFeaturesQCOM& get() { return features; }
    const vk::PhysicalDeviceCubicWeightsFeaturesQCOM& get() const { return features; }

  private:
    vk::PhysicalDeviceCubicWeightsFeaturesQCOM features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceCustomBorderColorEXT
// Wraps: vk::PhysicalDeviceCustomBorderColorFeaturesEXT
// Extension: VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceCustomBorderColorEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "customBorderColors",
            "customBorderColorWithoutFormat",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "customBorderColors") return features.customBorderColors == VK_TRUE;
        if (name == "customBorderColorWithoutFormat") return features.customBorderColorWithoutFormat == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "customBorderColors") { features.customBorderColors = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "customBorderColorWithoutFormat") { features.customBorderColorWithoutFormat = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceCustomBorderColorFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceCustomBorderColorFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceCustomBorderColorFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceCustomBorderColorFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceCustomBorderColorFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceCustomResolveEXT
// Wraps: vk::PhysicalDeviceCustomResolveFeaturesEXT
// Extension: VK_EXT_CUSTOM_RESOLVE_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceCustomResolveEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_CUSTOM_RESOLVE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "customResolve",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "customResolve") return features.customResolve == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "customResolve") { features.customResolve = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceCustomResolveFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceCustomResolveFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceCustomResolveFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceCustomResolveFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceCustomResolveFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceDataGraphARM
// Wraps: vk::PhysicalDeviceDataGraphFeaturesARM
// Extension: VK_ARM_DATA_GRAPH_EXTENSION_NAME
// Core in: VK_API_VERSION_1_3
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceDataGraphARM : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_3) {
            return {};
        }
        return {VK_ARM_DATA_GRAPH_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "dataGraph",
            "dataGraphUpdateAfterBind",
            "dataGraphSpecializationConstants",
            "dataGraphDescriptorBuffer",
            "dataGraphShaderModule",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "dataGraph") return features.dataGraph == VK_TRUE;
        if (name == "dataGraphUpdateAfterBind") return features.dataGraphUpdateAfterBind == VK_TRUE;
        if (name == "dataGraphSpecializationConstants") return features.dataGraphSpecializationConstants == VK_TRUE;
        if (name == "dataGraphDescriptorBuffer") return features.dataGraphDescriptorBuffer == VK_TRUE;
        if (name == "dataGraphShaderModule") return features.dataGraphShaderModule == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "dataGraph") { features.dataGraph = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "dataGraphUpdateAfterBind") { features.dataGraphUpdateAfterBind = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "dataGraphSpecializationConstants") { features.dataGraphSpecializationConstants = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "dataGraphDescriptorBuffer") { features.dataGraphDescriptorBuffer = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "dataGraphShaderModule") { features.dataGraphShaderModule = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceDataGraphFeaturesARM";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceDataGraphFeaturesARM;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceDataGraphFeaturesARM& get() { return features; }
    const vk::PhysicalDeviceDataGraphFeaturesARM& get() const { return features; }

  private:
    vk::PhysicalDeviceDataGraphFeaturesARM features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceDataGraphModelQCOM
// Wraps: vk::PhysicalDeviceDataGraphModelFeaturesQCOM
// Extension: VK_QCOM_DATA_GRAPH_MODEL_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceDataGraphModelQCOM : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_QCOM_DATA_GRAPH_MODEL_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "dataGraphModel",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "dataGraphModel") return features.dataGraphModel == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "dataGraphModel") { features.dataGraphModel = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceDataGraphModelFeaturesQCOM";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceDataGraphModelFeaturesQCOM;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceDataGraphModelFeaturesQCOM& get() { return features; }
    const vk::PhysicalDeviceDataGraphModelFeaturesQCOM& get() const { return features; }

  private:
    vk::PhysicalDeviceDataGraphModelFeaturesQCOM features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceDedicatedAllocationImageAliasingNV
// Wraps: vk::PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV
// Extension: VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceDedicatedAllocationImageAliasingNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "dedicatedAllocationImageAliasing",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "dedicatedAllocationImageAliasing") return features.dedicatedAllocationImageAliasing == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "dedicatedAllocationImageAliasing") { features.dedicatedAllocationImageAliasing = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceDepthBiasControlEXT
// Wraps: vk::PhysicalDeviceDepthBiasControlFeaturesEXT
// Extension: VK_EXT_DEPTH_BIAS_CONTROL_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceDepthBiasControlEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_DEPTH_BIAS_CONTROL_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "depthBiasControl",
            "leastRepresentableValueForceUnormRepresentation",
            "floatRepresentation",
            "depthBiasExact",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "depthBiasControl") return features.depthBiasControl == VK_TRUE;
        if (name == "leastRepresentableValueForceUnormRepresentation") return features.leastRepresentableValueForceUnormRepresentation == VK_TRUE;
        if (name == "floatRepresentation") return features.floatRepresentation == VK_TRUE;
        if (name == "depthBiasExact") return features.depthBiasExact == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "depthBiasControl") { features.depthBiasControl = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "leastRepresentableValueForceUnormRepresentation") { features.leastRepresentableValueForceUnormRepresentation = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "floatRepresentation") { features.floatRepresentation = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "depthBiasExact") { features.depthBiasExact = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceDepthBiasControlFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceDepthBiasControlFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceDepthBiasControlFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceDepthBiasControlFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceDepthBiasControlFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceDepthClampControlEXT
// Wraps: vk::PhysicalDeviceDepthClampControlFeaturesEXT
// Extension: VK_EXT_DEPTH_CLAMP_CONTROL_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceDepthClampControlEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_DEPTH_CLAMP_CONTROL_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "depthClampControl",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "depthClampControl") return features.depthClampControl == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "depthClampControl") { features.depthClampControl = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceDepthClampControlFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceDepthClampControlFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceDepthClampControlFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceDepthClampControlFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceDepthClampControlFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceDepthClampZeroOneKHR
// Wraps: vk::PhysicalDeviceDepthClampZeroOneFeaturesKHR
// Extension: VK_KHR_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceDepthClampZeroOneKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "depthClampZeroOne",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "depthClampZeroOne") return features.depthClampZeroOne == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "depthClampZeroOne") { features.depthClampZeroOne = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceDepthClampZeroOneFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceDepthClampZeroOneFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceDepthClampZeroOneFeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceDepthClampZeroOneFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceDepthClampZeroOneFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceDepthClipControlEXT
// Wraps: vk::PhysicalDeviceDepthClipControlFeaturesEXT
// Extension: VK_EXT_DEPTH_CLIP_CONTROL_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceDepthClipControlEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_DEPTH_CLIP_CONTROL_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "depthClipControl",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "depthClipControl") return features.depthClipControl == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "depthClipControl") { features.depthClipControl = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceDepthClipControlFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceDepthClipControlFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceDepthClipControlFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceDepthClipControlFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceDepthClipControlFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceDepthClipEnableEXT
// Wraps: vk::PhysicalDeviceDepthClipEnableFeaturesEXT
// Extension: VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceDepthClipEnableEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "depthClipEnable",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "depthClipEnable") return features.depthClipEnable == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "depthClipEnable") { features.depthClipEnable = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceDepthClipEnableFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceDepthClipEnableFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceDepthClipEnableFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceDepthClipEnableFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceDepthClipEnableFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceDescriptorBufferEXT
// Wraps: vk::PhysicalDeviceDescriptorBufferFeaturesEXT
// Extension: VK_EXT_DESCRIPTOR_BUFFER_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceDescriptorBufferEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_DESCRIPTOR_BUFFER_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "descriptorBuffer",
            "descriptorBufferCaptureReplay",
            "descriptorBufferImageLayoutIgnored",
            "descriptorBufferPushDescriptors",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "descriptorBuffer") return features.descriptorBuffer == VK_TRUE;
        if (name == "descriptorBufferCaptureReplay") return features.descriptorBufferCaptureReplay == VK_TRUE;
        if (name == "descriptorBufferImageLayoutIgnored") return features.descriptorBufferImageLayoutIgnored == VK_TRUE;
        if (name == "descriptorBufferPushDescriptors") return features.descriptorBufferPushDescriptors == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "descriptorBuffer") { features.descriptorBuffer = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBufferCaptureReplay") { features.descriptorBufferCaptureReplay = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBufferImageLayoutIgnored") { features.descriptorBufferImageLayoutIgnored = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBufferPushDescriptors") { features.descriptorBufferPushDescriptors = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceDescriptorBufferFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceDescriptorBufferFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceDescriptorBufferFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceDescriptorBufferFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceDescriptorBufferFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceDescriptorBufferTensorARM
// Wraps: vk::PhysicalDeviceDescriptorBufferTensorFeaturesARM
// Extension: VK_ARM_TENSORS_EXTENSION_NAME
// Core in: VK_API_VERSION_1_3
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceDescriptorBufferTensorARM : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_3) {
            return {};
        }
        return {VK_ARM_TENSORS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "descriptorBufferTensorDescriptors",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "descriptorBufferTensorDescriptors") return features.descriptorBufferTensorDescriptors == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "descriptorBufferTensorDescriptors") { features.descriptorBufferTensorDescriptors = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceDescriptorBufferTensorFeaturesARM";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceDescriptorBufferTensorFeaturesARM;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceDescriptorBufferTensorFeaturesARM& get() { return features; }
    const vk::PhysicalDeviceDescriptorBufferTensorFeaturesARM& get() const { return features; }

  private:
    vk::PhysicalDeviceDescriptorBufferTensorFeaturesARM features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceDescriptorIndexing
// Wraps: vk::PhysicalDeviceDescriptorIndexingFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceDescriptorIndexing : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderInputAttachmentArrayDynamicIndexing",
            "shaderUniformTexelBufferArrayDynamicIndexing",
            "shaderStorageTexelBufferArrayDynamicIndexing",
            "shaderUniformBufferArrayNonUniformIndexing",
            "shaderSampledImageArrayNonUniformIndexing",
            "shaderStorageBufferArrayNonUniformIndexing",
            "shaderStorageImageArrayNonUniformIndexing",
            "shaderInputAttachmentArrayNonUniformIndexing",
            "shaderUniformTexelBufferArrayNonUniformIndexing",
            "shaderStorageTexelBufferArrayNonUniformIndexing",
            "descriptorBindingUniformBufferUpdateAfterBind",
            "descriptorBindingSampledImageUpdateAfterBind",
            "descriptorBindingStorageImageUpdateAfterBind",
            "descriptorBindingStorageBufferUpdateAfterBind",
            "descriptorBindingUniformTexelBufferUpdateAfterBind",
            "descriptorBindingStorageTexelBufferUpdateAfterBind",
            "descriptorBindingUpdateUnusedWhilePending",
            "descriptorBindingPartiallyBound",
            "descriptorBindingVariableDescriptorCount",
            "runtimeDescriptorArray",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderInputAttachmentArrayDynamicIndexing") return features.shaderInputAttachmentArrayDynamicIndexing == VK_TRUE;
        if (name == "shaderUniformTexelBufferArrayDynamicIndexing") return features.shaderUniformTexelBufferArrayDynamicIndexing == VK_TRUE;
        if (name == "shaderStorageTexelBufferArrayDynamicIndexing") return features.shaderStorageTexelBufferArrayDynamicIndexing == VK_TRUE;
        if (name == "shaderUniformBufferArrayNonUniformIndexing") return features.shaderUniformBufferArrayNonUniformIndexing == VK_TRUE;
        if (name == "shaderSampledImageArrayNonUniformIndexing") return features.shaderSampledImageArrayNonUniformIndexing == VK_TRUE;
        if (name == "shaderStorageBufferArrayNonUniformIndexing") return features.shaderStorageBufferArrayNonUniformIndexing == VK_TRUE;
        if (name == "shaderStorageImageArrayNonUniformIndexing") return features.shaderStorageImageArrayNonUniformIndexing == VK_TRUE;
        if (name == "shaderInputAttachmentArrayNonUniformIndexing") return features.shaderInputAttachmentArrayNonUniformIndexing == VK_TRUE;
        if (name == "shaderUniformTexelBufferArrayNonUniformIndexing") return features.shaderUniformTexelBufferArrayNonUniformIndexing == VK_TRUE;
        if (name == "shaderStorageTexelBufferArrayNonUniformIndexing") return features.shaderStorageTexelBufferArrayNonUniformIndexing == VK_TRUE;
        if (name == "descriptorBindingUniformBufferUpdateAfterBind") return features.descriptorBindingUniformBufferUpdateAfterBind == VK_TRUE;
        if (name == "descriptorBindingSampledImageUpdateAfterBind") return features.descriptorBindingSampledImageUpdateAfterBind == VK_TRUE;
        if (name == "descriptorBindingStorageImageUpdateAfterBind") return features.descriptorBindingStorageImageUpdateAfterBind == VK_TRUE;
        if (name == "descriptorBindingStorageBufferUpdateAfterBind") return features.descriptorBindingStorageBufferUpdateAfterBind == VK_TRUE;
        if (name == "descriptorBindingUniformTexelBufferUpdateAfterBind") return features.descriptorBindingUniformTexelBufferUpdateAfterBind == VK_TRUE;
        if (name == "descriptorBindingStorageTexelBufferUpdateAfterBind") return features.descriptorBindingStorageTexelBufferUpdateAfterBind == VK_TRUE;
        if (name == "descriptorBindingUpdateUnusedWhilePending") return features.descriptorBindingUpdateUnusedWhilePending == VK_TRUE;
        if (name == "descriptorBindingPartiallyBound") return features.descriptorBindingPartiallyBound == VK_TRUE;
        if (name == "descriptorBindingVariableDescriptorCount") return features.descriptorBindingVariableDescriptorCount == VK_TRUE;
        if (name == "runtimeDescriptorArray") return features.runtimeDescriptorArray == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderInputAttachmentArrayDynamicIndexing") { features.shaderInputAttachmentArrayDynamicIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderUniformTexelBufferArrayDynamicIndexing") { features.shaderUniformTexelBufferArrayDynamicIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderStorageTexelBufferArrayDynamicIndexing") { features.shaderStorageTexelBufferArrayDynamicIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderUniformBufferArrayNonUniformIndexing") { features.shaderUniformBufferArrayNonUniformIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderSampledImageArrayNonUniformIndexing") { features.shaderSampledImageArrayNonUniformIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderStorageBufferArrayNonUniformIndexing") { features.shaderStorageBufferArrayNonUniformIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderStorageImageArrayNonUniformIndexing") { features.shaderStorageImageArrayNonUniformIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderInputAttachmentArrayNonUniformIndexing") { features.shaderInputAttachmentArrayNonUniformIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderUniformTexelBufferArrayNonUniformIndexing") { features.shaderUniformTexelBufferArrayNonUniformIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderStorageTexelBufferArrayNonUniformIndexing") { features.shaderStorageTexelBufferArrayNonUniformIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBindingUniformBufferUpdateAfterBind") { features.descriptorBindingUniformBufferUpdateAfterBind = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBindingSampledImageUpdateAfterBind") { features.descriptorBindingSampledImageUpdateAfterBind = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBindingStorageImageUpdateAfterBind") { features.descriptorBindingStorageImageUpdateAfterBind = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBindingStorageBufferUpdateAfterBind") { features.descriptorBindingStorageBufferUpdateAfterBind = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBindingUniformTexelBufferUpdateAfterBind") { features.descriptorBindingUniformTexelBufferUpdateAfterBind = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBindingStorageTexelBufferUpdateAfterBind") { features.descriptorBindingStorageTexelBufferUpdateAfterBind = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBindingUpdateUnusedWhilePending") { features.descriptorBindingUpdateUnusedWhilePending = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBindingPartiallyBound") { features.descriptorBindingPartiallyBound = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBindingVariableDescriptorCount") { features.descriptorBindingVariableDescriptorCount = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "runtimeDescriptorArray") { features.runtimeDescriptorArray = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceDescriptorIndexingFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceDescriptorIndexingFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceDescriptorIndexingFeatures& get() { return features; }
    const vk::PhysicalDeviceDescriptorIndexingFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceDescriptorIndexingFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceDescriptorPoolOverallocationNV
// Wraps: vk::PhysicalDeviceDescriptorPoolOverallocationFeaturesNV
// Extension: VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceDescriptorPoolOverallocationNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "descriptorPoolOverallocation",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "descriptorPoolOverallocation") return features.descriptorPoolOverallocation == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "descriptorPoolOverallocation") { features.descriptorPoolOverallocation = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceDescriptorPoolOverallocationFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceDescriptorPoolOverallocationFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceDescriptorPoolOverallocationFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceDescriptorPoolOverallocationFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceDescriptorPoolOverallocationFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceDescriptorSetHostMappingVALVE
// Wraps: vk::PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE
// Extension: VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceDescriptorSetHostMappingVALVE : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "descriptorSetHostMapping",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "descriptorSetHostMapping") return features.descriptorSetHostMapping == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "descriptorSetHostMapping") { features.descriptorSetHostMapping = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceDescriptorSetHostMappingFeaturesVALVE;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE& get() { return features; }
    const vk::PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE& get() const { return features; }

  private:
    vk::PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceDeviceGeneratedCommandsComputeNV
// Wraps: vk::PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV
// Extension: VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceDeviceGeneratedCommandsComputeNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "deviceGeneratedCompute",
            "deviceGeneratedComputePipelines",
            "deviceGeneratedComputeCaptureReplay",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "deviceGeneratedCompute") return features.deviceGeneratedCompute == VK_TRUE;
        if (name == "deviceGeneratedComputePipelines") return features.deviceGeneratedComputePipelines == VK_TRUE;
        if (name == "deviceGeneratedComputeCaptureReplay") return features.deviceGeneratedComputeCaptureReplay == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "deviceGeneratedCompute") { features.deviceGeneratedCompute = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "deviceGeneratedComputePipelines") { features.deviceGeneratedComputePipelines = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "deviceGeneratedComputeCaptureReplay") { features.deviceGeneratedComputeCaptureReplay = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceDeviceGeneratedCommandsEXT
// Wraps: vk::PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT
// Extension: VK_EXT_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME
// Core in: VK_API_VERSION_1_2
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceDeviceGeneratedCommandsEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_2) {
            return {};
        }
        return {VK_EXT_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "deviceGeneratedCommands",
            "dynamicGeneratedPipelineLayout",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "deviceGeneratedCommands") return features.deviceGeneratedCommands == VK_TRUE;
        if (name == "dynamicGeneratedPipelineLayout") return features.dynamicGeneratedPipelineLayout == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "deviceGeneratedCommands") { features.deviceGeneratedCommands = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "dynamicGeneratedPipelineLayout") { features.dynamicGeneratedPipelineLayout = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceDeviceGeneratedCommandsFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceDeviceGeneratedCommandsNV
// Wraps: vk::PhysicalDeviceDeviceGeneratedCommandsFeaturesNV
// Extension: VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceDeviceGeneratedCommandsNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "deviceGeneratedCommands",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "deviceGeneratedCommands") return features.deviceGeneratedCommands == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "deviceGeneratedCommands") { features.deviceGeneratedCommands = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceDeviceGeneratedCommandsFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceDeviceGeneratedCommandsFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceDeviceGeneratedCommandsFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceDeviceGeneratedCommandsFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceDeviceGeneratedCommandsFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceDeviceMemoryReportEXT
// Wraps: vk::PhysicalDeviceDeviceMemoryReportFeaturesEXT
// Extension: VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceDeviceMemoryReportEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "deviceMemoryReport",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "deviceMemoryReport") return features.deviceMemoryReport == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "deviceMemoryReport") { features.deviceMemoryReport = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceDeviceMemoryReportFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceDeviceMemoryReportFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceDeviceMemoryReportFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceDeviceMemoryReportFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceDeviceMemoryReportFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceDiagnosticsConfigNV
// Wraps: vk::PhysicalDeviceDiagnosticsConfigFeaturesNV
// Extension: VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceDiagnosticsConfigNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "diagnosticsConfig",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "diagnosticsConfig") return features.diagnosticsConfig == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "diagnosticsConfig") { features.diagnosticsConfig = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceDiagnosticsConfigFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceDiagnosticsConfigFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceDiagnosticsConfigFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceDiagnosticsConfigFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceDiagnosticsConfigFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceDynamicRendering
// Wraps: vk::PhysicalDeviceDynamicRenderingFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceDynamicRendering : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "dynamicRendering",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "dynamicRendering") return features.dynamicRendering == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "dynamicRendering") { features.dynamicRendering = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceDynamicRenderingFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceDynamicRenderingFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceDynamicRenderingFeatures& get() { return features; }
    const vk::PhysicalDeviceDynamicRenderingFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceDynamicRenderingFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceDynamicRenderingLocalRead
// Wraps: vk::PhysicalDeviceDynamicRenderingLocalReadFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceDynamicRenderingLocalRead : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "dynamicRenderingLocalRead",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "dynamicRenderingLocalRead") return features.dynamicRenderingLocalRead == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "dynamicRenderingLocalRead") { features.dynamicRenderingLocalRead = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceDynamicRenderingLocalReadFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceDynamicRenderingLocalReadFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceDynamicRenderingLocalReadFeatures& get() { return features; }
    const vk::PhysicalDeviceDynamicRenderingLocalReadFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceDynamicRenderingLocalReadFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceDynamicRenderingUnusedAttachmentsEXT
// Wraps: vk::PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT
// Extension: VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceDynamicRenderingUnusedAttachmentsEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "dynamicRenderingUnusedAttachments",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "dynamicRenderingUnusedAttachments") return features.dynamicRenderingUnusedAttachments == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "dynamicRenderingUnusedAttachments") { features.dynamicRenderingUnusedAttachments = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceExclusiveScissorNV
// Wraps: vk::PhysicalDeviceExclusiveScissorFeaturesNV
// Extension: VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceExclusiveScissorNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "exclusiveScissor",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "exclusiveScissor") return features.exclusiveScissor == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "exclusiveScissor") { features.exclusiveScissor = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceExclusiveScissorFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceExclusiveScissorFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceExclusiveScissorFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceExclusiveScissorFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceExclusiveScissorFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceExtendedDynamicState2EXT
// Wraps: vk::PhysicalDeviceExtendedDynamicState2FeaturesEXT
// Extension: VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceExtendedDynamicState2EXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "extendedDynamicState2",
            "extendedDynamicState2LogicOp",
            "extendedDynamicState2PatchControlPoints",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "extendedDynamicState2") return features.extendedDynamicState2 == VK_TRUE;
        if (name == "extendedDynamicState2LogicOp") return features.extendedDynamicState2LogicOp == VK_TRUE;
        if (name == "extendedDynamicState2PatchControlPoints") return features.extendedDynamicState2PatchControlPoints == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "extendedDynamicState2") { features.extendedDynamicState2 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState2LogicOp") { features.extendedDynamicState2LogicOp = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState2PatchControlPoints") { features.extendedDynamicState2PatchControlPoints = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceExtendedDynamicState2FeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceExtendedDynamicState2FeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceExtendedDynamicState2FeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceExtendedDynamicState2FeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceExtendedDynamicState2FeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceExtendedDynamicState3EXT
// Wraps: vk::PhysicalDeviceExtendedDynamicState3FeaturesEXT
// Extension: VK_EXT_EXTENDED_DYNAMIC_STATE_3_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceExtendedDynamicState3EXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_EXTENDED_DYNAMIC_STATE_3_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "extendedDynamicState3TessellationDomainOrigin",
            "extendedDynamicState3DepthClampEnable",
            "extendedDynamicState3PolygonMode",
            "extendedDynamicState3RasterizationSamples",
            "extendedDynamicState3SampleMask",
            "extendedDynamicState3AlphaToCoverageEnable",
            "extendedDynamicState3AlphaToOneEnable",
            "extendedDynamicState3LogicOpEnable",
            "extendedDynamicState3ColorBlendEnable",
            "extendedDynamicState3ColorBlendEquation",
            "extendedDynamicState3ColorWriteMask",
            "extendedDynamicState3RasterizationStream",
            "extendedDynamicState3ConservativeRasterizationMode",
            "extendedDynamicState3ExtraPrimitiveOverestimationSize",
            "extendedDynamicState3DepthClipEnable",
            "extendedDynamicState3SampleLocationsEnable",
            "extendedDynamicState3ColorBlendAdvanced",
            "extendedDynamicState3ProvokingVertexMode",
            "extendedDynamicState3LineRasterizationMode",
            "extendedDynamicState3LineStippleEnable",
            "extendedDynamicState3DepthClipNegativeOneToOne",
            "extendedDynamicState3ViewportWScalingEnable",
            "extendedDynamicState3ViewportSwizzle",
            "extendedDynamicState3CoverageToColorEnable",
            "extendedDynamicState3CoverageToColorLocation",
            "extendedDynamicState3CoverageModulationMode",
            "extendedDynamicState3CoverageModulationTableEnable",
            "extendedDynamicState3CoverageModulationTable",
            "extendedDynamicState3CoverageReductionMode",
            "extendedDynamicState3RepresentativeFragmentTestEnable",
            "extendedDynamicState3ShadingRateImageEnable",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "extendedDynamicState3TessellationDomainOrigin") return features.extendedDynamicState3TessellationDomainOrigin == VK_TRUE;
        if (name == "extendedDynamicState3DepthClampEnable") return features.extendedDynamicState3DepthClampEnable == VK_TRUE;
        if (name == "extendedDynamicState3PolygonMode") return features.extendedDynamicState3PolygonMode == VK_TRUE;
        if (name == "extendedDynamicState3RasterizationSamples") return features.extendedDynamicState3RasterizationSamples == VK_TRUE;
        if (name == "extendedDynamicState3SampleMask") return features.extendedDynamicState3SampleMask == VK_TRUE;
        if (name == "extendedDynamicState3AlphaToCoverageEnable") return features.extendedDynamicState3AlphaToCoverageEnable == VK_TRUE;
        if (name == "extendedDynamicState3AlphaToOneEnable") return features.extendedDynamicState3AlphaToOneEnable == VK_TRUE;
        if (name == "extendedDynamicState3LogicOpEnable") return features.extendedDynamicState3LogicOpEnable == VK_TRUE;
        if (name == "extendedDynamicState3ColorBlendEnable") return features.extendedDynamicState3ColorBlendEnable == VK_TRUE;
        if (name == "extendedDynamicState3ColorBlendEquation") return features.extendedDynamicState3ColorBlendEquation == VK_TRUE;
        if (name == "extendedDynamicState3ColorWriteMask") return features.extendedDynamicState3ColorWriteMask == VK_TRUE;
        if (name == "extendedDynamicState3RasterizationStream") return features.extendedDynamicState3RasterizationStream == VK_TRUE;
        if (name == "extendedDynamicState3ConservativeRasterizationMode") return features.extendedDynamicState3ConservativeRasterizationMode == VK_TRUE;
        if (name == "extendedDynamicState3ExtraPrimitiveOverestimationSize") return features.extendedDynamicState3ExtraPrimitiveOverestimationSize == VK_TRUE;
        if (name == "extendedDynamicState3DepthClipEnable") return features.extendedDynamicState3DepthClipEnable == VK_TRUE;
        if (name == "extendedDynamicState3SampleLocationsEnable") return features.extendedDynamicState3SampleLocationsEnable == VK_TRUE;
        if (name == "extendedDynamicState3ColorBlendAdvanced") return features.extendedDynamicState3ColorBlendAdvanced == VK_TRUE;
        if (name == "extendedDynamicState3ProvokingVertexMode") return features.extendedDynamicState3ProvokingVertexMode == VK_TRUE;
        if (name == "extendedDynamicState3LineRasterizationMode") return features.extendedDynamicState3LineRasterizationMode == VK_TRUE;
        if (name == "extendedDynamicState3LineStippleEnable") return features.extendedDynamicState3LineStippleEnable == VK_TRUE;
        if (name == "extendedDynamicState3DepthClipNegativeOneToOne") return features.extendedDynamicState3DepthClipNegativeOneToOne == VK_TRUE;
        if (name == "extendedDynamicState3ViewportWScalingEnable") return features.extendedDynamicState3ViewportWScalingEnable == VK_TRUE;
        if (name == "extendedDynamicState3ViewportSwizzle") return features.extendedDynamicState3ViewportSwizzle == VK_TRUE;
        if (name == "extendedDynamicState3CoverageToColorEnable") return features.extendedDynamicState3CoverageToColorEnable == VK_TRUE;
        if (name == "extendedDynamicState3CoverageToColorLocation") return features.extendedDynamicState3CoverageToColorLocation == VK_TRUE;
        if (name == "extendedDynamicState3CoverageModulationMode") return features.extendedDynamicState3CoverageModulationMode == VK_TRUE;
        if (name == "extendedDynamicState3CoverageModulationTableEnable") return features.extendedDynamicState3CoverageModulationTableEnable == VK_TRUE;
        if (name == "extendedDynamicState3CoverageModulationTable") return features.extendedDynamicState3CoverageModulationTable == VK_TRUE;
        if (name == "extendedDynamicState3CoverageReductionMode") return features.extendedDynamicState3CoverageReductionMode == VK_TRUE;
        if (name == "extendedDynamicState3RepresentativeFragmentTestEnable") return features.extendedDynamicState3RepresentativeFragmentTestEnable == VK_TRUE;
        if (name == "extendedDynamicState3ShadingRateImageEnable") return features.extendedDynamicState3ShadingRateImageEnable == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "extendedDynamicState3TessellationDomainOrigin") { features.extendedDynamicState3TessellationDomainOrigin = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3DepthClampEnable") { features.extendedDynamicState3DepthClampEnable = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3PolygonMode") { features.extendedDynamicState3PolygonMode = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3RasterizationSamples") { features.extendedDynamicState3RasterizationSamples = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3SampleMask") { features.extendedDynamicState3SampleMask = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3AlphaToCoverageEnable") { features.extendedDynamicState3AlphaToCoverageEnable = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3AlphaToOneEnable") { features.extendedDynamicState3AlphaToOneEnable = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3LogicOpEnable") { features.extendedDynamicState3LogicOpEnable = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3ColorBlendEnable") { features.extendedDynamicState3ColorBlendEnable = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3ColorBlendEquation") { features.extendedDynamicState3ColorBlendEquation = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3ColorWriteMask") { features.extendedDynamicState3ColorWriteMask = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3RasterizationStream") { features.extendedDynamicState3RasterizationStream = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3ConservativeRasterizationMode") { features.extendedDynamicState3ConservativeRasterizationMode = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3ExtraPrimitiveOverestimationSize") { features.extendedDynamicState3ExtraPrimitiveOverestimationSize = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3DepthClipEnable") { features.extendedDynamicState3DepthClipEnable = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3SampleLocationsEnable") { features.extendedDynamicState3SampleLocationsEnable = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3ColorBlendAdvanced") { features.extendedDynamicState3ColorBlendAdvanced = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3ProvokingVertexMode") { features.extendedDynamicState3ProvokingVertexMode = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3LineRasterizationMode") { features.extendedDynamicState3LineRasterizationMode = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3LineStippleEnable") { features.extendedDynamicState3LineStippleEnable = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3DepthClipNegativeOneToOne") { features.extendedDynamicState3DepthClipNegativeOneToOne = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3ViewportWScalingEnable") { features.extendedDynamicState3ViewportWScalingEnable = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3ViewportSwizzle") { features.extendedDynamicState3ViewportSwizzle = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3CoverageToColorEnable") { features.extendedDynamicState3CoverageToColorEnable = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3CoverageToColorLocation") { features.extendedDynamicState3CoverageToColorLocation = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3CoverageModulationMode") { features.extendedDynamicState3CoverageModulationMode = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3CoverageModulationTableEnable") { features.extendedDynamicState3CoverageModulationTableEnable = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3CoverageModulationTable") { features.extendedDynamicState3CoverageModulationTable = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3CoverageReductionMode") { features.extendedDynamicState3CoverageReductionMode = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3RepresentativeFragmentTestEnable") { features.extendedDynamicState3RepresentativeFragmentTestEnable = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "extendedDynamicState3ShadingRateImageEnable") { features.extendedDynamicState3ShadingRateImageEnable = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceExtendedDynamicState3FeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceExtendedDynamicState3FeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceExtendedDynamicState3FeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceExtendedDynamicState3FeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceExtendedDynamicState3FeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceExtendedDynamicStateEXT
// Wraps: vk::PhysicalDeviceExtendedDynamicStateFeaturesEXT
// Extension: VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceExtendedDynamicStateEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "extendedDynamicState",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "extendedDynamicState") return features.extendedDynamicState == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "extendedDynamicState") { features.extendedDynamicState = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceExtendedDynamicStateFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceExtendedDynamicStateFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceExtendedDynamicStateFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceExtendedDynamicStateFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceExtendedDynamicStateFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceExtendedSparseAddressSpaceNV
// Wraps: vk::PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV
// Extension: VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceExtendedSparseAddressSpaceNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "extendedSparseAddressSpace",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "extendedSparseAddressSpace") return features.extendedSparseAddressSpace == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "extendedSparseAddressSpace") { features.extendedSparseAddressSpace = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceExtendedSparseAddressSpaceFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceExternalMemoryRDMANV
// Wraps: vk::PhysicalDeviceExternalMemoryRDMAFeaturesNV
// Extension: VK_NV_EXTERNAL_MEMORY_RDMA_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceExternalMemoryRDMANV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_EXTERNAL_MEMORY_RDMA_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "externalMemoryRDMA",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "externalMemoryRDMA") return features.externalMemoryRDMA == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "externalMemoryRDMA") { features.externalMemoryRDMA = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceExternalMemoryRDMAFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceExternalMemoryRdmaFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceExternalMemoryRDMAFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceExternalMemoryRDMAFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceExternalMemoryRDMAFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceFaultEXT
// Wraps: vk::PhysicalDeviceFaultFeaturesEXT
// Extension: VK_EXT_DEVICE_FAULT_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceFaultEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_DEVICE_FAULT_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "deviceFault",
            "deviceFaultVendorBinary",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "deviceFault") return features.deviceFault == VK_TRUE;
        if (name == "deviceFaultVendorBinary") return features.deviceFaultVendorBinary == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "deviceFault") { features.deviceFault = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "deviceFaultVendorBinary") { features.deviceFaultVendorBinary = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceFaultFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceFaultFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceFaultFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceFaultFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceFaultFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceFeatures2
// Wraps: vk::PhysicalDeviceFeatures2
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceFeatures2 : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "robustBufferAccess",
            "fullDrawIndexUint32",
            "imageCubeArray",
            "independentBlend",
            "geometryShader",
            "tessellationShader",
            "sampleRateShading",
            "dualSrcBlend",
            "logicOp",
            "multiDrawIndirect",
            "drawIndirectFirstInstance",
            "depthClamp",
            "depthBiasClamp",
            "fillModeNonSolid",
            "depthBounds",
            "wideLines",
            "largePoints",
            "alphaToOne",
            "multiViewport",
            "samplerAnisotropy",
            "textureCompressionETC2",
            "textureCompressionASTC_LDR",
            "textureCompressionBC",
            "occlusionQueryPrecise",
            "pipelineStatisticsQuery",
            "vertexPipelineStoresAndAtomics",
            "fragmentStoresAndAtomics",
            "shaderTessellationAndGeometryPointSize",
            "shaderImageGatherExtended",
            "shaderStorageImageExtendedFormats",
            "shaderStorageImageMultisample",
            "shaderStorageImageReadWithoutFormat",
            "shaderStorageImageWriteWithoutFormat",
            "shaderUniformBufferArrayDynamicIndexing",
            "shaderSampledImageArrayDynamicIndexing",
            "shaderStorageBufferArrayDynamicIndexing",
            "shaderStorageImageArrayDynamicIndexing",
            "shaderClipDistance",
            "shaderCullDistance",
            "shaderFloat64",
            "shaderInt64",
            "shaderInt16",
            "shaderResourceResidency",
            "shaderResourceMinLod",
            "sparseBinding",
            "sparseResidencyBuffer",
            "sparseResidencyImage2D",
            "sparseResidencyImage3D",
            "sparseResidency2Samples",
            "sparseResidency4Samples",
            "sparseResidency8Samples",
            "sparseResidency16Samples",
            "sparseResidencyAliased",
            "variableMultisampleRate",
            "inheritedQueries",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "robustBufferAccess") return features.features.robustBufferAccess == VK_TRUE;
        if (name == "fullDrawIndexUint32") return features.features.fullDrawIndexUint32 == VK_TRUE;
        if (name == "imageCubeArray") return features.features.imageCubeArray == VK_TRUE;
        if (name == "independentBlend") return features.features.independentBlend == VK_TRUE;
        if (name == "geometryShader") return features.features.geometryShader == VK_TRUE;
        if (name == "tessellationShader") return features.features.tessellationShader == VK_TRUE;
        if (name == "sampleRateShading") return features.features.sampleRateShading == VK_TRUE;
        if (name == "dualSrcBlend") return features.features.dualSrcBlend == VK_TRUE;
        if (name == "logicOp") return features.features.logicOp == VK_TRUE;
        if (name == "multiDrawIndirect") return features.features.multiDrawIndirect == VK_TRUE;
        if (name == "drawIndirectFirstInstance") return features.features.drawIndirectFirstInstance == VK_TRUE;
        if (name == "depthClamp") return features.features.depthClamp == VK_TRUE;
        if (name == "depthBiasClamp") return features.features.depthBiasClamp == VK_TRUE;
        if (name == "fillModeNonSolid") return features.features.fillModeNonSolid == VK_TRUE;
        if (name == "depthBounds") return features.features.depthBounds == VK_TRUE;
        if (name == "wideLines") return features.features.wideLines == VK_TRUE;
        if (name == "largePoints") return features.features.largePoints == VK_TRUE;
        if (name == "alphaToOne") return features.features.alphaToOne == VK_TRUE;
        if (name == "multiViewport") return features.features.multiViewport == VK_TRUE;
        if (name == "samplerAnisotropy") return features.features.samplerAnisotropy == VK_TRUE;
        if (name == "textureCompressionETC2") return features.features.textureCompressionETC2 == VK_TRUE;
        if (name == "textureCompressionASTC_LDR") return features.features.textureCompressionASTC_LDR == VK_TRUE;
        if (name == "textureCompressionBC") return features.features.textureCompressionBC == VK_TRUE;
        if (name == "occlusionQueryPrecise") return features.features.occlusionQueryPrecise == VK_TRUE;
        if (name == "pipelineStatisticsQuery") return features.features.pipelineStatisticsQuery == VK_TRUE;
        if (name == "vertexPipelineStoresAndAtomics") return features.features.vertexPipelineStoresAndAtomics == VK_TRUE;
        if (name == "fragmentStoresAndAtomics") return features.features.fragmentStoresAndAtomics == VK_TRUE;
        if (name == "shaderTessellationAndGeometryPointSize") return features.features.shaderTessellationAndGeometryPointSize == VK_TRUE;
        if (name == "shaderImageGatherExtended") return features.features.shaderImageGatherExtended == VK_TRUE;
        if (name == "shaderStorageImageExtendedFormats") return features.features.shaderStorageImageExtendedFormats == VK_TRUE;
        if (name == "shaderStorageImageMultisample") return features.features.shaderStorageImageMultisample == VK_TRUE;
        if (name == "shaderStorageImageReadWithoutFormat") return features.features.shaderStorageImageReadWithoutFormat == VK_TRUE;
        if (name == "shaderStorageImageWriteWithoutFormat") return features.features.shaderStorageImageWriteWithoutFormat == VK_TRUE;
        if (name == "shaderUniformBufferArrayDynamicIndexing") return features.features.shaderUniformBufferArrayDynamicIndexing == VK_TRUE;
        if (name == "shaderSampledImageArrayDynamicIndexing") return features.features.shaderSampledImageArrayDynamicIndexing == VK_TRUE;
        if (name == "shaderStorageBufferArrayDynamicIndexing") return features.features.shaderStorageBufferArrayDynamicIndexing == VK_TRUE;
        if (name == "shaderStorageImageArrayDynamicIndexing") return features.features.shaderStorageImageArrayDynamicIndexing == VK_TRUE;
        if (name == "shaderClipDistance") return features.features.shaderClipDistance == VK_TRUE;
        if (name == "shaderCullDistance") return features.features.shaderCullDistance == VK_TRUE;
        if (name == "shaderFloat64") return features.features.shaderFloat64 == VK_TRUE;
        if (name == "shaderInt64") return features.features.shaderInt64 == VK_TRUE;
        if (name == "shaderInt16") return features.features.shaderInt16 == VK_TRUE;
        if (name == "shaderResourceResidency") return features.features.shaderResourceResidency == VK_TRUE;
        if (name == "shaderResourceMinLod") return features.features.shaderResourceMinLod == VK_TRUE;
        if (name == "sparseBinding") return features.features.sparseBinding == VK_TRUE;
        if (name == "sparseResidencyBuffer") return features.features.sparseResidencyBuffer == VK_TRUE;
        if (name == "sparseResidencyImage2D") return features.features.sparseResidencyImage2D == VK_TRUE;
        if (name == "sparseResidencyImage3D") return features.features.sparseResidencyImage3D == VK_TRUE;
        if (name == "sparseResidency2Samples") return features.features.sparseResidency2Samples == VK_TRUE;
        if (name == "sparseResidency4Samples") return features.features.sparseResidency4Samples == VK_TRUE;
        if (name == "sparseResidency8Samples") return features.features.sparseResidency8Samples == VK_TRUE;
        if (name == "sparseResidency16Samples") return features.features.sparseResidency16Samples == VK_TRUE;
        if (name == "sparseResidencyAliased") return features.features.sparseResidencyAliased == VK_TRUE;
        if (name == "variableMultisampleRate") return features.features.variableMultisampleRate == VK_TRUE;
        if (name == "inheritedQueries") return features.features.inheritedQueries == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "robustBufferAccess") { features.features.robustBufferAccess = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "fullDrawIndexUint32") { features.features.fullDrawIndexUint32 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "imageCubeArray") { features.features.imageCubeArray = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "independentBlend") { features.features.independentBlend = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "geometryShader") { features.features.geometryShader = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "tessellationShader") { features.features.tessellationShader = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "sampleRateShading") { features.features.sampleRateShading = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "dualSrcBlend") { features.features.dualSrcBlend = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "logicOp") { features.features.logicOp = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "multiDrawIndirect") { features.features.multiDrawIndirect = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "drawIndirectFirstInstance") { features.features.drawIndirectFirstInstance = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "depthClamp") { features.features.depthClamp = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "depthBiasClamp") { features.features.depthBiasClamp = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "fillModeNonSolid") { features.features.fillModeNonSolid = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "depthBounds") { features.features.depthBounds = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "wideLines") { features.features.wideLines = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "largePoints") { features.features.largePoints = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "alphaToOne") { features.features.alphaToOne = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "multiViewport") { features.features.multiViewport = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "samplerAnisotropy") { features.features.samplerAnisotropy = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "textureCompressionETC2") { features.features.textureCompressionETC2 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "textureCompressionASTC_LDR") { features.features.textureCompressionASTC_LDR = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "textureCompressionBC") { features.features.textureCompressionBC = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "occlusionQueryPrecise") { features.features.occlusionQueryPrecise = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "pipelineStatisticsQuery") { features.features.pipelineStatisticsQuery = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "vertexPipelineStoresAndAtomics") { features.features.vertexPipelineStoresAndAtomics = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "fragmentStoresAndAtomics") { features.features.fragmentStoresAndAtomics = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderTessellationAndGeometryPointSize") { features.features.shaderTessellationAndGeometryPointSize = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderImageGatherExtended") { features.features.shaderImageGatherExtended = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderStorageImageExtendedFormats") { features.features.shaderStorageImageExtendedFormats = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderStorageImageMultisample") { features.features.shaderStorageImageMultisample = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderStorageImageReadWithoutFormat") { features.features.shaderStorageImageReadWithoutFormat = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderStorageImageWriteWithoutFormat") { features.features.shaderStorageImageWriteWithoutFormat = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderUniformBufferArrayDynamicIndexing") { features.features.shaderUniformBufferArrayDynamicIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderSampledImageArrayDynamicIndexing") { features.features.shaderSampledImageArrayDynamicIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderStorageBufferArrayDynamicIndexing") { features.features.shaderStorageBufferArrayDynamicIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderStorageImageArrayDynamicIndexing") { features.features.shaderStorageImageArrayDynamicIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderClipDistance") { features.features.shaderClipDistance = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderCullDistance") { features.features.shaderCullDistance = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderFloat64") { features.features.shaderFloat64 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderInt64") { features.features.shaderInt64 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderInt16") { features.features.shaderInt16 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderResourceResidency") { features.features.shaderResourceResidency = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderResourceMinLod") { features.features.shaderResourceMinLod = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "sparseBinding") { features.features.sparseBinding = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "sparseResidencyBuffer") { features.features.sparseResidencyBuffer = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "sparseResidencyImage2D") { features.features.sparseResidencyImage2D = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "sparseResidencyImage3D") { features.features.sparseResidencyImage3D = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "sparseResidency2Samples") { features.features.sparseResidency2Samples = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "sparseResidency4Samples") { features.features.sparseResidency4Samples = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "sparseResidency8Samples") { features.features.sparseResidency8Samples = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "sparseResidency16Samples") { features.features.sparseResidency16Samples = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "sparseResidencyAliased") { features.features.sparseResidencyAliased = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "variableMultisampleRate") { features.features.variableMultisampleRate = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "inheritedQueries") { features.features.inheritedQueries = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceFeatures2";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceFeatures2;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceFeatures2& get() { return features; }
    const vk::PhysicalDeviceFeatures2& get() const { return features; }

  private:
    vk::PhysicalDeviceFeatures2 features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceFormatPackARM
// Wraps: vk::PhysicalDeviceFormatPackFeaturesARM
// Extension: VK_ARM_FORMAT_PACK_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceFormatPackARM : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_ARM_FORMAT_PACK_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "formatPack",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "formatPack") return features.formatPack == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "formatPack") { features.formatPack = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceFormatPackFeaturesARM";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceFormatPackFeaturesARM;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceFormatPackFeaturesARM& get() { return features; }
    const vk::PhysicalDeviceFormatPackFeaturesARM& get() const { return features; }

  private:
    vk::PhysicalDeviceFormatPackFeaturesARM features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceFragmentDensityMap2EXT
// Wraps: vk::PhysicalDeviceFragmentDensityMap2FeaturesEXT
// Extension: VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceFragmentDensityMap2EXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "fragmentDensityMapDeferred",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "fragmentDensityMapDeferred") return features.fragmentDensityMapDeferred == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "fragmentDensityMapDeferred") { features.fragmentDensityMapDeferred = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceFragmentDensityMap2FeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceFragmentDensityMap2FeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceFragmentDensityMap2FeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceFragmentDensityMap2FeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceFragmentDensityMap2FeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceFragmentDensityMapEXT
// Wraps: vk::PhysicalDeviceFragmentDensityMapFeaturesEXT
// Extension: VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceFragmentDensityMapEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "fragmentDensityMap",
            "fragmentDensityMapDynamic",
            "fragmentDensityMapNonSubsampledImages",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "fragmentDensityMap") return features.fragmentDensityMap == VK_TRUE;
        if (name == "fragmentDensityMapDynamic") return features.fragmentDensityMapDynamic == VK_TRUE;
        if (name == "fragmentDensityMapNonSubsampledImages") return features.fragmentDensityMapNonSubsampledImages == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "fragmentDensityMap") { features.fragmentDensityMap = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "fragmentDensityMapDynamic") { features.fragmentDensityMapDynamic = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "fragmentDensityMapNonSubsampledImages") { features.fragmentDensityMapNonSubsampledImages = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceFragmentDensityMapFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceFragmentDensityMapFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceFragmentDensityMapFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceFragmentDensityMapFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceFragmentDensityMapFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceFragmentDensityMapLayeredVALVE
// Wraps: vk::PhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE
// Extension: VK_VALVE_FRAGMENT_DENSITY_MAP_LAYERED_EXTENSION_NAME
// Core in: VK_API_VERSION_1_4
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceFragmentDensityMapLayeredVALVE : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_4) {
            return {};
        }
        return {VK_VALVE_FRAGMENT_DENSITY_MAP_LAYERED_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "fragmentDensityMapLayered",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "fragmentDensityMapLayered") return features.fragmentDensityMapLayered == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "fragmentDensityMapLayered") { features.fragmentDensityMapLayered = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE& get() { return features; }
    const vk::PhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE& get() const { return features; }

  private:
    vk::PhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceFragmentDensityMapOffsetEXT
// Wraps: vk::PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT
// Extension: VK_EXT_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceFragmentDensityMapOffsetEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "fragmentDensityMapOffset",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "fragmentDensityMapOffset") return features.fragmentDensityMapOffset == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "fragmentDensityMapOffset") { features.fragmentDensityMapOffset = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceFragmentDensityMapOffsetFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceFragmentShaderBarycentricKHR
// Wraps: vk::PhysicalDeviceFragmentShaderBarycentricFeaturesKHR
// Extension: VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceFragmentShaderBarycentricKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "fragmentShaderBarycentric",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "fragmentShaderBarycentric") return features.fragmentShaderBarycentric == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "fragmentShaderBarycentric") { features.fragmentShaderBarycentric = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceFragmentShaderBarycentricFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceFragmentShaderBarycentricFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceFragmentShaderBarycentricFeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceFragmentShaderBarycentricFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceFragmentShaderBarycentricFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceFragmentShaderInterlockEXT
// Wraps: vk::PhysicalDeviceFragmentShaderInterlockFeaturesEXT
// Extension: VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceFragmentShaderInterlockEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "fragmentShaderSampleInterlock",
            "fragmentShaderPixelInterlock",
            "fragmentShaderShadingRateInterlock",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "fragmentShaderSampleInterlock") return features.fragmentShaderSampleInterlock == VK_TRUE;
        if (name == "fragmentShaderPixelInterlock") return features.fragmentShaderPixelInterlock == VK_TRUE;
        if (name == "fragmentShaderShadingRateInterlock") return features.fragmentShaderShadingRateInterlock == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "fragmentShaderSampleInterlock") { features.fragmentShaderSampleInterlock = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "fragmentShaderPixelInterlock") { features.fragmentShaderPixelInterlock = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "fragmentShaderShadingRateInterlock") { features.fragmentShaderShadingRateInterlock = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceFragmentShaderInterlockFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceFragmentShaderInterlockFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceFragmentShaderInterlockFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceFragmentShaderInterlockFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceFragmentShaderInterlockFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceFragmentShadingRateEnumsNV
// Wraps: vk::PhysicalDeviceFragmentShadingRateEnumsFeaturesNV
// Extension: VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceFragmentShadingRateEnumsNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "fragmentShadingRateEnums",
            "supersampleFragmentShadingRates",
            "noInvocationFragmentShadingRates",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "fragmentShadingRateEnums") return features.fragmentShadingRateEnums == VK_TRUE;
        if (name == "supersampleFragmentShadingRates") return features.supersampleFragmentShadingRates == VK_TRUE;
        if (name == "noInvocationFragmentShadingRates") return features.noInvocationFragmentShadingRates == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "fragmentShadingRateEnums") { features.fragmentShadingRateEnums = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "supersampleFragmentShadingRates") { features.supersampleFragmentShadingRates = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "noInvocationFragmentShadingRates") { features.noInvocationFragmentShadingRates = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceFragmentShadingRateEnumsFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceFragmentShadingRateEnumsFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceFragmentShadingRateEnumsFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceFragmentShadingRateEnumsFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceFragmentShadingRateEnumsFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceFragmentShadingRateKHR
// Wraps: vk::PhysicalDeviceFragmentShadingRateFeaturesKHR
// Extension: VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceFragmentShadingRateKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "pipelineFragmentShadingRate",
            "primitiveFragmentShadingRate",
            "attachmentFragmentShadingRate",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "pipelineFragmentShadingRate") return features.pipelineFragmentShadingRate == VK_TRUE;
        if (name == "primitiveFragmentShadingRate") return features.primitiveFragmentShadingRate == VK_TRUE;
        if (name == "attachmentFragmentShadingRate") return features.attachmentFragmentShadingRate == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "pipelineFragmentShadingRate") { features.pipelineFragmentShadingRate = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "primitiveFragmentShadingRate") { features.primitiveFragmentShadingRate = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "attachmentFragmentShadingRate") { features.attachmentFragmentShadingRate = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceFragmentShadingRateFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceFragmentShadingRateFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceFragmentShadingRateFeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceFragmentShadingRateFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceFragmentShadingRateFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceFrameBoundaryEXT
// Wraps: vk::PhysicalDeviceFrameBoundaryFeaturesEXT
// Extension: VK_EXT_FRAME_BOUNDARY_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceFrameBoundaryEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_FRAME_BOUNDARY_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "frameBoundary",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "frameBoundary") return features.frameBoundary == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "frameBoundary") { features.frameBoundary = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceFrameBoundaryFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceFrameBoundaryFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceFrameBoundaryFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceFrameBoundaryFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceFrameBoundaryFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceGlobalPriorityQuery
// Wraps: vk::PhysicalDeviceGlobalPriorityQueryFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceGlobalPriorityQuery : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "globalPriorityQuery",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "globalPriorityQuery") return features.globalPriorityQuery == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "globalPriorityQuery") { features.globalPriorityQuery = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceGlobalPriorityQueryFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceGlobalPriorityQueryFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceGlobalPriorityQueryFeatures& get() { return features; }
    const vk::PhysicalDeviceGlobalPriorityQueryFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceGlobalPriorityQueryFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceGraphicsPipelineLibraryEXT
// Wraps: vk::PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT
// Extension: VK_EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceGraphicsPipelineLibraryEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "graphicsPipelineLibrary",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "graphicsPipelineLibrary") return features.graphicsPipelineLibrary == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "graphicsPipelineLibrary") { features.graphicsPipelineLibrary = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceGraphicsPipelineLibraryFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceHdrVividHUAWEI
// Wraps: vk::PhysicalDeviceHdrVividFeaturesHUAWEI
// Extension: VK_HUAWEI_HDR_VIVID_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceHdrVividHUAWEI : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_HUAWEI_HDR_VIVID_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "hdrVivid",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "hdrVivid") return features.hdrVivid == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "hdrVivid") { features.hdrVivid = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceHdrVividFeaturesHUAWEI";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceHdrVividFeaturesHUAWEI;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceHdrVividFeaturesHUAWEI& get() { return features; }
    const vk::PhysicalDeviceHdrVividFeaturesHUAWEI& get() const { return features; }

  private:
    vk::PhysicalDeviceHdrVividFeaturesHUAWEI features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceHostImageCopy
// Wraps: vk::PhysicalDeviceHostImageCopyFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceHostImageCopy : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "hostImageCopy",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "hostImageCopy") return features.hostImageCopy == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "hostImageCopy") { features.hostImageCopy = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceHostImageCopyFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceHostImageCopyFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceHostImageCopyFeatures& get() { return features; }
    const vk::PhysicalDeviceHostImageCopyFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceHostImageCopyFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceHostQueryReset
// Wraps: vk::PhysicalDeviceHostQueryResetFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceHostQueryReset : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "hostQueryReset",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "hostQueryReset") return features.hostQueryReset == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "hostQueryReset") { features.hostQueryReset = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceHostQueryResetFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceHostQueryResetFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceHostQueryResetFeatures& get() { return features; }
    const vk::PhysicalDeviceHostQueryResetFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceHostQueryResetFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceImage2DViewOf3DEXT
// Wraps: vk::PhysicalDeviceImage2DViewOf3DFeaturesEXT
// Extension: VK_EXT_IMAGE_2D_VIEW_OF_3D_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceImage2DViewOf3DEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_IMAGE_2D_VIEW_OF_3D_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "image2DViewOf3D",
            "sampler2DViewOf3D",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "image2DViewOf3D") return features.image2DViewOf3D == VK_TRUE;
        if (name == "sampler2DViewOf3D") return features.sampler2DViewOf3D == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "image2DViewOf3D") { features.image2DViewOf3D = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "sampler2DViewOf3D") { features.sampler2DViewOf3D = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceImage2DViewOf3DFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceImage2DViewOf3DFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceImage2DViewOf3DFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceImage2DViewOf3DFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceImage2DViewOf3DFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceImageAlignmentControlMESA
// Wraps: vk::PhysicalDeviceImageAlignmentControlFeaturesMESA
// Extension: VK_MESA_IMAGE_ALIGNMENT_CONTROL_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceImageAlignmentControlMESA : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_MESA_IMAGE_ALIGNMENT_CONTROL_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "imageAlignmentControl",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "imageAlignmentControl") return features.imageAlignmentControl == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "imageAlignmentControl") { features.imageAlignmentControl = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceImageAlignmentControlFeaturesMESA";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceImageAlignmentControlFeaturesMESA;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceImageAlignmentControlFeaturesMESA& get() { return features; }
    const vk::PhysicalDeviceImageAlignmentControlFeaturesMESA& get() const { return features; }

  private:
    vk::PhysicalDeviceImageAlignmentControlFeaturesMESA features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceImageCompressionControlEXT
// Wraps: vk::PhysicalDeviceImageCompressionControlFeaturesEXT
// Extension: VK_EXT_IMAGE_COMPRESSION_CONTROL_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceImageCompressionControlEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_IMAGE_COMPRESSION_CONTROL_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "imageCompressionControl",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "imageCompressionControl") return features.imageCompressionControl == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "imageCompressionControl") { features.imageCompressionControl = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceImageCompressionControlFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceImageCompressionControlFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceImageCompressionControlFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceImageCompressionControlFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceImageCompressionControlFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceImageCompressionControlSwapchainEXT
// Wraps: vk::PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT
// Extension: VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceImageCompressionControlSwapchainEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "imageCompressionControlSwapchain",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "imageCompressionControlSwapchain") return features.imageCompressionControlSwapchain == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "imageCompressionControlSwapchain") { features.imageCompressionControlSwapchain = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceImageCompressionControlSwapchainFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceImageProcessing2QCOM
// Wraps: vk::PhysicalDeviceImageProcessing2FeaturesQCOM
// Extension: VK_QCOM_IMAGE_PROCESSING_2_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceImageProcessing2QCOM : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_QCOM_IMAGE_PROCESSING_2_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "textureBlockMatch2",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "textureBlockMatch2") return features.textureBlockMatch2 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "textureBlockMatch2") { features.textureBlockMatch2 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceImageProcessing2FeaturesQCOM";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceImageProcessing2FeaturesQCOM;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceImageProcessing2FeaturesQCOM& get() { return features; }
    const vk::PhysicalDeviceImageProcessing2FeaturesQCOM& get() const { return features; }

  private:
    vk::PhysicalDeviceImageProcessing2FeaturesQCOM features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceImageProcessingQCOM
// Wraps: vk::PhysicalDeviceImageProcessingFeaturesQCOM
// Extension: VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME
// Core in: VK_API_VERSION_1_3
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceImageProcessingQCOM : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_3) {
            return {};
        }
        return {VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "textureSampleWeighted",
            "textureBoxFilter",
            "textureBlockMatch",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "textureSampleWeighted") return features.textureSampleWeighted == VK_TRUE;
        if (name == "textureBoxFilter") return features.textureBoxFilter == VK_TRUE;
        if (name == "textureBlockMatch") return features.textureBlockMatch == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "textureSampleWeighted") { features.textureSampleWeighted = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "textureBoxFilter") { features.textureBoxFilter = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "textureBlockMatch") { features.textureBlockMatch = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceImageProcessingFeaturesQCOM";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceImageProcessingFeaturesQCOM;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceImageProcessingFeaturesQCOM& get() { return features; }
    const vk::PhysicalDeviceImageProcessingFeaturesQCOM& get() const { return features; }

  private:
    vk::PhysicalDeviceImageProcessingFeaturesQCOM features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceImageRobustness
// Wraps: vk::PhysicalDeviceImageRobustnessFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceImageRobustness : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "robustImageAccess",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "robustImageAccess") return features.robustImageAccess == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "robustImageAccess") { features.robustImageAccess = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceImageRobustnessFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceImageRobustnessFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceImageRobustnessFeatures& get() { return features; }
    const vk::PhysicalDeviceImageRobustnessFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceImageRobustnessFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceImageSlicedViewOf3DEXT
// Wraps: vk::PhysicalDeviceImageSlicedViewOf3DFeaturesEXT
// Extension: VK_EXT_IMAGE_SLICED_VIEW_OF_3D_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceImageSlicedViewOf3DEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_IMAGE_SLICED_VIEW_OF_3D_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "imageSlicedViewOf3D",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "imageSlicedViewOf3D") return features.imageSlicedViewOf3D == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "imageSlicedViewOf3D") { features.imageSlicedViewOf3D = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceImageSlicedViewOf3DFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceImageSlicedViewOf3DFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceImageSlicedViewOf3DFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceImageSlicedViewOf3DFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceImageSlicedViewOf3DFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceImageViewMinLodEXT
// Wraps: vk::PhysicalDeviceImageViewMinLodFeaturesEXT
// Extension: VK_EXT_IMAGE_VIEW_MIN_LOD_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceImageViewMinLodEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_IMAGE_VIEW_MIN_LOD_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "minLod",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "minLod") return features.minLod == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "minLod") { features.minLod = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceImageViewMinLodFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceImageViewMinLodFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceImageViewMinLodFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceImageViewMinLodFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceImageViewMinLodFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceImagelessFramebuffer
// Wraps: vk::PhysicalDeviceImagelessFramebufferFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceImagelessFramebuffer : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "imagelessFramebuffer",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "imagelessFramebuffer") return features.imagelessFramebuffer == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "imagelessFramebuffer") { features.imagelessFramebuffer = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceImagelessFramebufferFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceImagelessFramebufferFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceImagelessFramebufferFeatures& get() { return features; }
    const vk::PhysicalDeviceImagelessFramebufferFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceImagelessFramebufferFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceIndexTypeUint8
// Wraps: vk::PhysicalDeviceIndexTypeUint8Features
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceIndexTypeUint8 : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "indexTypeUint8",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "indexTypeUint8") return features.indexTypeUint8 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "indexTypeUint8") { features.indexTypeUint8 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceIndexTypeUint8Features";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceIndexTypeUint8Features;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceIndexTypeUint8Features& get() { return features; }
    const vk::PhysicalDeviceIndexTypeUint8Features& get() const { return features; }

  private:
    vk::PhysicalDeviceIndexTypeUint8Features features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceInheritedViewportScissorNV
// Wraps: vk::PhysicalDeviceInheritedViewportScissorFeaturesNV
// Extension: VK_NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceInheritedViewportScissorNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "inheritedViewportScissor2D",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "inheritedViewportScissor2D") return features.inheritedViewportScissor2D == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "inheritedViewportScissor2D") { features.inheritedViewportScissor2D = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceInheritedViewportScissorFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceInheritedViewportScissorFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceInheritedViewportScissorFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceInheritedViewportScissorFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceInheritedViewportScissorFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceInlineUniformBlock
// Wraps: vk::PhysicalDeviceInlineUniformBlockFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceInlineUniformBlock : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "inlineUniformBlock",
            "descriptorBindingInlineUniformBlockUpdateAfterBind",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "inlineUniformBlock") return features.inlineUniformBlock == VK_TRUE;
        if (name == "descriptorBindingInlineUniformBlockUpdateAfterBind") return features.descriptorBindingInlineUniformBlockUpdateAfterBind == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "inlineUniformBlock") { features.inlineUniformBlock = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBindingInlineUniformBlockUpdateAfterBind") { features.descriptorBindingInlineUniformBlockUpdateAfterBind = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceInlineUniformBlockFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceInlineUniformBlockFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceInlineUniformBlockFeatures& get() { return features; }
    const vk::PhysicalDeviceInlineUniformBlockFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceInlineUniformBlockFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceInvocationMaskHUAWEI
// Wraps: vk::PhysicalDeviceInvocationMaskFeaturesHUAWEI
// Extension: VK_HUAWEI_INVOCATION_MASK_EXTENSION_NAME
// Core in: VK_API_VERSION_1_3
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceInvocationMaskHUAWEI : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_3) {
            return {};
        }
        return {VK_HUAWEI_INVOCATION_MASK_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "invocationMask",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "invocationMask") return features.invocationMask == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "invocationMask") { features.invocationMask = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceInvocationMaskFeaturesHUAWEI";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceInvocationMaskFeaturesHUAWEI;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceInvocationMaskFeaturesHUAWEI& get() { return features; }
    const vk::PhysicalDeviceInvocationMaskFeaturesHUAWEI& get() const { return features; }

  private:
    vk::PhysicalDeviceInvocationMaskFeaturesHUAWEI features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceLegacyDitheringEXT
// Wraps: vk::PhysicalDeviceLegacyDitheringFeaturesEXT
// Extension: VK_EXT_LEGACY_DITHERING_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceLegacyDitheringEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_LEGACY_DITHERING_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "legacyDithering",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "legacyDithering") return features.legacyDithering == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "legacyDithering") { features.legacyDithering = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceLegacyDitheringFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceLegacyDitheringFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceLegacyDitheringFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceLegacyDitheringFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceLegacyDitheringFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceLegacyVertexAttributesEXT
// Wraps: vk::PhysicalDeviceLegacyVertexAttributesFeaturesEXT
// Extension: VK_EXT_LEGACY_VERTEX_ATTRIBUTES_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceLegacyVertexAttributesEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_EXT_LEGACY_VERTEX_ATTRIBUTES_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "legacyVertexAttributes",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "legacyVertexAttributes") return features.legacyVertexAttributes == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "legacyVertexAttributes") { features.legacyVertexAttributes = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceLegacyVertexAttributesFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceLegacyVertexAttributesFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceLegacyVertexAttributesFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceLegacyVertexAttributesFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceLegacyVertexAttributesFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceLineRasterization
// Wraps: vk::PhysicalDeviceLineRasterizationFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceLineRasterization : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "rectangularLines",
            "bresenhamLines",
            "smoothLines",
            "stippledRectangularLines",
            "stippledBresenhamLines",
            "stippledSmoothLines",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "rectangularLines") return features.rectangularLines == VK_TRUE;
        if (name == "bresenhamLines") return features.bresenhamLines == VK_TRUE;
        if (name == "smoothLines") return features.smoothLines == VK_TRUE;
        if (name == "stippledRectangularLines") return features.stippledRectangularLines == VK_TRUE;
        if (name == "stippledBresenhamLines") return features.stippledBresenhamLines == VK_TRUE;
        if (name == "stippledSmoothLines") return features.stippledSmoothLines == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "rectangularLines") { features.rectangularLines = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "bresenhamLines") { features.bresenhamLines = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "smoothLines") { features.smoothLines = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "stippledRectangularLines") { features.stippledRectangularLines = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "stippledBresenhamLines") { features.stippledBresenhamLines = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "stippledSmoothLines") { features.stippledSmoothLines = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceLineRasterizationFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceLineRasterizationFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceLineRasterizationFeatures& get() { return features; }
    const vk::PhysicalDeviceLineRasterizationFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceLineRasterizationFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceLinearColorAttachmentNV
// Wraps: vk::PhysicalDeviceLinearColorAttachmentFeaturesNV
// Extension: VK_NV_LINEAR_COLOR_ATTACHMENT_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceLinearColorAttachmentNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_LINEAR_COLOR_ATTACHMENT_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "linearColorAttachment",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "linearColorAttachment") return features.linearColorAttachment == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "linearColorAttachment") { features.linearColorAttachment = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceLinearColorAttachmentFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceLinearColorAttachmentFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceLinearColorAttachmentFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceLinearColorAttachmentFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceLinearColorAttachmentFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceMaintenance10KHR
// Wraps: vk::PhysicalDeviceMaintenance10FeaturesKHR
// Extension: VK_KHR_MAINTENANCE_10_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceMaintenance10KHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_MAINTENANCE_10_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "maintenance10",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "maintenance10") return features.maintenance10 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "maintenance10") { features.maintenance10 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceMaintenance10FeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceMaintenance10FeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceMaintenance10FeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceMaintenance10FeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceMaintenance10FeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceMaintenance4
// Wraps: vk::PhysicalDeviceMaintenance4Features
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceMaintenance4 : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "maintenance4",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "maintenance4") return features.maintenance4 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "maintenance4") { features.maintenance4 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceMaintenance4Features";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceMaintenance4Features;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceMaintenance4Features& get() { return features; }
    const vk::PhysicalDeviceMaintenance4Features& get() const { return features; }

  private:
    vk::PhysicalDeviceMaintenance4Features features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceMaintenance5
// Wraps: vk::PhysicalDeviceMaintenance5Features
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceMaintenance5 : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "maintenance5",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "maintenance5") return features.maintenance5 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "maintenance5") { features.maintenance5 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceMaintenance5Features";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceMaintenance5Features;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceMaintenance5Features& get() { return features; }
    const vk::PhysicalDeviceMaintenance5Features& get() const { return features; }

  private:
    vk::PhysicalDeviceMaintenance5Features features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceMaintenance6
// Wraps: vk::PhysicalDeviceMaintenance6Features
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceMaintenance6 : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "maintenance6",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "maintenance6") return features.maintenance6 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "maintenance6") { features.maintenance6 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceMaintenance6Features";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceMaintenance6Features;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceMaintenance6Features& get() { return features; }
    const vk::PhysicalDeviceMaintenance6Features& get() const { return features; }

  private:
    vk::PhysicalDeviceMaintenance6Features features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceMaintenance7KHR
// Wraps: vk::PhysicalDeviceMaintenance7FeaturesKHR
// Extension: VK_KHR_MAINTENANCE_7_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceMaintenance7KHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_MAINTENANCE_7_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "maintenance7",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "maintenance7") return features.maintenance7 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "maintenance7") { features.maintenance7 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceMaintenance7FeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceMaintenance7FeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceMaintenance7FeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceMaintenance7FeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceMaintenance7FeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceMaintenance8KHR
// Wraps: vk::PhysicalDeviceMaintenance8FeaturesKHR
// Extension: VK_KHR_MAINTENANCE_8_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceMaintenance8KHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_MAINTENANCE_8_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "maintenance8",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "maintenance8") return features.maintenance8 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "maintenance8") { features.maintenance8 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceMaintenance8FeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceMaintenance8FeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceMaintenance8FeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceMaintenance8FeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceMaintenance8FeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceMaintenance9KHR
// Wraps: vk::PhysicalDeviceMaintenance9FeaturesKHR
// Extension: VK_KHR_MAINTENANCE_9_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceMaintenance9KHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_MAINTENANCE_9_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "maintenance9",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "maintenance9") return features.maintenance9 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "maintenance9") { features.maintenance9 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceMaintenance9FeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceMaintenance9FeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceMaintenance9FeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceMaintenance9FeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceMaintenance9FeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceMapMemoryPlacedEXT
// Wraps: vk::PhysicalDeviceMapMemoryPlacedFeaturesEXT
// Extension: VK_EXT_MAP_MEMORY_PLACED_EXTENSION_NAME
// Core in: VK_API_VERSION_1_4
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceMapMemoryPlacedEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_4) {
            return {};
        }
        return {VK_EXT_MAP_MEMORY_PLACED_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "memoryMapPlaced",
            "memoryMapRangePlaced",
            "memoryUnmapReserve",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "memoryMapPlaced") return features.memoryMapPlaced == VK_TRUE;
        if (name == "memoryMapRangePlaced") return features.memoryMapRangePlaced == VK_TRUE;
        if (name == "memoryUnmapReserve") return features.memoryUnmapReserve == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "memoryMapPlaced") { features.memoryMapPlaced = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "memoryMapRangePlaced") { features.memoryMapRangePlaced = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "memoryUnmapReserve") { features.memoryUnmapReserve = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceMapMemoryPlacedFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceMapMemoryPlacedFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceMapMemoryPlacedFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceMapMemoryPlacedFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceMapMemoryPlacedFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceMemoryDecompressionEXT
// Wraps: vk::PhysicalDeviceMemoryDecompressionFeaturesEXT
// Extension: VK_EXT_MEMORY_DECOMPRESSION_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceMemoryDecompressionEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_EXT_MEMORY_DECOMPRESSION_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "memoryDecompression",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "memoryDecompression") return features.memoryDecompression == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "memoryDecompression") { features.memoryDecompression = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceMemoryDecompressionFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceMemoryDecompressionFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceMemoryDecompressionFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceMemoryDecompressionFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceMemoryDecompressionFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceMemoryPriorityEXT
// Wraps: vk::PhysicalDeviceMemoryPriorityFeaturesEXT
// Extension: VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceMemoryPriorityEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "memoryPriority",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "memoryPriority") return features.memoryPriority == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "memoryPriority") { features.memoryPriority = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceMemoryPriorityFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceMemoryPriorityFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceMemoryPriorityFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceMemoryPriorityFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceMemoryPriorityFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceMeshShaderEXT
// Wraps: vk::PhysicalDeviceMeshShaderFeaturesEXT
// Extension: VK_EXT_MESH_SHADER_EXTENSION_NAME
// Core in: VK_API_VERSION_1_2
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceMeshShaderEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_2) {
            return {};
        }
        return {VK_EXT_MESH_SHADER_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "taskShader",
            "meshShader",
            "multiviewMeshShader",
            "primitiveFragmentShadingRateMeshShader",
            "meshShaderQueries",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "taskShader") return features.taskShader == VK_TRUE;
        if (name == "meshShader") return features.meshShader == VK_TRUE;
        if (name == "multiviewMeshShader") return features.multiviewMeshShader == VK_TRUE;
        if (name == "primitiveFragmentShadingRateMeshShader") return features.primitiveFragmentShadingRateMeshShader == VK_TRUE;
        if (name == "meshShaderQueries") return features.meshShaderQueries == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "taskShader") { features.taskShader = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "meshShader") { features.meshShader = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "multiviewMeshShader") { features.multiviewMeshShader = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "primitiveFragmentShadingRateMeshShader") { features.primitiveFragmentShadingRateMeshShader = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "meshShaderQueries") { features.meshShaderQueries = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceMeshShaderFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceMeshShaderFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceMeshShaderFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceMeshShaderFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceMeshShaderFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceMeshShaderNV
// Wraps: vk::PhysicalDeviceMeshShaderFeaturesNV
// Extension: VK_NV_MESH_SHADER_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceMeshShaderNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_MESH_SHADER_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "taskShader",
            "meshShader",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "taskShader") return features.taskShader == VK_TRUE;
        if (name == "meshShader") return features.meshShader == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "taskShader") { features.taskShader = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "meshShader") { features.meshShader = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceMeshShaderFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceMeshShaderFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceMeshShaderFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceMeshShaderFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceMeshShaderFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceMultiDrawEXT
// Wraps: vk::PhysicalDeviceMultiDrawFeaturesEXT
// Extension: VK_EXT_MULTI_DRAW_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceMultiDrawEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_MULTI_DRAW_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "multiDraw",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "multiDraw") return features.multiDraw == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "multiDraw") { features.multiDraw = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceMultiDrawFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceMultiDrawFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceMultiDrawFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceMultiDrawFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceMultiDrawFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceMultisampledRenderToSingleSampledEXT
// Wraps: vk::PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT
// Extension: VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_EXTENSION_NAME
// Core in: VK_API_VERSION_1_2
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceMultisampledRenderToSingleSampledEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_2) {
            return {};
        }
        return {VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "multisampledRenderToSingleSampled",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "multisampledRenderToSingleSampled") return features.multisampledRenderToSingleSampled == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "multisampledRenderToSingleSampled") { features.multisampledRenderToSingleSampled = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceMultiview
// Wraps: vk::PhysicalDeviceMultiviewFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceMultiview : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "multiview",
            "multiviewGeometryShader",
            "multiviewTessellationShader",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "multiview") return features.multiview == VK_TRUE;
        if (name == "multiviewGeometryShader") return features.multiviewGeometryShader == VK_TRUE;
        if (name == "multiviewTessellationShader") return features.multiviewTessellationShader == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "multiview") { features.multiview = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "multiviewGeometryShader") { features.multiviewGeometryShader = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "multiviewTessellationShader") { features.multiviewTessellationShader = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceMultiviewFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceMultiviewFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceMultiviewFeatures& get() { return features; }
    const vk::PhysicalDeviceMultiviewFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceMultiviewFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceMultiviewPerViewRenderAreasQCOM
// Wraps: vk::PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM
// Extension: VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceMultiviewPerViewRenderAreasQCOM : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "multiviewPerViewRenderAreas",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "multiviewPerViewRenderAreas") return features.multiviewPerViewRenderAreas == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "multiviewPerViewRenderAreas") { features.multiviewPerViewRenderAreas = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM& get() { return features; }
    const vk::PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM& get() const { return features; }

  private:
    vk::PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceMultiviewPerViewViewportsQCOM
// Wraps: vk::PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM
// Extension: VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceMultiviewPerViewViewportsQCOM : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "multiviewPerViewViewports",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "multiviewPerViewViewports") return features.multiviewPerViewViewports == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "multiviewPerViewViewports") { features.multiviewPerViewViewports = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM& get() { return features; }
    const vk::PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM& get() const { return features; }

  private:
    vk::PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceMutableDescriptorTypeEXT
// Wraps: vk::PhysicalDeviceMutableDescriptorTypeFeaturesEXT
// Extension: VK_EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceMutableDescriptorTypeEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "mutableDescriptorType",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "mutableDescriptorType") return features.mutableDescriptorType == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "mutableDescriptorType") { features.mutableDescriptorType = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceMutableDescriptorTypeFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceMutableDescriptorTypeFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceMutableDescriptorTypeFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceMutableDescriptorTypeFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceMutableDescriptorTypeFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceNestedCommandBufferEXT
// Wraps: vk::PhysicalDeviceNestedCommandBufferFeaturesEXT
// Extension: VK_EXT_NESTED_COMMAND_BUFFER_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceNestedCommandBufferEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_NESTED_COMMAND_BUFFER_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "nestedCommandBuffer",
            "nestedCommandBufferRendering",
            "nestedCommandBufferSimultaneousUse",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "nestedCommandBuffer") return features.nestedCommandBuffer == VK_TRUE;
        if (name == "nestedCommandBufferRendering") return features.nestedCommandBufferRendering == VK_TRUE;
        if (name == "nestedCommandBufferSimultaneousUse") return features.nestedCommandBufferSimultaneousUse == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "nestedCommandBuffer") { features.nestedCommandBuffer = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "nestedCommandBufferRendering") { features.nestedCommandBufferRendering = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "nestedCommandBufferSimultaneousUse") { features.nestedCommandBufferSimultaneousUse = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceNestedCommandBufferFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceNestedCommandBufferFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceNestedCommandBufferFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceNestedCommandBufferFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceNestedCommandBufferFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceNonSeamlessCubeMapEXT
// Wraps: vk::PhysicalDeviceNonSeamlessCubeMapFeaturesEXT
// Extension: VK_EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceNonSeamlessCubeMapEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "nonSeamlessCubeMap",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "nonSeamlessCubeMap") return features.nonSeamlessCubeMap == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "nonSeamlessCubeMap") { features.nonSeamlessCubeMap = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceNonSeamlessCubeMapFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceNonSeamlessCubeMapFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceNonSeamlessCubeMapFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceNonSeamlessCubeMapFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceNonSeamlessCubeMapFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceOpacityMicromapEXT
// Wraps: vk::PhysicalDeviceOpacityMicromapFeaturesEXT
// Extension: VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME
// Core in: VK_API_VERSION_1_3
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceOpacityMicromapEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_3) {
            return {};
        }
        return {VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "micromap",
            "micromapCaptureReplay",
            "micromapHostCommands",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "micromap") return features.micromap == VK_TRUE;
        if (name == "micromapCaptureReplay") return features.micromapCaptureReplay == VK_TRUE;
        if (name == "micromapHostCommands") return features.micromapHostCommands == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "micromap") { features.micromap = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "micromapCaptureReplay") { features.micromapCaptureReplay = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "micromapHostCommands") { features.micromapHostCommands = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceOpacityMicromapFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceOpacityMicromapFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceOpacityMicromapFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceOpacityMicromapFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceOpacityMicromapFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceOpticalFlowNV
// Wraps: vk::PhysicalDeviceOpticalFlowFeaturesNV
// Extension: VK_NV_OPTICAL_FLOW_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceOpticalFlowNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_OPTICAL_FLOW_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "opticalFlow",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "opticalFlow") return features.opticalFlow == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "opticalFlow") { features.opticalFlow = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceOpticalFlowFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceOpticalFlowFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceOpticalFlowFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceOpticalFlowFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceOpticalFlowFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePageableDeviceLocalMemoryEXT
// Wraps: vk::PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT
// Extension: VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePageableDeviceLocalMemoryEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "pageableDeviceLocalMemory",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "pageableDeviceLocalMemory") return features.pageableDeviceLocalMemory == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "pageableDeviceLocalMemory") { features.pageableDeviceLocalMemory = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePageableDeviceLocalMemoryFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT& get() { return features; }
    const vk::PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePartitionedAccelerationStructureNV
// Wraps: vk::PhysicalDevicePartitionedAccelerationStructureFeaturesNV
// Extension: VK_NV_PARTITIONED_ACCELERATION_STRUCTURE_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePartitionedAccelerationStructureNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_NV_PARTITIONED_ACCELERATION_STRUCTURE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "partitionedAccelerationStructure",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "partitionedAccelerationStructure") return features.partitionedAccelerationStructure == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "partitionedAccelerationStructure") { features.partitionedAccelerationStructure = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePartitionedAccelerationStructureFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePartitionedAccelerationStructureFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePartitionedAccelerationStructureFeaturesNV& get() { return features; }
    const vk::PhysicalDevicePartitionedAccelerationStructureFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDevicePartitionedAccelerationStructureFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePerStageDescriptorSetNV
// Wraps: vk::PhysicalDevicePerStageDescriptorSetFeaturesNV
// Extension: VK_NV_PER_STAGE_DESCRIPTOR_SET_EXTENSION_NAME
// Core in: VK_API_VERSION_1_4
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePerStageDescriptorSetNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_4) {
            return {};
        }
        return {VK_NV_PER_STAGE_DESCRIPTOR_SET_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "perStageDescriptorSet",
            "dynamicPipelineLayout",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "perStageDescriptorSet") return features.perStageDescriptorSet == VK_TRUE;
        if (name == "dynamicPipelineLayout") return features.dynamicPipelineLayout == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "perStageDescriptorSet") { features.perStageDescriptorSet = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "dynamicPipelineLayout") { features.dynamicPipelineLayout = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePerStageDescriptorSetFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePerStageDescriptorSetFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePerStageDescriptorSetFeaturesNV& get() { return features; }
    const vk::PhysicalDevicePerStageDescriptorSetFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDevicePerStageDescriptorSetFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePerformanceCountersByRegionARM
// Wraps: vk::PhysicalDevicePerformanceCountersByRegionFeaturesARM
// Extension: VK_ARM_PERFORMANCE_COUNTERS_BY_REGION_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePerformanceCountersByRegionARM : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_ARM_PERFORMANCE_COUNTERS_BY_REGION_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "performanceCountersByRegion",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "performanceCountersByRegion") return features.performanceCountersByRegion == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "performanceCountersByRegion") { features.performanceCountersByRegion = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePerformanceCountersByRegionFeaturesARM";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePerformanceCountersByRegionFeaturesARM;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePerformanceCountersByRegionFeaturesARM& get() { return features; }
    const vk::PhysicalDevicePerformanceCountersByRegionFeaturesARM& get() const { return features; }

  private:
    vk::PhysicalDevicePerformanceCountersByRegionFeaturesARM features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePerformanceQueryKHR
// Wraps: vk::PhysicalDevicePerformanceQueryFeaturesKHR
// Extension: VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePerformanceQueryKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "performanceCounterQueryPools",
            "performanceCounterMultipleQueryPools",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "performanceCounterQueryPools") return features.performanceCounterQueryPools == VK_TRUE;
        if (name == "performanceCounterMultipleQueryPools") return features.performanceCounterMultipleQueryPools == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "performanceCounterQueryPools") { features.performanceCounterQueryPools = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "performanceCounterMultipleQueryPools") { features.performanceCounterMultipleQueryPools = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePerformanceQueryFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePerformanceQueryFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePerformanceQueryFeaturesKHR& get() { return features; }
    const vk::PhysicalDevicePerformanceQueryFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDevicePerformanceQueryFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePipelineBinaryKHR
// Wraps: vk::PhysicalDevicePipelineBinaryFeaturesKHR
// Extension: VK_KHR_PIPELINE_BINARY_EXTENSION_NAME
// Core in: VK_API_VERSION_1_4
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePipelineBinaryKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_4) {
            return {};
        }
        return {VK_KHR_PIPELINE_BINARY_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "pipelineBinaries",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "pipelineBinaries") return features.pipelineBinaries == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "pipelineBinaries") { features.pipelineBinaries = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePipelineBinaryFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePipelineBinaryFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePipelineBinaryFeaturesKHR& get() { return features; }
    const vk::PhysicalDevicePipelineBinaryFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDevicePipelineBinaryFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePipelineCacheIncrementalModeSEC
// Wraps: vk::PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC
// Extension: VK_SEC_PIPELINE_CACHE_INCREMENTAL_MODE_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePipelineCacheIncrementalModeSEC : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_SEC_PIPELINE_CACHE_INCREMENTAL_MODE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "pipelineCacheIncrementalMode",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "pipelineCacheIncrementalMode") return features.pipelineCacheIncrementalMode == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "pipelineCacheIncrementalMode") { features.pipelineCacheIncrementalMode = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePipelineCacheIncrementalModeFeaturesSEC;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC& get() { return features; }
    const vk::PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC& get() const { return features; }

  private:
    vk::PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePipelineCreationCacheControl
// Wraps: vk::PhysicalDevicePipelineCreationCacheControlFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePipelineCreationCacheControl : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "pipelineCreationCacheControl",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "pipelineCreationCacheControl") return features.pipelineCreationCacheControl == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "pipelineCreationCacheControl") { features.pipelineCreationCacheControl = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePipelineCreationCacheControlFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePipelineCreationCacheControlFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePipelineCreationCacheControlFeatures& get() { return features; }
    const vk::PhysicalDevicePipelineCreationCacheControlFeatures& get() const { return features; }

  private:
    vk::PhysicalDevicePipelineCreationCacheControlFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePipelineExecutablePropertiesKHR
// Wraps: vk::PhysicalDevicePipelineExecutablePropertiesFeaturesKHR
// Extension: VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePipelineExecutablePropertiesKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "pipelineExecutableInfo",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "pipelineExecutableInfo") return features.pipelineExecutableInfo == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "pipelineExecutableInfo") { features.pipelineExecutableInfo = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePipelineExecutablePropertiesFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePipelineExecutablePropertiesFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePipelineExecutablePropertiesFeaturesKHR& get() { return features; }
    const vk::PhysicalDevicePipelineExecutablePropertiesFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDevicePipelineExecutablePropertiesFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePipelineLibraryGroupHandlesEXT
// Wraps: vk::PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT
// Extension: VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePipelineLibraryGroupHandlesEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "pipelineLibraryGroupHandles",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "pipelineLibraryGroupHandles") return features.pipelineLibraryGroupHandles == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "pipelineLibraryGroupHandles") { features.pipelineLibraryGroupHandles = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT& get() { return features; }
    const vk::PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePipelineOpacityMicromapARM
// Wraps: vk::PhysicalDevicePipelineOpacityMicromapFeaturesARM
// Extension: VK_ARM_PIPELINE_OPACITY_MICROMAP_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePipelineOpacityMicromapARM : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_ARM_PIPELINE_OPACITY_MICROMAP_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "pipelineOpacityMicromap",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "pipelineOpacityMicromap") return features.pipelineOpacityMicromap == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "pipelineOpacityMicromap") { features.pipelineOpacityMicromap = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePipelineOpacityMicromapFeaturesARM";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePipelineOpacityMicromapFeaturesARM;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePipelineOpacityMicromapFeaturesARM& get() { return features; }
    const vk::PhysicalDevicePipelineOpacityMicromapFeaturesARM& get() const { return features; }

  private:
    vk::PhysicalDevicePipelineOpacityMicromapFeaturesARM features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePipelinePropertiesEXT
// Wraps: vk::PhysicalDevicePipelinePropertiesFeaturesEXT
// Extension: VK_EXT_PIPELINE_PROPERTIES_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePipelinePropertiesEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_PIPELINE_PROPERTIES_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "pipelinePropertiesIdentifier",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "pipelinePropertiesIdentifier") return features.pipelinePropertiesIdentifier == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "pipelinePropertiesIdentifier") { features.pipelinePropertiesIdentifier = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePipelinePropertiesFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePipelinePropertiesFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePipelinePropertiesFeaturesEXT& get() { return features; }
    const vk::PhysicalDevicePipelinePropertiesFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDevicePipelinePropertiesFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePipelineProtectedAccess
// Wraps: vk::PhysicalDevicePipelineProtectedAccessFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePipelineProtectedAccess : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "pipelineProtectedAccess",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "pipelineProtectedAccess") return features.pipelineProtectedAccess == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "pipelineProtectedAccess") { features.pipelineProtectedAccess = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePipelineProtectedAccessFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePipelineProtectedAccessFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePipelineProtectedAccessFeatures& get() { return features; }
    const vk::PhysicalDevicePipelineProtectedAccessFeatures& get() const { return features; }

  private:
    vk::PhysicalDevicePipelineProtectedAccessFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePipelineRobustness
// Wraps: vk::PhysicalDevicePipelineRobustnessFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePipelineRobustness : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "pipelineRobustness",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "pipelineRobustness") return features.pipelineRobustness == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "pipelineRobustness") { features.pipelineRobustness = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePipelineRobustnessFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePipelineRobustnessFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePipelineRobustnessFeatures& get() { return features; }
    const vk::PhysicalDevicePipelineRobustnessFeatures& get() const { return features; }

  private:
    vk::PhysicalDevicePipelineRobustnessFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePresentBarrierNV
// Wraps: vk::PhysicalDevicePresentBarrierFeaturesNV
// Extension: VK_NV_PRESENT_BARRIER_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePresentBarrierNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_PRESENT_BARRIER_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "presentBarrier",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "presentBarrier") return features.presentBarrier == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "presentBarrier") { features.presentBarrier = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePresentBarrierFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePresentBarrierFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePresentBarrierFeaturesNV& get() { return features; }
    const vk::PhysicalDevicePresentBarrierFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDevicePresentBarrierFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePresentId2KHR
// Wraps: vk::PhysicalDevicePresentId2FeaturesKHR
// Extension: VK_KHR_PRESENT_ID_2_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePresentId2KHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_KHR_PRESENT_ID_2_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "presentId2",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "presentId2") return features.presentId2 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "presentId2") { features.presentId2 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePresentId2FeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePresentId2FeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePresentId2FeaturesKHR& get() { return features; }
    const vk::PhysicalDevicePresentId2FeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDevicePresentId2FeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePresentIdKHR
// Wraps: vk::PhysicalDevicePresentIdFeaturesKHR
// Extension: VK_KHR_PRESENT_ID_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePresentIdKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_PRESENT_ID_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "presentId",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "presentId") return features.presentId == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "presentId") { features.presentId = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePresentIdFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePresentIdFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePresentIdFeaturesKHR& get() { return features; }
    const vk::PhysicalDevicePresentIdFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDevicePresentIdFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePresentModeFifoLatestReadyKHR
// Wraps: vk::PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR
// Extension: VK_KHR_PRESENT_MODE_FIFO_LATEST_READY_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePresentModeFifoLatestReadyKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_KHR_PRESENT_MODE_FIFO_LATEST_READY_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "presentModeFifoLatestReady",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "presentModeFifoLatestReady") return features.presentModeFifoLatestReady == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "presentModeFifoLatestReady") { features.presentModeFifoLatestReady = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePresentModeFifoLatestReadyFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR& get() { return features; }
    const vk::PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePresentTimingEXT
// Wraps: vk::PhysicalDevicePresentTimingFeaturesEXT
// Extension: VK_EXT_PRESENT_TIMING_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePresentTimingEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_EXT_PRESENT_TIMING_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "presentTiming",
            "presentAtAbsoluteTime",
            "presentAtRelativeTime",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "presentTiming") return features.presentTiming == VK_TRUE;
        if (name == "presentAtAbsoluteTime") return features.presentAtAbsoluteTime == VK_TRUE;
        if (name == "presentAtRelativeTime") return features.presentAtRelativeTime == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "presentTiming") { features.presentTiming = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "presentAtAbsoluteTime") { features.presentAtAbsoluteTime = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "presentAtRelativeTime") { features.presentAtRelativeTime = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePresentTimingFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePresentTimingFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePresentTimingFeaturesEXT& get() { return features; }
    const vk::PhysicalDevicePresentTimingFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDevicePresentTimingFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePresentWait2KHR
// Wraps: vk::PhysicalDevicePresentWait2FeaturesKHR
// Extension: VK_KHR_PRESENT_WAIT_2_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePresentWait2KHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_KHR_PRESENT_WAIT_2_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "presentWait2",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "presentWait2") return features.presentWait2 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "presentWait2") { features.presentWait2 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePresentWait2FeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePresentWait2FeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePresentWait2FeaturesKHR& get() { return features; }
    const vk::PhysicalDevicePresentWait2FeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDevicePresentWait2FeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePresentWaitKHR
// Wraps: vk::PhysicalDevicePresentWaitFeaturesKHR
// Extension: VK_KHR_PRESENT_WAIT_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePresentWaitKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_KHR_PRESENT_WAIT_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "presentWait",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "presentWait") return features.presentWait == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "presentWait") { features.presentWait = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePresentWaitFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePresentWaitFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePresentWaitFeaturesKHR& get() { return features; }
    const vk::PhysicalDevicePresentWaitFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDevicePresentWaitFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePrimitiveTopologyListRestartEXT
// Wraps: vk::PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT
// Extension: VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePrimitiveTopologyListRestartEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "primitiveTopologyListRestart",
            "primitiveTopologyPatchListRestart",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "primitiveTopologyListRestart") return features.primitiveTopologyListRestart == VK_TRUE;
        if (name == "primitiveTopologyPatchListRestart") return features.primitiveTopologyPatchListRestart == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "primitiveTopologyListRestart") { features.primitiveTopologyListRestart = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "primitiveTopologyPatchListRestart") { features.primitiveTopologyPatchListRestart = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePrimitiveTopologyListRestartFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT& get() { return features; }
    const vk::PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePrimitivesGeneratedQueryEXT
// Wraps: vk::PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT
// Extension: VK_EXT_PRIMITIVES_GENERATED_QUERY_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePrimitivesGeneratedQueryEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_EXT_PRIMITIVES_GENERATED_QUERY_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "primitivesGeneratedQuery",
            "primitivesGeneratedQueryWithRasterizerDiscard",
            "primitivesGeneratedQueryWithNonZeroStreams",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "primitivesGeneratedQuery") return features.primitivesGeneratedQuery == VK_TRUE;
        if (name == "primitivesGeneratedQueryWithRasterizerDiscard") return features.primitivesGeneratedQueryWithRasterizerDiscard == VK_TRUE;
        if (name == "primitivesGeneratedQueryWithNonZeroStreams") return features.primitivesGeneratedQueryWithNonZeroStreams == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "primitivesGeneratedQuery") { features.primitivesGeneratedQuery = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "primitivesGeneratedQueryWithRasterizerDiscard") { features.primitivesGeneratedQueryWithRasterizerDiscard = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "primitivesGeneratedQueryWithNonZeroStreams") { features.primitivesGeneratedQueryWithNonZeroStreams = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePrimitivesGeneratedQueryFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT& get() { return features; }
    const vk::PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDevicePrivateData
// Wraps: vk::PhysicalDevicePrivateDataFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDevicePrivateData : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "privateData",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "privateData") return features.privateData == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "privateData") { features.privateData = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDevicePrivateDataFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDevicePrivateDataFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDevicePrivateDataFeatures& get() { return features; }
    const vk::PhysicalDevicePrivateDataFeatures& get() const { return features; }

  private:
    vk::PhysicalDevicePrivateDataFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceProtectedMemory
// Wraps: vk::PhysicalDeviceProtectedMemoryFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceProtectedMemory : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "protectedMemory",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "protectedMemory") return features.protectedMemory == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "protectedMemory") { features.protectedMemory = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceProtectedMemoryFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceProtectedMemoryFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceProtectedMemoryFeatures& get() { return features; }
    const vk::PhysicalDeviceProtectedMemoryFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceProtectedMemoryFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceProvokingVertexEXT
// Wraps: vk::PhysicalDeviceProvokingVertexFeaturesEXT
// Extension: VK_EXT_PROVOKING_VERTEX_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceProvokingVertexEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_PROVOKING_VERTEX_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "provokingVertexLast",
            "transformFeedbackPreservesProvokingVertex",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "provokingVertexLast") return features.provokingVertexLast == VK_TRUE;
        if (name == "transformFeedbackPreservesProvokingVertex") return features.transformFeedbackPreservesProvokingVertex == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "provokingVertexLast") { features.provokingVertexLast = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "transformFeedbackPreservesProvokingVertex") { features.transformFeedbackPreservesProvokingVertex = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceProvokingVertexFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceProvokingVertexFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceProvokingVertexFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceProvokingVertexFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceProvokingVertexFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceRGBA10X6FormatsEXT
// Wraps: vk::PhysicalDeviceRGBA10X6FormatsFeaturesEXT
// Extension: VK_EXT_RGBA10X6_FORMATS_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceRGBA10X6FormatsEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_RGBA10X6_FORMATS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "formatRgba10x6WithoutYCbCrSampler",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "formatRgba10x6WithoutYCbCrSampler") return features.formatRgba10x6WithoutYCbCrSampler == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "formatRgba10x6WithoutYCbCrSampler") { features.formatRgba10x6WithoutYCbCrSampler = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceRGBA10X6FormatsFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceRgba10X6FormatsFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceRGBA10X6FormatsFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceRGBA10X6FormatsFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceRGBA10X6FormatsFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceRasterizationOrderAttachmentAccessEXT
// Wraps: vk::PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT
// Extension: VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceRasterizationOrderAttachmentAccessEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "rasterizationOrderColorAttachmentAccess",
            "rasterizationOrderDepthAttachmentAccess",
            "rasterizationOrderStencilAttachmentAccess",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "rasterizationOrderColorAttachmentAccess") return features.rasterizationOrderColorAttachmentAccess == VK_TRUE;
        if (name == "rasterizationOrderDepthAttachmentAccess") return features.rasterizationOrderDepthAttachmentAccess == VK_TRUE;
        if (name == "rasterizationOrderStencilAttachmentAccess") return features.rasterizationOrderStencilAttachmentAccess == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "rasterizationOrderColorAttachmentAccess") { features.rasterizationOrderColorAttachmentAccess = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "rasterizationOrderDepthAttachmentAccess") { features.rasterizationOrderDepthAttachmentAccess = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "rasterizationOrderStencilAttachmentAccess") { features.rasterizationOrderStencilAttachmentAccess = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceRawAccessChainsNV
// Wraps: vk::PhysicalDeviceRawAccessChainsFeaturesNV
// Extension: VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceRawAccessChainsNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderRawAccessChains",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderRawAccessChains") return features.shaderRawAccessChains == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderRawAccessChains") { features.shaderRawAccessChains = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceRawAccessChainsFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceRawAccessChainsFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceRawAccessChainsFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceRawAccessChainsFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceRawAccessChainsFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceRayQueryKHR
// Wraps: vk::PhysicalDeviceRayQueryFeaturesKHR
// Extension: VK_KHR_RAY_QUERY_EXTENSION_NAME
// Core in: VK_API_VERSION_1_2
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceRayQueryKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_2) {
            return {};
        }
        return {VK_KHR_RAY_QUERY_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "rayQuery",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "rayQuery") return features.rayQuery == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "rayQuery") { features.rayQuery = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceRayQueryFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceRayQueryFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceRayQueryFeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceRayQueryFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceRayQueryFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceRayTracingInvocationReorderEXT
// Wraps: vk::PhysicalDeviceRayTracingInvocationReorderFeaturesEXT
// Extension: VK_EXT_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceRayTracingInvocationReorderEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_EXT_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "rayTracingInvocationReorder",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "rayTracingInvocationReorder") return features.rayTracingInvocationReorder == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "rayTracingInvocationReorder") { features.rayTracingInvocationReorder = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceRayTracingInvocationReorderFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceRayTracingInvocationReorderFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceRayTracingInvocationReorderFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceRayTracingInvocationReorderFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceRayTracingInvocationReorderFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceRayTracingInvocationReorderNV
// Wraps: vk::PhysicalDeviceRayTracingInvocationReorderFeaturesNV
// Extension: VK_NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceRayTracingInvocationReorderNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "rayTracingInvocationReorder",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "rayTracingInvocationReorder") return features.rayTracingInvocationReorder == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "rayTracingInvocationReorder") { features.rayTracingInvocationReorder = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceRayTracingInvocationReorderFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceRayTracingInvocationReorderFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceRayTracingInvocationReorderFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceRayTracingInvocationReorderFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceRayTracingInvocationReorderFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceRayTracingLinearSweptSpheresNV
// Wraps: vk::PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV
// Extension: VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceRayTracingLinearSweptSpheresNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "spheres",
            "linearSweptSpheres",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "spheres") return features.spheres == VK_TRUE;
        if (name == "linearSweptSpheres") return features.linearSweptSpheres == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "spheres") { features.spheres = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "linearSweptSpheres") { features.linearSweptSpheres = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceRayTracingMaintenance1KHR
// Wraps: vk::PhysicalDeviceRayTracingMaintenance1FeaturesKHR
// Extension: VK_KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceRayTracingMaintenance1KHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "rayTracingMaintenance1",
            "rayTracingPipelineTraceRaysIndirect2",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "rayTracingMaintenance1") return features.rayTracingMaintenance1 == VK_TRUE;
        if (name == "rayTracingPipelineTraceRaysIndirect2") return features.rayTracingPipelineTraceRaysIndirect2 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "rayTracingMaintenance1") { features.rayTracingMaintenance1 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "rayTracingPipelineTraceRaysIndirect2") { features.rayTracingPipelineTraceRaysIndirect2 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceRayTracingMaintenance1FeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceRayTracingMaintenance1FeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceRayTracingMaintenance1FeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceRayTracingMaintenance1FeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceRayTracingMaintenance1FeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceRayTracingMotionBlurNV
// Wraps: vk::PhysicalDeviceRayTracingMotionBlurFeaturesNV
// Extension: VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceRayTracingMotionBlurNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "rayTracingMotionBlur",
            "rayTracingMotionBlurPipelineTraceRaysIndirect",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "rayTracingMotionBlur") return features.rayTracingMotionBlur == VK_TRUE;
        if (name == "rayTracingMotionBlurPipelineTraceRaysIndirect") return features.rayTracingMotionBlurPipelineTraceRaysIndirect == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "rayTracingMotionBlur") { features.rayTracingMotionBlur = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "rayTracingMotionBlurPipelineTraceRaysIndirect") { features.rayTracingMotionBlurPipelineTraceRaysIndirect = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceRayTracingMotionBlurFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceRayTracingMotionBlurFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceRayTracingMotionBlurFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceRayTracingMotionBlurFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceRayTracingMotionBlurFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceRayTracingPipelineKHR
// Wraps: vk::PhysicalDeviceRayTracingPipelineFeaturesKHR
// Extension: VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME
// Core in: VK_API_VERSION_1_2
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceRayTracingPipelineKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_2) {
            return {};
        }
        return {VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "rayTracingPipeline",
            "rayTracingPipelineShaderGroupHandleCaptureReplay",
            "rayTracingPipelineShaderGroupHandleCaptureReplayMixed",
            "rayTracingPipelineTraceRaysIndirect",
            "rayTraversalPrimitiveCulling",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "rayTracingPipeline") return features.rayTracingPipeline == VK_TRUE;
        if (name == "rayTracingPipelineShaderGroupHandleCaptureReplay") return features.rayTracingPipelineShaderGroupHandleCaptureReplay == VK_TRUE;
        if (name == "rayTracingPipelineShaderGroupHandleCaptureReplayMixed") return features.rayTracingPipelineShaderGroupHandleCaptureReplayMixed == VK_TRUE;
        if (name == "rayTracingPipelineTraceRaysIndirect") return features.rayTracingPipelineTraceRaysIndirect == VK_TRUE;
        if (name == "rayTraversalPrimitiveCulling") return features.rayTraversalPrimitiveCulling == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "rayTracingPipeline") { features.rayTracingPipeline = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "rayTracingPipelineShaderGroupHandleCaptureReplay") { features.rayTracingPipelineShaderGroupHandleCaptureReplay = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "rayTracingPipelineShaderGroupHandleCaptureReplayMixed") { features.rayTracingPipelineShaderGroupHandleCaptureReplayMixed = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "rayTracingPipelineTraceRaysIndirect") { features.rayTracingPipelineTraceRaysIndirect = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "rayTraversalPrimitiveCulling") { features.rayTraversalPrimitiveCulling = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceRayTracingPipelineFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceRayTracingPipelineFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceRayTracingPipelineFeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceRayTracingPipelineFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceRayTracingPipelineFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceRayTracingPositionFetchKHR
// Wraps: vk::PhysicalDeviceRayTracingPositionFetchFeaturesKHR
// Extension: VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceRayTracingPositionFetchKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "rayTracingPositionFetch",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "rayTracingPositionFetch") return features.rayTracingPositionFetch == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "rayTracingPositionFetch") { features.rayTracingPositionFetch = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceRayTracingPositionFetchFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceRayTracingPositionFetchFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceRayTracingPositionFetchFeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceRayTracingPositionFetchFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceRayTracingPositionFetchFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceRayTracingValidationNV
// Wraps: vk::PhysicalDeviceRayTracingValidationFeaturesNV
// Extension: VK_NV_RAY_TRACING_VALIDATION_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceRayTracingValidationNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_RAY_TRACING_VALIDATION_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "rayTracingValidation",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "rayTracingValidation") return features.rayTracingValidation == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "rayTracingValidation") { features.rayTracingValidation = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceRayTracingValidationFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceRayTracingValidationFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceRayTracingValidationFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceRayTracingValidationFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceRayTracingValidationFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceRelaxedLineRasterizationIMG
// Wraps: vk::PhysicalDeviceRelaxedLineRasterizationFeaturesIMG
// Extension: VK_IMG_RELAXED_LINE_RASTERIZATION_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceRelaxedLineRasterizationIMG : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_IMG_RELAXED_LINE_RASTERIZATION_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "relaxedLineRasterization",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "relaxedLineRasterization") return features.relaxedLineRasterization == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "relaxedLineRasterization") { features.relaxedLineRasterization = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceRelaxedLineRasterizationFeaturesIMG";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceRelaxedLineRasterizationFeaturesIMG;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceRelaxedLineRasterizationFeaturesIMG& get() { return features; }
    const vk::PhysicalDeviceRelaxedLineRasterizationFeaturesIMG& get() const { return features; }

  private:
    vk::PhysicalDeviceRelaxedLineRasterizationFeaturesIMG features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceRenderPassStripedARM
// Wraps: vk::PhysicalDeviceRenderPassStripedFeaturesARM
// Extension: VK_ARM_RENDER_PASS_STRIPED_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceRenderPassStripedARM : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_ARM_RENDER_PASS_STRIPED_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "renderPassStriped",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "renderPassStriped") return features.renderPassStriped == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "renderPassStriped") { features.renderPassStriped = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceRenderPassStripedFeaturesARM";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceRenderPassStripedFeaturesARM;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceRenderPassStripedFeaturesARM& get() { return features; }
    const vk::PhysicalDeviceRenderPassStripedFeaturesARM& get() const { return features; }

  private:
    vk::PhysicalDeviceRenderPassStripedFeaturesARM features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceRepresentativeFragmentTestNV
// Wraps: vk::PhysicalDeviceRepresentativeFragmentTestFeaturesNV
// Extension: VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceRepresentativeFragmentTestNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "representativeFragmentTest",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "representativeFragmentTest") return features.representativeFragmentTest == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "representativeFragmentTest") { features.representativeFragmentTest = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceRepresentativeFragmentTestFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceRepresentativeFragmentTestFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceRepresentativeFragmentTestFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceRepresentativeFragmentTestFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceRepresentativeFragmentTestFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceRobustness2KHR
// Wraps: vk::PhysicalDeviceRobustness2FeaturesKHR
// Extension: VK_KHR_ROBUSTNESS_2_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceRobustness2KHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_ROBUSTNESS_2_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "robustBufferAccess2",
            "robustImageAccess2",
            "nullDescriptor",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "robustBufferAccess2") return features.robustBufferAccess2 == VK_TRUE;
        if (name == "robustImageAccess2") return features.robustImageAccess2 == VK_TRUE;
        if (name == "nullDescriptor") return features.nullDescriptor == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "robustBufferAccess2") { features.robustBufferAccess2 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "robustImageAccess2") { features.robustImageAccess2 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "nullDescriptor") { features.nullDescriptor = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceRobustness2FeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceRobustness2FeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceRobustness2FeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceRobustness2FeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceRobustness2FeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceSamplerYcbcrConversion
// Wraps: vk::PhysicalDeviceSamplerYcbcrConversionFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceSamplerYcbcrConversion : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "samplerYcbcrConversion",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "samplerYcbcrConversion") return features.samplerYcbcrConversion == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "samplerYcbcrConversion") { features.samplerYcbcrConversion = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceSamplerYcbcrConversionFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceSamplerYcbcrConversionFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceSamplerYcbcrConversionFeatures& get() { return features; }
    const vk::PhysicalDeviceSamplerYcbcrConversionFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceSamplerYcbcrConversionFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceScalarBlockLayout
// Wraps: vk::PhysicalDeviceScalarBlockLayoutFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceScalarBlockLayout : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "scalarBlockLayout",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "scalarBlockLayout") return features.scalarBlockLayout == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "scalarBlockLayout") { features.scalarBlockLayout = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceScalarBlockLayoutFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceScalarBlockLayoutFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceScalarBlockLayoutFeatures& get() { return features; }
    const vk::PhysicalDeviceScalarBlockLayoutFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceScalarBlockLayoutFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceSchedulingControlsARM
// Wraps: vk::PhysicalDeviceSchedulingControlsFeaturesARM
// Extension: VK_ARM_SCHEDULING_CONTROLS_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceSchedulingControlsARM : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_ARM_SCHEDULING_CONTROLS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "schedulingControls",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "schedulingControls") return features.schedulingControls == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "schedulingControls") { features.schedulingControls = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceSchedulingControlsFeaturesARM";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceSchedulingControlsFeaturesARM;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceSchedulingControlsFeaturesARM& get() { return features; }
    const vk::PhysicalDeviceSchedulingControlsFeaturesARM& get() const { return features; }

  private:
    vk::PhysicalDeviceSchedulingControlsFeaturesARM features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceSeparateDepthStencilLayouts
// Wraps: vk::PhysicalDeviceSeparateDepthStencilLayoutsFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceSeparateDepthStencilLayouts : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "separateDepthStencilLayouts",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "separateDepthStencilLayouts") return features.separateDepthStencilLayouts == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "separateDepthStencilLayouts") { features.separateDepthStencilLayouts = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceSeparateDepthStencilLayoutsFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceSeparateDepthStencilLayoutsFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceSeparateDepthStencilLayoutsFeatures& get() { return features; }
    const vk::PhysicalDeviceSeparateDepthStencilLayoutsFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceSeparateDepthStencilLayoutsFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShader64BitIndexingEXT
// Wraps: vk::PhysicalDeviceShader64BitIndexingFeaturesEXT
// Extension: VK_EXT_SHADER_64BIT_INDEXING_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShader64BitIndexingEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_SHADER_64BIT_INDEXING_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shader64BitIndexing",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shader64BitIndexing") return features.shader64BitIndexing == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shader64BitIndexing") { features.shader64BitIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShader64BitIndexingFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShader64BitIndexingFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShader64BitIndexingFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceShader64BitIndexingFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceShader64BitIndexingFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderAtomicFloat16VectorNV
// Wraps: vk::PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV
// Extension: VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderAtomicFloat16VectorNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderFloat16VectorAtomics",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderFloat16VectorAtomics") return features.shaderFloat16VectorAtomics == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderFloat16VectorAtomics") { features.shaderFloat16VectorAtomics = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderAtomicFloat16VectorFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderAtomicFloat2EXT
// Wraps: vk::PhysicalDeviceShaderAtomicFloat2FeaturesEXT
// Extension: VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderAtomicFloat2EXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderBufferFloat16Atomics",
            "shaderBufferFloat16AtomicAdd",
            "shaderBufferFloat16AtomicMinMax",
            "shaderBufferFloat32AtomicMinMax",
            "shaderBufferFloat64AtomicMinMax",
            "shaderSharedFloat16Atomics",
            "shaderSharedFloat16AtomicAdd",
            "shaderSharedFloat16AtomicMinMax",
            "shaderSharedFloat32AtomicMinMax",
            "shaderSharedFloat64AtomicMinMax",
            "shaderImageFloat32AtomicMinMax",
            "sparseImageFloat32AtomicMinMax",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderBufferFloat16Atomics") return features.shaderBufferFloat16Atomics == VK_TRUE;
        if (name == "shaderBufferFloat16AtomicAdd") return features.shaderBufferFloat16AtomicAdd == VK_TRUE;
        if (name == "shaderBufferFloat16AtomicMinMax") return features.shaderBufferFloat16AtomicMinMax == VK_TRUE;
        if (name == "shaderBufferFloat32AtomicMinMax") return features.shaderBufferFloat32AtomicMinMax == VK_TRUE;
        if (name == "shaderBufferFloat64AtomicMinMax") return features.shaderBufferFloat64AtomicMinMax == VK_TRUE;
        if (name == "shaderSharedFloat16Atomics") return features.shaderSharedFloat16Atomics == VK_TRUE;
        if (name == "shaderSharedFloat16AtomicAdd") return features.shaderSharedFloat16AtomicAdd == VK_TRUE;
        if (name == "shaderSharedFloat16AtomicMinMax") return features.shaderSharedFloat16AtomicMinMax == VK_TRUE;
        if (name == "shaderSharedFloat32AtomicMinMax") return features.shaderSharedFloat32AtomicMinMax == VK_TRUE;
        if (name == "shaderSharedFloat64AtomicMinMax") return features.shaderSharedFloat64AtomicMinMax == VK_TRUE;
        if (name == "shaderImageFloat32AtomicMinMax") return features.shaderImageFloat32AtomicMinMax == VK_TRUE;
        if (name == "sparseImageFloat32AtomicMinMax") return features.sparseImageFloat32AtomicMinMax == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderBufferFloat16Atomics") { features.shaderBufferFloat16Atomics = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderBufferFloat16AtomicAdd") { features.shaderBufferFloat16AtomicAdd = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderBufferFloat16AtomicMinMax") { features.shaderBufferFloat16AtomicMinMax = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderBufferFloat32AtomicMinMax") { features.shaderBufferFloat32AtomicMinMax = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderBufferFloat64AtomicMinMax") { features.shaderBufferFloat64AtomicMinMax = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderSharedFloat16Atomics") { features.shaderSharedFloat16Atomics = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderSharedFloat16AtomicAdd") { features.shaderSharedFloat16AtomicAdd = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderSharedFloat16AtomicMinMax") { features.shaderSharedFloat16AtomicMinMax = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderSharedFloat32AtomicMinMax") { features.shaderSharedFloat32AtomicMinMax = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderSharedFloat64AtomicMinMax") { features.shaderSharedFloat64AtomicMinMax = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderImageFloat32AtomicMinMax") { features.shaderImageFloat32AtomicMinMax = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "sparseImageFloat32AtomicMinMax") { features.sparseImageFloat32AtomicMinMax = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderAtomicFloat2FeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderAtomicFloat2FeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderAtomicFloat2FeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceShaderAtomicFloat2FeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderAtomicFloat2FeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderAtomicFloatEXT
// Wraps: vk::PhysicalDeviceShaderAtomicFloatFeaturesEXT
// Extension: VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderAtomicFloatEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderBufferFloat32Atomics",
            "shaderBufferFloat32AtomicAdd",
            "shaderBufferFloat64Atomics",
            "shaderBufferFloat64AtomicAdd",
            "shaderSharedFloat32Atomics",
            "shaderSharedFloat32AtomicAdd",
            "shaderSharedFloat64Atomics",
            "shaderSharedFloat64AtomicAdd",
            "shaderImageFloat32Atomics",
            "shaderImageFloat32AtomicAdd",
            "sparseImageFloat32Atomics",
            "sparseImageFloat32AtomicAdd",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderBufferFloat32Atomics") return features.shaderBufferFloat32Atomics == VK_TRUE;
        if (name == "shaderBufferFloat32AtomicAdd") return features.shaderBufferFloat32AtomicAdd == VK_TRUE;
        if (name == "shaderBufferFloat64Atomics") return features.shaderBufferFloat64Atomics == VK_TRUE;
        if (name == "shaderBufferFloat64AtomicAdd") return features.shaderBufferFloat64AtomicAdd == VK_TRUE;
        if (name == "shaderSharedFloat32Atomics") return features.shaderSharedFloat32Atomics == VK_TRUE;
        if (name == "shaderSharedFloat32AtomicAdd") return features.shaderSharedFloat32AtomicAdd == VK_TRUE;
        if (name == "shaderSharedFloat64Atomics") return features.shaderSharedFloat64Atomics == VK_TRUE;
        if (name == "shaderSharedFloat64AtomicAdd") return features.shaderSharedFloat64AtomicAdd == VK_TRUE;
        if (name == "shaderImageFloat32Atomics") return features.shaderImageFloat32Atomics == VK_TRUE;
        if (name == "shaderImageFloat32AtomicAdd") return features.shaderImageFloat32AtomicAdd == VK_TRUE;
        if (name == "sparseImageFloat32Atomics") return features.sparseImageFloat32Atomics == VK_TRUE;
        if (name == "sparseImageFloat32AtomicAdd") return features.sparseImageFloat32AtomicAdd == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderBufferFloat32Atomics") { features.shaderBufferFloat32Atomics = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderBufferFloat32AtomicAdd") { features.shaderBufferFloat32AtomicAdd = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderBufferFloat64Atomics") { features.shaderBufferFloat64Atomics = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderBufferFloat64AtomicAdd") { features.shaderBufferFloat64AtomicAdd = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderSharedFloat32Atomics") { features.shaderSharedFloat32Atomics = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderSharedFloat32AtomicAdd") { features.shaderSharedFloat32AtomicAdd = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderSharedFloat64Atomics") { features.shaderSharedFloat64Atomics = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderSharedFloat64AtomicAdd") { features.shaderSharedFloat64AtomicAdd = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderImageFloat32Atomics") { features.shaderImageFloat32Atomics = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderImageFloat32AtomicAdd") { features.shaderImageFloat32AtomicAdd = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "sparseImageFloat32Atomics") { features.sparseImageFloat32Atomics = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "sparseImageFloat32AtomicAdd") { features.sparseImageFloat32AtomicAdd = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderAtomicFloatFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderAtomicFloatFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderAtomicFloatFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceShaderAtomicFloatFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderAtomicFloatFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderAtomicInt64
// Wraps: vk::PhysicalDeviceShaderAtomicInt64Features
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderAtomicInt64 : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderBufferInt64Atomics",
            "shaderSharedInt64Atomics",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderBufferInt64Atomics") return features.shaderBufferInt64Atomics == VK_TRUE;
        if (name == "shaderSharedInt64Atomics") return features.shaderSharedInt64Atomics == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderBufferInt64Atomics") { features.shaderBufferInt64Atomics = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderSharedInt64Atomics") { features.shaderSharedInt64Atomics = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderAtomicInt64Features";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderAtomicInt64Features;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderAtomicInt64Features& get() { return features; }
    const vk::PhysicalDeviceShaderAtomicInt64Features& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderAtomicInt64Features features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderBfloat16KHR
// Wraps: vk::PhysicalDeviceShaderBfloat16FeaturesKHR
// Extension: VK_KHR_SHADER_BFLOAT16_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderBfloat16KHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_SHADER_BFLOAT16_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderBFloat16Type",
            "shaderBFloat16DotProduct",
            "shaderBFloat16CooperativeMatrix",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderBFloat16Type") return features.shaderBFloat16Type == VK_TRUE;
        if (name == "shaderBFloat16DotProduct") return features.shaderBFloat16DotProduct == VK_TRUE;
        if (name == "shaderBFloat16CooperativeMatrix") return features.shaderBFloat16CooperativeMatrix == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderBFloat16Type") { features.shaderBFloat16Type = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderBFloat16DotProduct") { features.shaderBFloat16DotProduct = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderBFloat16CooperativeMatrix") { features.shaderBFloat16CooperativeMatrix = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderBfloat16FeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderBfloat16FeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderBfloat16FeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceShaderBfloat16FeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderBfloat16FeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderClockKHR
// Wraps: vk::PhysicalDeviceShaderClockFeaturesKHR
// Extension: VK_KHR_SHADER_CLOCK_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderClockKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_SHADER_CLOCK_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderSubgroupClock",
            "shaderDeviceClock",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderSubgroupClock") return features.shaderSubgroupClock == VK_TRUE;
        if (name == "shaderDeviceClock") return features.shaderDeviceClock == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderSubgroupClock") { features.shaderSubgroupClock = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderDeviceClock") { features.shaderDeviceClock = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderClockFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderClockFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderClockFeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceShaderClockFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderClockFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderCoreBuiltinsARM
// Wraps: vk::PhysicalDeviceShaderCoreBuiltinsFeaturesARM
// Extension: VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderCoreBuiltinsARM : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderCoreBuiltins",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderCoreBuiltins") return features.shaderCoreBuiltins == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderCoreBuiltins") { features.shaderCoreBuiltins = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderCoreBuiltinsFeaturesARM";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderCoreBuiltinsFeaturesARM;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderCoreBuiltinsFeaturesARM& get() { return features; }
    const vk::PhysicalDeviceShaderCoreBuiltinsFeaturesARM& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderCoreBuiltinsFeaturesARM features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderDemoteToHelperInvocation
// Wraps: vk::PhysicalDeviceShaderDemoteToHelperInvocationFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderDemoteToHelperInvocation : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderDemoteToHelperInvocation",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderDemoteToHelperInvocation") return features.shaderDemoteToHelperInvocation == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderDemoteToHelperInvocation") { features.shaderDemoteToHelperInvocation = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderDemoteToHelperInvocationFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderDemoteToHelperInvocationFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderDemoteToHelperInvocationFeatures& get() { return features; }
    const vk::PhysicalDeviceShaderDemoteToHelperInvocationFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderDemoteToHelperInvocationFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderDrawParameters
// Wraps: vk::PhysicalDeviceShaderDrawParametersFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderDrawParameters : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderDrawParameters",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderDrawParameters") return features.shaderDrawParameters == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderDrawParameters") { features.shaderDrawParameters = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderDrawParametersFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderDrawParametersFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderDrawParametersFeatures& get() { return features; }
    const vk::PhysicalDeviceShaderDrawParametersFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderDrawParametersFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderEarlyAndLateFragmentTestsAMD
// Wraps: vk::PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD
// Extension: VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderEarlyAndLateFragmentTestsAMD : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderEarlyAndLateFragmentTests",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderEarlyAndLateFragmentTests") return features.shaderEarlyAndLateFragmentTests == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderEarlyAndLateFragmentTests") { features.shaderEarlyAndLateFragmentTests = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD& get() { return features; }
    const vk::PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderExpectAssume
// Wraps: vk::PhysicalDeviceShaderExpectAssumeFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderExpectAssume : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderExpectAssume",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderExpectAssume") return features.shaderExpectAssume == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderExpectAssume") { features.shaderExpectAssume = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderExpectAssumeFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderExpectAssumeFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderExpectAssumeFeatures& get() { return features; }
    const vk::PhysicalDeviceShaderExpectAssumeFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderExpectAssumeFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderFloat16Int8
// Wraps: vk::PhysicalDeviceShaderFloat16Int8Features
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderFloat16Int8 : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderFloat16",
            "shaderInt8",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderFloat16") return features.shaderFloat16 == VK_TRUE;
        if (name == "shaderInt8") return features.shaderInt8 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderFloat16") { features.shaderFloat16 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderInt8") { features.shaderInt8 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderFloat16Int8Features";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderFloat16Int8Features;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderFloat16Int8Features& get() { return features; }
    const vk::PhysicalDeviceShaderFloat16Int8Features& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderFloat16Int8Features features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderFloat8EXT
// Wraps: vk::PhysicalDeviceShaderFloat8FeaturesEXT
// Extension: VK_EXT_SHADER_FLOAT8_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderFloat8EXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_SHADER_FLOAT8_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderFloat8",
            "shaderFloat8CooperativeMatrix",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderFloat8") return features.shaderFloat8 == VK_TRUE;
        if (name == "shaderFloat8CooperativeMatrix") return features.shaderFloat8CooperativeMatrix == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderFloat8") { features.shaderFloat8 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderFloat8CooperativeMatrix") { features.shaderFloat8CooperativeMatrix = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderFloat8FeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderFloat8FeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderFloat8FeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceShaderFloat8FeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderFloat8FeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderFloatControls2
// Wraps: vk::PhysicalDeviceShaderFloatControls2Features
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderFloatControls2 : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderFloatControls2",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderFloatControls2") return features.shaderFloatControls2 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderFloatControls2") { features.shaderFloatControls2 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderFloatControls2Features";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderFloatControls2Features;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderFloatControls2Features& get() { return features; }
    const vk::PhysicalDeviceShaderFloatControls2Features& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderFloatControls2Features features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderFmaKHR
// Wraps: vk::PhysicalDeviceShaderFmaFeaturesKHR
// Extension: VK_KHR_SHADER_FMA_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderFmaKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_SHADER_FMA_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderFmaFloat16",
            "shaderFmaFloat32",
            "shaderFmaFloat64",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderFmaFloat16") return features.shaderFmaFloat16 == VK_TRUE;
        if (name == "shaderFmaFloat32") return features.shaderFmaFloat32 == VK_TRUE;
        if (name == "shaderFmaFloat64") return features.shaderFmaFloat64 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderFmaFloat16") { features.shaderFmaFloat16 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderFmaFloat32") { features.shaderFmaFloat32 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderFmaFloat64") { features.shaderFmaFloat64 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderFmaFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderFmaFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderFmaFeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceShaderFmaFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderFmaFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderImageAtomicInt64EXT
// Wraps: vk::PhysicalDeviceShaderImageAtomicInt64FeaturesEXT
// Extension: VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderImageAtomicInt64EXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderImageInt64Atomics",
            "sparseImageInt64Atomics",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderImageInt64Atomics") return features.shaderImageInt64Atomics == VK_TRUE;
        if (name == "sparseImageInt64Atomics") return features.sparseImageInt64Atomics == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderImageInt64Atomics") { features.shaderImageInt64Atomics = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "sparseImageInt64Atomics") { features.sparseImageInt64Atomics = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderImageAtomicInt64FeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderImageAtomicInt64FeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderImageAtomicInt64FeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceShaderImageAtomicInt64FeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderImageAtomicInt64FeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderImageFootprintNV
// Wraps: vk::PhysicalDeviceShaderImageFootprintFeaturesNV
// Extension: VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderImageFootprintNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "imageFootprint",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "imageFootprint") return features.imageFootprint == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "imageFootprint") { features.imageFootprint = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderImageFootprintFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderImageFootprintFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderImageFootprintFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceShaderImageFootprintFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderImageFootprintFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderIntegerDotProduct
// Wraps: vk::PhysicalDeviceShaderIntegerDotProductFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderIntegerDotProduct : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderIntegerDotProduct",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderIntegerDotProduct") return features.shaderIntegerDotProduct == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderIntegerDotProduct") { features.shaderIntegerDotProduct = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderIntegerDotProductFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderIntegerDotProductFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderIntegerDotProductFeatures& get() { return features; }
    const vk::PhysicalDeviceShaderIntegerDotProductFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderIntegerDotProductFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderIntegerFunctions2INTEL
// Wraps: vk::PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL
// Extension: VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderIntegerFunctions2INTEL : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderIntegerFunctions2",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderIntegerFunctions2") return features.shaderIntegerFunctions2 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderIntegerFunctions2") { features.shaderIntegerFunctions2 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderIntegerFunctions2FeaturesINTEL;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL& get() { return features; }
    const vk::PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderLongVectorEXT
// Wraps: vk::PhysicalDeviceShaderLongVectorFeaturesEXT
// Extension: VK_EXT_SHADER_LONG_VECTOR_EXTENSION_NAME
// Core in: VK_API_VERSION_1_2
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderLongVectorEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_2) {
            return {};
        }
        return {VK_EXT_SHADER_LONG_VECTOR_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "longVector",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "longVector") return features.longVector == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "longVector") { features.longVector = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderLongVectorFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderLongVectorFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderLongVectorFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceShaderLongVectorFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderLongVectorFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderMaximalReconvergenceKHR
// Wraps: vk::PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR
// Extension: VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderMaximalReconvergenceKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderMaximalReconvergence",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderMaximalReconvergence") return features.shaderMaximalReconvergence == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderMaximalReconvergence") { features.shaderMaximalReconvergence = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderMaximalReconvergenceFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderModuleIdentifierEXT
// Wraps: vk::PhysicalDeviceShaderModuleIdentifierFeaturesEXT
// Extension: VK_EXT_SHADER_MODULE_IDENTIFIER_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderModuleIdentifierEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_SHADER_MODULE_IDENTIFIER_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderModuleIdentifier",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderModuleIdentifier") return features.shaderModuleIdentifier == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderModuleIdentifier") { features.shaderModuleIdentifier = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderModuleIdentifierFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderModuleIdentifierFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderModuleIdentifierFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceShaderModuleIdentifierFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderModuleIdentifierFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderObjectEXT
// Wraps: vk::PhysicalDeviceShaderObjectFeaturesEXT
// Extension: VK_EXT_SHADER_OBJECT_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderObjectEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_SHADER_OBJECT_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderObject",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderObject") return features.shaderObject == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderObject") { features.shaderObject = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderObjectFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderObjectFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderObjectFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceShaderObjectFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderObjectFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderQuadControlKHR
// Wraps: vk::PhysicalDeviceShaderQuadControlFeaturesKHR
// Extension: VK_KHR_SHADER_QUAD_CONTROL_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderQuadControlKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_SHADER_QUAD_CONTROL_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderQuadControl",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderQuadControl") return features.shaderQuadControl == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderQuadControl") { features.shaderQuadControl = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderQuadControlFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderQuadControlFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderQuadControlFeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceShaderQuadControlFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderQuadControlFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderRelaxedExtendedInstructionKHR
// Wraps: vk::PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR
// Extension: VK_KHR_SHADER_RELAXED_EXTENDED_INSTRUCTION_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderRelaxedExtendedInstructionKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_SHADER_RELAXED_EXTENDED_INSTRUCTION_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderRelaxedExtendedInstruction",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderRelaxedExtendedInstruction") return features.shaderRelaxedExtendedInstruction == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderRelaxedExtendedInstruction") { features.shaderRelaxedExtendedInstruction = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderReplicatedCompositesEXT
// Wraps: vk::PhysicalDeviceShaderReplicatedCompositesFeaturesEXT
// Extension: VK_EXT_SHADER_REPLICATED_COMPOSITES_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderReplicatedCompositesEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_SHADER_REPLICATED_COMPOSITES_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderReplicatedComposites",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderReplicatedComposites") return features.shaderReplicatedComposites == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderReplicatedComposites") { features.shaderReplicatedComposites = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderReplicatedCompositesFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderReplicatedCompositesFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderReplicatedCompositesFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceShaderReplicatedCompositesFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderReplicatedCompositesFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderSMBuiltinsNV
// Wraps: vk::PhysicalDeviceShaderSMBuiltinsFeaturesNV
// Extension: VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderSMBuiltinsNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderSMBuiltins",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderSMBuiltins") return features.shaderSMBuiltins == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderSMBuiltins") { features.shaderSMBuiltins = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderSMBuiltinsFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderSmBuiltinsFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderSMBuiltinsFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceShaderSMBuiltinsFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderSMBuiltinsFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderSubgroupExtendedTypes
// Wraps: vk::PhysicalDeviceShaderSubgroupExtendedTypesFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderSubgroupExtendedTypes : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderSubgroupExtendedTypes",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderSubgroupExtendedTypes") return features.shaderSubgroupExtendedTypes == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderSubgroupExtendedTypes") { features.shaderSubgroupExtendedTypes = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderSubgroupExtendedTypesFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderSubgroupExtendedTypesFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderSubgroupExtendedTypesFeatures& get() { return features; }
    const vk::PhysicalDeviceShaderSubgroupExtendedTypesFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderSubgroupExtendedTypesFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderSubgroupRotate
// Wraps: vk::PhysicalDeviceShaderSubgroupRotateFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderSubgroupRotate : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderSubgroupRotate",
            "shaderSubgroupRotateClustered",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderSubgroupRotate") return features.shaderSubgroupRotate == VK_TRUE;
        if (name == "shaderSubgroupRotateClustered") return features.shaderSubgroupRotateClustered == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderSubgroupRotate") { features.shaderSubgroupRotate = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderSubgroupRotateClustered") { features.shaderSubgroupRotateClustered = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderSubgroupRotateFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderSubgroupRotateFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderSubgroupRotateFeatures& get() { return features; }
    const vk::PhysicalDeviceShaderSubgroupRotateFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderSubgroupRotateFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderSubgroupUniformControlFlowKHR
// Wraps: vk::PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR
// Extension: VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderSubgroupUniformControlFlowKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderSubgroupUniformControlFlow",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderSubgroupUniformControlFlow") return features.shaderSubgroupUniformControlFlow == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderSubgroupUniformControlFlow") { features.shaderSubgroupUniformControlFlow = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderTerminateInvocation
// Wraps: vk::PhysicalDeviceShaderTerminateInvocationFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderTerminateInvocation : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderTerminateInvocation",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderTerminateInvocation") return features.shaderTerminateInvocation == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderTerminateInvocation") { features.shaderTerminateInvocation = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderTerminateInvocationFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderTerminateInvocationFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderTerminateInvocationFeatures& get() { return features; }
    const vk::PhysicalDeviceShaderTerminateInvocationFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderTerminateInvocationFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderTileImageEXT
// Wraps: vk::PhysicalDeviceShaderTileImageFeaturesEXT
// Extension: VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME
// Core in: VK_API_VERSION_1_3
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderTileImageEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_3) {
            return {};
        }
        return {VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderTileImageColorReadAccess",
            "shaderTileImageDepthReadAccess",
            "shaderTileImageStencilReadAccess",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderTileImageColorReadAccess") return features.shaderTileImageColorReadAccess == VK_TRUE;
        if (name == "shaderTileImageDepthReadAccess") return features.shaderTileImageDepthReadAccess == VK_TRUE;
        if (name == "shaderTileImageStencilReadAccess") return features.shaderTileImageStencilReadAccess == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderTileImageColorReadAccess") { features.shaderTileImageColorReadAccess = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderTileImageDepthReadAccess") { features.shaderTileImageDepthReadAccess = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderTileImageStencilReadAccess") { features.shaderTileImageStencilReadAccess = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderTileImageFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderTileImageFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderTileImageFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceShaderTileImageFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderTileImageFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderUniformBufferUnsizedArrayEXT
// Wraps: vk::PhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT
// Extension: VK_EXT_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderUniformBufferUnsizedArrayEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderUniformBufferUnsizedArray",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderUniformBufferUnsizedArray") return features.shaderUniformBufferUnsizedArray == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderUniformBufferUnsizedArray") { features.shaderUniformBufferUnsizedArray = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShaderUntypedPointersKHR
// Wraps: vk::PhysicalDeviceShaderUntypedPointersFeaturesKHR
// Extension: VK_KHR_SHADER_UNTYPED_POINTERS_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShaderUntypedPointersKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_KHR_SHADER_UNTYPED_POINTERS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderUntypedPointers",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderUntypedPointers") return features.shaderUntypedPointers == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderUntypedPointers") { features.shaderUntypedPointers = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShaderUntypedPointersFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShaderUntypedPointersFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShaderUntypedPointersFeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceShaderUntypedPointersFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceShaderUntypedPointersFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceShadingRateImageNV
// Wraps: vk::PhysicalDeviceShadingRateImageFeaturesNV
// Extension: VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceShadingRateImageNV : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shadingRateImage",
            "shadingRateCoarseSampleOrder",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shadingRateImage") return features.shadingRateImage == VK_TRUE;
        if (name == "shadingRateCoarseSampleOrder") return features.shadingRateCoarseSampleOrder == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shadingRateImage") { features.shadingRateImage = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shadingRateCoarseSampleOrder") { features.shadingRateCoarseSampleOrder = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceShadingRateImageFeaturesNV";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceShadingRateImageFeaturesNV;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceShadingRateImageFeaturesNV& get() { return features; }
    const vk::PhysicalDeviceShadingRateImageFeaturesNV& get() const { return features; }

  private:
    vk::PhysicalDeviceShadingRateImageFeaturesNV features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceSubgroupSizeControl
// Wraps: vk::PhysicalDeviceSubgroupSizeControlFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceSubgroupSizeControl : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "subgroupSizeControl",
            "computeFullSubgroups",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "subgroupSizeControl") return features.subgroupSizeControl == VK_TRUE;
        if (name == "computeFullSubgroups") return features.computeFullSubgroups == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "subgroupSizeControl") { features.subgroupSizeControl = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "computeFullSubgroups") { features.computeFullSubgroups = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceSubgroupSizeControlFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceSubgroupSizeControlFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceSubgroupSizeControlFeatures& get() { return features; }
    const vk::PhysicalDeviceSubgroupSizeControlFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceSubgroupSizeControlFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceSubpassMergeFeedbackEXT
// Wraps: vk::PhysicalDeviceSubpassMergeFeedbackFeaturesEXT
// Extension: VK_EXT_SUBPASS_MERGE_FEEDBACK_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceSubpassMergeFeedbackEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_SUBPASS_MERGE_FEEDBACK_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "subpassMergeFeedback",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "subpassMergeFeedback") return features.subpassMergeFeedback == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "subpassMergeFeedback") { features.subpassMergeFeedback = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceSubpassMergeFeedbackFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceSubpassMergeFeedbackFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceSubpassMergeFeedbackFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceSubpassMergeFeedbackFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceSubpassMergeFeedbackFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceSubpassShadingHUAWEI
// Wraps: vk::PhysicalDeviceSubpassShadingFeaturesHUAWEI
// Extension: VK_HUAWEI_SUBPASS_SHADING_EXTENSION_NAME
// Core in: VK_API_VERSION_1_2
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceSubpassShadingHUAWEI : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_2) {
            return {};
        }
        return {VK_HUAWEI_SUBPASS_SHADING_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "subpassShading",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "subpassShading") return features.subpassShading == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "subpassShading") { features.subpassShading = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceSubpassShadingFeaturesHUAWEI";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceSubpassShadingFeaturesHUAWEI;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceSubpassShadingFeaturesHUAWEI& get() { return features; }
    const vk::PhysicalDeviceSubpassShadingFeaturesHUAWEI& get() const { return features; }

  private:
    vk::PhysicalDeviceSubpassShadingFeaturesHUAWEI features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceSwapchainMaintenance1KHR
// Wraps: vk::PhysicalDeviceSwapchainMaintenance1FeaturesKHR
// Extension: VK_KHR_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceSwapchainMaintenance1KHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_KHR_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "swapchainMaintenance1",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "swapchainMaintenance1") return features.swapchainMaintenance1 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "swapchainMaintenance1") { features.swapchainMaintenance1 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceSwapchainMaintenance1FeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceSwapchainMaintenance1FeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceSwapchainMaintenance1FeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceSwapchainMaintenance1FeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceSwapchainMaintenance1FeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceSynchronization2
// Wraps: vk::PhysicalDeviceSynchronization2Features
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceSynchronization2 : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "synchronization2",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "synchronization2") return features.synchronization2 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "synchronization2") { features.synchronization2 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceSynchronization2Features";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceSynchronization2Features;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceSynchronization2Features& get() { return features; }
    const vk::PhysicalDeviceSynchronization2Features& get() const { return features; }

  private:
    vk::PhysicalDeviceSynchronization2Features features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceTensorARM
// Wraps: vk::PhysicalDeviceTensorFeaturesARM
// Extension: VK_ARM_TENSORS_EXTENSION_NAME
// Core in: VK_API_VERSION_1_3
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceTensorARM : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_3) {
            return {};
        }
        return {VK_ARM_TENSORS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "tensorNonPacked",
            "shaderTensorAccess",
            "shaderStorageTensorArrayDynamicIndexing",
            "shaderStorageTensorArrayNonUniformIndexing",
            "descriptorBindingStorageTensorUpdateAfterBind",
            "tensors",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "tensorNonPacked") return features.tensorNonPacked == VK_TRUE;
        if (name == "shaderTensorAccess") return features.shaderTensorAccess == VK_TRUE;
        if (name == "shaderStorageTensorArrayDynamicIndexing") return features.shaderStorageTensorArrayDynamicIndexing == VK_TRUE;
        if (name == "shaderStorageTensorArrayNonUniformIndexing") return features.shaderStorageTensorArrayNonUniformIndexing == VK_TRUE;
        if (name == "descriptorBindingStorageTensorUpdateAfterBind") return features.descriptorBindingStorageTensorUpdateAfterBind == VK_TRUE;
        if (name == "tensors") return features.tensors == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "tensorNonPacked") { features.tensorNonPacked = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderTensorAccess") { features.shaderTensorAccess = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderStorageTensorArrayDynamicIndexing") { features.shaderStorageTensorArrayDynamicIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderStorageTensorArrayNonUniformIndexing") { features.shaderStorageTensorArrayNonUniformIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBindingStorageTensorUpdateAfterBind") { features.descriptorBindingStorageTensorUpdateAfterBind = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "tensors") { features.tensors = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceTensorFeaturesARM";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceTensorFeaturesARM;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceTensorFeaturesARM& get() { return features; }
    const vk::PhysicalDeviceTensorFeaturesARM& get() const { return features; }

  private:
    vk::PhysicalDeviceTensorFeaturesARM features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceTexelBufferAlignmentEXT
// Wraps: vk::PhysicalDeviceTexelBufferAlignmentFeaturesEXT
// Extension: VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceTexelBufferAlignmentEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "texelBufferAlignment",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "texelBufferAlignment") return features.texelBufferAlignment == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "texelBufferAlignment") { features.texelBufferAlignment = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceTexelBufferAlignmentFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceTexelBufferAlignmentFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceTexelBufferAlignmentFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceTexelBufferAlignmentFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceTexelBufferAlignmentFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceTextureCompressionASTC3DEXT
// Wraps: vk::PhysicalDeviceTextureCompressionASTC3DFeaturesEXT
// Extension: VK_EXT_TEXTURE_COMPRESSION_ASTC_3D_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceTextureCompressionASTC3DEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_TEXTURE_COMPRESSION_ASTC_3D_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "textureCompressionASTC_3D",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "textureCompressionASTC_3D") return features.textureCompressionASTC_3D == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "textureCompressionASTC_3D") { features.textureCompressionASTC_3D = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceTextureCompressionASTC3DFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceTextureCompressionAstc3DFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceTextureCompressionASTC3DFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceTextureCompressionASTC3DFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceTextureCompressionASTC3DFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceTextureCompressionASTCHDR
// Wraps: vk::PhysicalDeviceTextureCompressionASTCHDRFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceTextureCompressionASTCHDR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "textureCompressionASTC_HDR",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "textureCompressionASTC_HDR") return features.textureCompressionASTC_HDR == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "textureCompressionASTC_HDR") { features.textureCompressionASTC_HDR = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceTextureCompressionASTCHDRFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceTextureCompressionAstcHdrFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceTextureCompressionASTCHDRFeatures& get() { return features; }
    const vk::PhysicalDeviceTextureCompressionASTCHDRFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceTextureCompressionASTCHDRFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceTileMemoryHeapQCOM
// Wraps: vk::PhysicalDeviceTileMemoryHeapFeaturesQCOM
// Extension: VK_QCOM_TILE_MEMORY_HEAP_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceTileMemoryHeapQCOM : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_QCOM_TILE_MEMORY_HEAP_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "tileMemoryHeap",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "tileMemoryHeap") return features.tileMemoryHeap == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "tileMemoryHeap") { features.tileMemoryHeap = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceTileMemoryHeapFeaturesQCOM";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceTileMemoryHeapFeaturesQCOM;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceTileMemoryHeapFeaturesQCOM& get() { return features; }
    const vk::PhysicalDeviceTileMemoryHeapFeaturesQCOM& get() const { return features; }

  private:
    vk::PhysicalDeviceTileMemoryHeapFeaturesQCOM features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceTilePropertiesQCOM
// Wraps: vk::PhysicalDeviceTilePropertiesFeaturesQCOM
// Extension: VK_QCOM_TILE_PROPERTIES_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceTilePropertiesQCOM : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_QCOM_TILE_PROPERTIES_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "tileProperties",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "tileProperties") return features.tileProperties == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "tileProperties") { features.tileProperties = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceTilePropertiesFeaturesQCOM";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceTilePropertiesFeaturesQCOM;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceTilePropertiesFeaturesQCOM& get() { return features; }
    const vk::PhysicalDeviceTilePropertiesFeaturesQCOM& get() const { return features; }

  private:
    vk::PhysicalDeviceTilePropertiesFeaturesQCOM features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceTileShadingQCOM
// Wraps: vk::PhysicalDeviceTileShadingFeaturesQCOM
// Extension: VK_QCOM_TILE_SHADING_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceTileShadingQCOM : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_QCOM_TILE_SHADING_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "tileShading",
            "tileShadingFragmentStage",
            "tileShadingColorAttachments",
            "tileShadingDepthAttachments",
            "tileShadingStencilAttachments",
            "tileShadingInputAttachments",
            "tileShadingSampledAttachments",
            "tileShadingPerTileDraw",
            "tileShadingPerTileDispatch",
            "tileShadingDispatchTile",
            "tileShadingApron",
            "tileShadingAnisotropicApron",
            "tileShadingAtomicOps",
            "tileShadingImageProcessing",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "tileShading") return features.tileShading == VK_TRUE;
        if (name == "tileShadingFragmentStage") return features.tileShadingFragmentStage == VK_TRUE;
        if (name == "tileShadingColorAttachments") return features.tileShadingColorAttachments == VK_TRUE;
        if (name == "tileShadingDepthAttachments") return features.tileShadingDepthAttachments == VK_TRUE;
        if (name == "tileShadingStencilAttachments") return features.tileShadingStencilAttachments == VK_TRUE;
        if (name == "tileShadingInputAttachments") return features.tileShadingInputAttachments == VK_TRUE;
        if (name == "tileShadingSampledAttachments") return features.tileShadingSampledAttachments == VK_TRUE;
        if (name == "tileShadingPerTileDraw") return features.tileShadingPerTileDraw == VK_TRUE;
        if (name == "tileShadingPerTileDispatch") return features.tileShadingPerTileDispatch == VK_TRUE;
        if (name == "tileShadingDispatchTile") return features.tileShadingDispatchTile == VK_TRUE;
        if (name == "tileShadingApron") return features.tileShadingApron == VK_TRUE;
        if (name == "tileShadingAnisotropicApron") return features.tileShadingAnisotropicApron == VK_TRUE;
        if (name == "tileShadingAtomicOps") return features.tileShadingAtomicOps == VK_TRUE;
        if (name == "tileShadingImageProcessing") return features.tileShadingImageProcessing == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "tileShading") { features.tileShading = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "tileShadingFragmentStage") { features.tileShadingFragmentStage = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "tileShadingColorAttachments") { features.tileShadingColorAttachments = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "tileShadingDepthAttachments") { features.tileShadingDepthAttachments = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "tileShadingStencilAttachments") { features.tileShadingStencilAttachments = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "tileShadingInputAttachments") { features.tileShadingInputAttachments = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "tileShadingSampledAttachments") { features.tileShadingSampledAttachments = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "tileShadingPerTileDraw") { features.tileShadingPerTileDraw = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "tileShadingPerTileDispatch") { features.tileShadingPerTileDispatch = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "tileShadingDispatchTile") { features.tileShadingDispatchTile = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "tileShadingApron") { features.tileShadingApron = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "tileShadingAnisotropicApron") { features.tileShadingAnisotropicApron = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "tileShadingAtomicOps") { features.tileShadingAtomicOps = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "tileShadingImageProcessing") { features.tileShadingImageProcessing = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceTileShadingFeaturesQCOM";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceTileShadingFeaturesQCOM;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceTileShadingFeaturesQCOM& get() { return features; }
    const vk::PhysicalDeviceTileShadingFeaturesQCOM& get() const { return features; }

  private:
    vk::PhysicalDeviceTileShadingFeaturesQCOM features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceTimelineSemaphore
// Wraps: vk::PhysicalDeviceTimelineSemaphoreFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceTimelineSemaphore : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "timelineSemaphore",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "timelineSemaphore") return features.timelineSemaphore == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "timelineSemaphore") { features.timelineSemaphore = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceTimelineSemaphoreFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceTimelineSemaphoreFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceTimelineSemaphoreFeatures& get() { return features; }
    const vk::PhysicalDeviceTimelineSemaphoreFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceTimelineSemaphoreFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceTransformFeedbackEXT
// Wraps: vk::PhysicalDeviceTransformFeedbackFeaturesEXT
// Extension: VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceTransformFeedbackEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "transformFeedback",
            "geometryStreams",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "transformFeedback") return features.transformFeedback == VK_TRUE;
        if (name == "geometryStreams") return features.geometryStreams == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "transformFeedback") { features.transformFeedback = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "geometryStreams") { features.geometryStreams = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceTransformFeedbackFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceTransformFeedbackFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceTransformFeedbackFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceTransformFeedbackFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceTransformFeedbackFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceUnifiedImageLayoutsKHR
// Wraps: vk::PhysicalDeviceUnifiedImageLayoutsFeaturesKHR
// Extension: VK_KHR_UNIFIED_IMAGE_LAYOUTS_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceUnifiedImageLayoutsKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_UNIFIED_IMAGE_LAYOUTS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "unifiedImageLayouts",
            "unifiedImageLayoutsVideo",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "unifiedImageLayouts") return features.unifiedImageLayouts == VK_TRUE;
        if (name == "unifiedImageLayoutsVideo") return features.unifiedImageLayoutsVideo == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "unifiedImageLayouts") { features.unifiedImageLayouts = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "unifiedImageLayoutsVideo") { features.unifiedImageLayoutsVideo = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceUnifiedImageLayoutsFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceUnifiedImageLayoutsFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceUnifiedImageLayoutsFeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceUnifiedImageLayoutsFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceUnifiedImageLayoutsFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceUniformBufferStandardLayout
// Wraps: vk::PhysicalDeviceUniformBufferStandardLayoutFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceUniformBufferStandardLayout : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "uniformBufferStandardLayout",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "uniformBufferStandardLayout") return features.uniformBufferStandardLayout == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "uniformBufferStandardLayout") { features.uniformBufferStandardLayout = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceUniformBufferStandardLayoutFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceUniformBufferStandardLayoutFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceUniformBufferStandardLayoutFeatures& get() { return features; }
    const vk::PhysicalDeviceUniformBufferStandardLayoutFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceUniformBufferStandardLayoutFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceVariablePointers
// Wraps: vk::PhysicalDeviceVariablePointersFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceVariablePointers : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "variablePointersStorageBuffer",
            "variablePointers",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "variablePointersStorageBuffer") return features.variablePointersStorageBuffer == VK_TRUE;
        if (name == "variablePointers") return features.variablePointers == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "variablePointersStorageBuffer") { features.variablePointersStorageBuffer = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "variablePointers") { features.variablePointers = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceVariablePointersFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceVariablePointersFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceVariablePointersFeatures& get() { return features; }
    const vk::PhysicalDeviceVariablePointersFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceVariablePointersFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceVertexAttributeDivisor
// Wraps: vk::PhysicalDeviceVertexAttributeDivisorFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceVertexAttributeDivisor : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "vertexAttributeInstanceRateDivisor",
            "vertexAttributeInstanceRateZeroDivisor",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "vertexAttributeInstanceRateDivisor") return features.vertexAttributeInstanceRateDivisor == VK_TRUE;
        if (name == "vertexAttributeInstanceRateZeroDivisor") return features.vertexAttributeInstanceRateZeroDivisor == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "vertexAttributeInstanceRateDivisor") { features.vertexAttributeInstanceRateDivisor = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "vertexAttributeInstanceRateZeroDivisor") { features.vertexAttributeInstanceRateZeroDivisor = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceVertexAttributeDivisorFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceVertexAttributeDivisorFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceVertexAttributeDivisorFeatures& get() { return features; }
    const vk::PhysicalDeviceVertexAttributeDivisorFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceVertexAttributeDivisorFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceVertexAttributeRobustnessEXT
// Wraps: vk::PhysicalDeviceVertexAttributeRobustnessFeaturesEXT
// Extension: VK_EXT_VERTEX_ATTRIBUTE_ROBUSTNESS_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceVertexAttributeRobustnessEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_VERTEX_ATTRIBUTE_ROBUSTNESS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "vertexAttributeRobustness",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "vertexAttributeRobustness") return features.vertexAttributeRobustness == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "vertexAttributeRobustness") { features.vertexAttributeRobustness = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceVertexAttributeRobustnessFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceVertexAttributeRobustnessFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceVertexAttributeRobustnessFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceVertexAttributeRobustnessFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceVertexAttributeRobustnessFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceVertexInputDynamicStateEXT
// Wraps: vk::PhysicalDeviceVertexInputDynamicStateFeaturesEXT
// Extension: VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceVertexInputDynamicStateEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "vertexInputDynamicState",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "vertexInputDynamicState") return features.vertexInputDynamicState == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "vertexInputDynamicState") { features.vertexInputDynamicState = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceVertexInputDynamicStateFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceVertexInputDynamicStateFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceVertexInputDynamicStateFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceVertexInputDynamicStateFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceVertexInputDynamicStateFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceVideoDecodeVP9KHR
// Wraps: vk::PhysicalDeviceVideoDecodeVP9FeaturesKHR
// Extension: VK_KHR_VIDEO_DECODE_VP9_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceVideoDecodeVP9KHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_KHR_VIDEO_DECODE_VP9_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "videoDecodeVP9",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "videoDecodeVP9") return features.videoDecodeVP9 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "videoDecodeVP9") { features.videoDecodeVP9 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceVideoDecodeVP9FeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceVideoDecodeVp9FeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceVideoDecodeVP9FeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceVideoDecodeVP9FeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceVideoDecodeVP9FeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceVideoEncodeAV1KHR
// Wraps: vk::PhysicalDeviceVideoEncodeAV1FeaturesKHR
// Extension: VK_KHR_VIDEO_ENCODE_AV1_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceVideoEncodeAV1KHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_KHR_VIDEO_ENCODE_AV1_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "videoEncodeAV1",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "videoEncodeAV1") return features.videoEncodeAV1 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "videoEncodeAV1") { features.videoEncodeAV1 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceVideoEncodeAV1FeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceVideoEncodeAv1FeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceVideoEncodeAV1FeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceVideoEncodeAV1FeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceVideoEncodeAV1FeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceVideoEncodeIntraRefreshKHR
// Wraps: vk::PhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR
// Extension: VK_KHR_VIDEO_ENCODE_INTRA_REFRESH_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceVideoEncodeIntraRefreshKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_KHR_VIDEO_ENCODE_INTRA_REFRESH_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "videoEncodeIntraRefresh",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "videoEncodeIntraRefresh") return features.videoEncodeIntraRefresh == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "videoEncodeIntraRefresh") { features.videoEncodeIntraRefresh = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceVideoEncodeQuantizationMapKHR
// Wraps: vk::PhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR
// Extension: VK_KHR_VIDEO_ENCODE_QUANTIZATION_MAP_EXTENSION_NAME
// Core in: VK_API_VERSION_1_3
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceVideoEncodeQuantizationMapKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_3) {
            return {};
        }
        return {VK_KHR_VIDEO_ENCODE_QUANTIZATION_MAP_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "videoEncodeQuantizationMap",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "videoEncodeQuantizationMap") return features.videoEncodeQuantizationMap == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "videoEncodeQuantizationMap") { features.videoEncodeQuantizationMap = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceVideoEncodeRgbConversionVALVE
// Wraps: vk::PhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE
// Extension: VK_VALVE_VIDEO_ENCODE_RGB_CONVERSION_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceVideoEncodeRgbConversionVALVE : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_VALVE_VIDEO_ENCODE_RGB_CONVERSION_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "videoEncodeRgbConversion",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "videoEncodeRgbConversion") return features.videoEncodeRgbConversion == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "videoEncodeRgbConversion") { features.videoEncodeRgbConversion = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE& get() { return features; }
    const vk::PhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE& get() const { return features; }

  private:
    vk::PhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceVideoMaintenance1KHR
// Wraps: vk::PhysicalDeviceVideoMaintenance1FeaturesKHR
// Extension: VK_KHR_VIDEO_MAINTENANCE_1_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceVideoMaintenance1KHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_KHR_VIDEO_MAINTENANCE_1_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "videoMaintenance1",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "videoMaintenance1") return features.videoMaintenance1 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "videoMaintenance1") { features.videoMaintenance1 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceVideoMaintenance1FeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceVideoMaintenance1FeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceVideoMaintenance1FeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceVideoMaintenance1FeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceVideoMaintenance1FeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceVideoMaintenance2KHR
// Wraps: vk::PhysicalDeviceVideoMaintenance2FeaturesKHR
// Extension: VK_KHR_VIDEO_MAINTENANCE_2_EXTENSION_NAME
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceVideoMaintenance2KHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {VK_KHR_VIDEO_MAINTENANCE_2_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "videoMaintenance2",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "videoMaintenance2") return features.videoMaintenance2 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "videoMaintenance2") { features.videoMaintenance2 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceVideoMaintenance2FeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceVideoMaintenance2FeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceVideoMaintenance2FeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceVideoMaintenance2FeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceVideoMaintenance2FeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceVulkan11
// Wraps: vk::PhysicalDeviceVulkan11Features
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceVulkan11 : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "storageBuffer16BitAccess",
            "uniformAndStorageBuffer16BitAccess",
            "storagePushConstant16",
            "storageInputOutput16",
            "multiview",
            "multiviewGeometryShader",
            "multiviewTessellationShader",
            "variablePointersStorageBuffer",
            "variablePointers",
            "protectedMemory",
            "samplerYcbcrConversion",
            "shaderDrawParameters",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "storageBuffer16BitAccess") return features.storageBuffer16BitAccess == VK_TRUE;
        if (name == "uniformAndStorageBuffer16BitAccess") return features.uniformAndStorageBuffer16BitAccess == VK_TRUE;
        if (name == "storagePushConstant16") return features.storagePushConstant16 == VK_TRUE;
        if (name == "storageInputOutput16") return features.storageInputOutput16 == VK_TRUE;
        if (name == "multiview") return features.multiview == VK_TRUE;
        if (name == "multiviewGeometryShader") return features.multiviewGeometryShader == VK_TRUE;
        if (name == "multiviewTessellationShader") return features.multiviewTessellationShader == VK_TRUE;
        if (name == "variablePointersStorageBuffer") return features.variablePointersStorageBuffer == VK_TRUE;
        if (name == "variablePointers") return features.variablePointers == VK_TRUE;
        if (name == "protectedMemory") return features.protectedMemory == VK_TRUE;
        if (name == "samplerYcbcrConversion") return features.samplerYcbcrConversion == VK_TRUE;
        if (name == "shaderDrawParameters") return features.shaderDrawParameters == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "storageBuffer16BitAccess") { features.storageBuffer16BitAccess = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "uniformAndStorageBuffer16BitAccess") { features.uniformAndStorageBuffer16BitAccess = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "storagePushConstant16") { features.storagePushConstant16 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "storageInputOutput16") { features.storageInputOutput16 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "multiview") { features.multiview = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "multiviewGeometryShader") { features.multiviewGeometryShader = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "multiviewTessellationShader") { features.multiviewTessellationShader = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "variablePointersStorageBuffer") { features.variablePointersStorageBuffer = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "variablePointers") { features.variablePointers = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "protectedMemory") { features.protectedMemory = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "samplerYcbcrConversion") { features.samplerYcbcrConversion = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderDrawParameters") { features.shaderDrawParameters = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceVulkan11Features";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceVulkan11Features;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceVulkan11Features& get() { return features; }
    const vk::PhysicalDeviceVulkan11Features& get() const { return features; }

  private:
    vk::PhysicalDeviceVulkan11Features features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceVulkan12
// Wraps: vk::PhysicalDeviceVulkan12Features
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceVulkan12 : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "samplerMirrorClampToEdge",
            "drawIndirectCount",
            "storageBuffer8BitAccess",
            "uniformAndStorageBuffer8BitAccess",
            "storagePushConstant8",
            "shaderBufferInt64Atomics",
            "shaderSharedInt64Atomics",
            "shaderFloat16",
            "shaderInt8",
            "descriptorIndexing",
            "shaderInputAttachmentArrayDynamicIndexing",
            "shaderUniformTexelBufferArrayDynamicIndexing",
            "shaderStorageTexelBufferArrayDynamicIndexing",
            "shaderUniformBufferArrayNonUniformIndexing",
            "shaderSampledImageArrayNonUniformIndexing",
            "shaderStorageBufferArrayNonUniformIndexing",
            "shaderStorageImageArrayNonUniformIndexing",
            "shaderInputAttachmentArrayNonUniformIndexing",
            "shaderUniformTexelBufferArrayNonUniformIndexing",
            "shaderStorageTexelBufferArrayNonUniformIndexing",
            "descriptorBindingUniformBufferUpdateAfterBind",
            "descriptorBindingSampledImageUpdateAfterBind",
            "descriptorBindingStorageImageUpdateAfterBind",
            "descriptorBindingStorageBufferUpdateAfterBind",
            "descriptorBindingUniformTexelBufferUpdateAfterBind",
            "descriptorBindingStorageTexelBufferUpdateAfterBind",
            "descriptorBindingUpdateUnusedWhilePending",
            "descriptorBindingPartiallyBound",
            "descriptorBindingVariableDescriptorCount",
            "runtimeDescriptorArray",
            "samplerFilterMinmax",
            "scalarBlockLayout",
            "imagelessFramebuffer",
            "uniformBufferStandardLayout",
            "shaderSubgroupExtendedTypes",
            "separateDepthStencilLayouts",
            "hostQueryReset",
            "timelineSemaphore",
            "bufferDeviceAddress",
            "bufferDeviceAddressCaptureReplay",
            "bufferDeviceAddressMultiDevice",
            "vulkanMemoryModel",
            "vulkanMemoryModelDeviceScope",
            "vulkanMemoryModelAvailabilityVisibilityChains",
            "shaderOutputViewportIndex",
            "shaderOutputLayer",
            "subgroupBroadcastDynamicId",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "samplerMirrorClampToEdge") return features.samplerMirrorClampToEdge == VK_TRUE;
        if (name == "drawIndirectCount") return features.drawIndirectCount == VK_TRUE;
        if (name == "storageBuffer8BitAccess") return features.storageBuffer8BitAccess == VK_TRUE;
        if (name == "uniformAndStorageBuffer8BitAccess") return features.uniformAndStorageBuffer8BitAccess == VK_TRUE;
        if (name == "storagePushConstant8") return features.storagePushConstant8 == VK_TRUE;
        if (name == "shaderBufferInt64Atomics") return features.shaderBufferInt64Atomics == VK_TRUE;
        if (name == "shaderSharedInt64Atomics") return features.shaderSharedInt64Atomics == VK_TRUE;
        if (name == "shaderFloat16") return features.shaderFloat16 == VK_TRUE;
        if (name == "shaderInt8") return features.shaderInt8 == VK_TRUE;
        if (name == "descriptorIndexing") return features.descriptorIndexing == VK_TRUE;
        if (name == "shaderInputAttachmentArrayDynamicIndexing") return features.shaderInputAttachmentArrayDynamicIndexing == VK_TRUE;
        if (name == "shaderUniformTexelBufferArrayDynamicIndexing") return features.shaderUniformTexelBufferArrayDynamicIndexing == VK_TRUE;
        if (name == "shaderStorageTexelBufferArrayDynamicIndexing") return features.shaderStorageTexelBufferArrayDynamicIndexing == VK_TRUE;
        if (name == "shaderUniformBufferArrayNonUniformIndexing") return features.shaderUniformBufferArrayNonUniformIndexing == VK_TRUE;
        if (name == "shaderSampledImageArrayNonUniformIndexing") return features.shaderSampledImageArrayNonUniformIndexing == VK_TRUE;
        if (name == "shaderStorageBufferArrayNonUniformIndexing") return features.shaderStorageBufferArrayNonUniformIndexing == VK_TRUE;
        if (name == "shaderStorageImageArrayNonUniformIndexing") return features.shaderStorageImageArrayNonUniformIndexing == VK_TRUE;
        if (name == "shaderInputAttachmentArrayNonUniformIndexing") return features.shaderInputAttachmentArrayNonUniformIndexing == VK_TRUE;
        if (name == "shaderUniformTexelBufferArrayNonUniformIndexing") return features.shaderUniformTexelBufferArrayNonUniformIndexing == VK_TRUE;
        if (name == "shaderStorageTexelBufferArrayNonUniformIndexing") return features.shaderStorageTexelBufferArrayNonUniformIndexing == VK_TRUE;
        if (name == "descriptorBindingUniformBufferUpdateAfterBind") return features.descriptorBindingUniformBufferUpdateAfterBind == VK_TRUE;
        if (name == "descriptorBindingSampledImageUpdateAfterBind") return features.descriptorBindingSampledImageUpdateAfterBind == VK_TRUE;
        if (name == "descriptorBindingStorageImageUpdateAfterBind") return features.descriptorBindingStorageImageUpdateAfterBind == VK_TRUE;
        if (name == "descriptorBindingStorageBufferUpdateAfterBind") return features.descriptorBindingStorageBufferUpdateAfterBind == VK_TRUE;
        if (name == "descriptorBindingUniformTexelBufferUpdateAfterBind") return features.descriptorBindingUniformTexelBufferUpdateAfterBind == VK_TRUE;
        if (name == "descriptorBindingStorageTexelBufferUpdateAfterBind") return features.descriptorBindingStorageTexelBufferUpdateAfterBind == VK_TRUE;
        if (name == "descriptorBindingUpdateUnusedWhilePending") return features.descriptorBindingUpdateUnusedWhilePending == VK_TRUE;
        if (name == "descriptorBindingPartiallyBound") return features.descriptorBindingPartiallyBound == VK_TRUE;
        if (name == "descriptorBindingVariableDescriptorCount") return features.descriptorBindingVariableDescriptorCount == VK_TRUE;
        if (name == "runtimeDescriptorArray") return features.runtimeDescriptorArray == VK_TRUE;
        if (name == "samplerFilterMinmax") return features.samplerFilterMinmax == VK_TRUE;
        if (name == "scalarBlockLayout") return features.scalarBlockLayout == VK_TRUE;
        if (name == "imagelessFramebuffer") return features.imagelessFramebuffer == VK_TRUE;
        if (name == "uniformBufferStandardLayout") return features.uniformBufferStandardLayout == VK_TRUE;
        if (name == "shaderSubgroupExtendedTypes") return features.shaderSubgroupExtendedTypes == VK_TRUE;
        if (name == "separateDepthStencilLayouts") return features.separateDepthStencilLayouts == VK_TRUE;
        if (name == "hostQueryReset") return features.hostQueryReset == VK_TRUE;
        if (name == "timelineSemaphore") return features.timelineSemaphore == VK_TRUE;
        if (name == "bufferDeviceAddress") return features.bufferDeviceAddress == VK_TRUE;
        if (name == "bufferDeviceAddressCaptureReplay") return features.bufferDeviceAddressCaptureReplay == VK_TRUE;
        if (name == "bufferDeviceAddressMultiDevice") return features.bufferDeviceAddressMultiDevice == VK_TRUE;
        if (name == "vulkanMemoryModel") return features.vulkanMemoryModel == VK_TRUE;
        if (name == "vulkanMemoryModelDeviceScope") return features.vulkanMemoryModelDeviceScope == VK_TRUE;
        if (name == "vulkanMemoryModelAvailabilityVisibilityChains") return features.vulkanMemoryModelAvailabilityVisibilityChains == VK_TRUE;
        if (name == "shaderOutputViewportIndex") return features.shaderOutputViewportIndex == VK_TRUE;
        if (name == "shaderOutputLayer") return features.shaderOutputLayer == VK_TRUE;
        if (name == "subgroupBroadcastDynamicId") return features.subgroupBroadcastDynamicId == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "samplerMirrorClampToEdge") { features.samplerMirrorClampToEdge = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "drawIndirectCount") { features.drawIndirectCount = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "storageBuffer8BitAccess") { features.storageBuffer8BitAccess = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "uniformAndStorageBuffer8BitAccess") { features.uniformAndStorageBuffer8BitAccess = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "storagePushConstant8") { features.storagePushConstant8 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderBufferInt64Atomics") { features.shaderBufferInt64Atomics = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderSharedInt64Atomics") { features.shaderSharedInt64Atomics = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderFloat16") { features.shaderFloat16 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderInt8") { features.shaderInt8 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorIndexing") { features.descriptorIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderInputAttachmentArrayDynamicIndexing") { features.shaderInputAttachmentArrayDynamicIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderUniformTexelBufferArrayDynamicIndexing") { features.shaderUniformTexelBufferArrayDynamicIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderStorageTexelBufferArrayDynamicIndexing") { features.shaderStorageTexelBufferArrayDynamicIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderUniformBufferArrayNonUniformIndexing") { features.shaderUniformBufferArrayNonUniformIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderSampledImageArrayNonUniformIndexing") { features.shaderSampledImageArrayNonUniformIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderStorageBufferArrayNonUniformIndexing") { features.shaderStorageBufferArrayNonUniformIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderStorageImageArrayNonUniformIndexing") { features.shaderStorageImageArrayNonUniformIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderInputAttachmentArrayNonUniformIndexing") { features.shaderInputAttachmentArrayNonUniformIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderUniformTexelBufferArrayNonUniformIndexing") { features.shaderUniformTexelBufferArrayNonUniformIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderStorageTexelBufferArrayNonUniformIndexing") { features.shaderStorageTexelBufferArrayNonUniformIndexing = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBindingUniformBufferUpdateAfterBind") { features.descriptorBindingUniformBufferUpdateAfterBind = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBindingSampledImageUpdateAfterBind") { features.descriptorBindingSampledImageUpdateAfterBind = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBindingStorageImageUpdateAfterBind") { features.descriptorBindingStorageImageUpdateAfterBind = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBindingStorageBufferUpdateAfterBind") { features.descriptorBindingStorageBufferUpdateAfterBind = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBindingUniformTexelBufferUpdateAfterBind") { features.descriptorBindingUniformTexelBufferUpdateAfterBind = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBindingStorageTexelBufferUpdateAfterBind") { features.descriptorBindingStorageTexelBufferUpdateAfterBind = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBindingUpdateUnusedWhilePending") { features.descriptorBindingUpdateUnusedWhilePending = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBindingPartiallyBound") { features.descriptorBindingPartiallyBound = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBindingVariableDescriptorCount") { features.descriptorBindingVariableDescriptorCount = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "runtimeDescriptorArray") { features.runtimeDescriptorArray = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "samplerFilterMinmax") { features.samplerFilterMinmax = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "scalarBlockLayout") { features.scalarBlockLayout = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "imagelessFramebuffer") { features.imagelessFramebuffer = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "uniformBufferStandardLayout") { features.uniformBufferStandardLayout = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderSubgroupExtendedTypes") { features.shaderSubgroupExtendedTypes = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "separateDepthStencilLayouts") { features.separateDepthStencilLayouts = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "hostQueryReset") { features.hostQueryReset = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "timelineSemaphore") { features.timelineSemaphore = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "bufferDeviceAddress") { features.bufferDeviceAddress = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "bufferDeviceAddressCaptureReplay") { features.bufferDeviceAddressCaptureReplay = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "bufferDeviceAddressMultiDevice") { features.bufferDeviceAddressMultiDevice = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "vulkanMemoryModel") { features.vulkanMemoryModel = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "vulkanMemoryModelDeviceScope") { features.vulkanMemoryModelDeviceScope = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "vulkanMemoryModelAvailabilityVisibilityChains") { features.vulkanMemoryModelAvailabilityVisibilityChains = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderOutputViewportIndex") { features.shaderOutputViewportIndex = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderOutputLayer") { features.shaderOutputLayer = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "subgroupBroadcastDynamicId") { features.subgroupBroadcastDynamicId = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceVulkan12Features";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceVulkan12Features;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceVulkan12Features& get() { return features; }
    const vk::PhysicalDeviceVulkan12Features& get() const { return features; }

  private:
    vk::PhysicalDeviceVulkan12Features features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceVulkan13
// Wraps: vk::PhysicalDeviceVulkan13Features
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceVulkan13 : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "robustImageAccess",
            "inlineUniformBlock",
            "descriptorBindingInlineUniformBlockUpdateAfterBind",
            "pipelineCreationCacheControl",
            "privateData",
            "shaderDemoteToHelperInvocation",
            "shaderTerminateInvocation",
            "subgroupSizeControl",
            "computeFullSubgroups",
            "synchronization2",
            "textureCompressionASTC_HDR",
            "shaderZeroInitializeWorkgroupMemory",
            "dynamicRendering",
            "shaderIntegerDotProduct",
            "maintenance4",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "robustImageAccess") return features.robustImageAccess == VK_TRUE;
        if (name == "inlineUniformBlock") return features.inlineUniformBlock == VK_TRUE;
        if (name == "descriptorBindingInlineUniformBlockUpdateAfterBind") return features.descriptorBindingInlineUniformBlockUpdateAfterBind == VK_TRUE;
        if (name == "pipelineCreationCacheControl") return features.pipelineCreationCacheControl == VK_TRUE;
        if (name == "privateData") return features.privateData == VK_TRUE;
        if (name == "shaderDemoteToHelperInvocation") return features.shaderDemoteToHelperInvocation == VK_TRUE;
        if (name == "shaderTerminateInvocation") return features.shaderTerminateInvocation == VK_TRUE;
        if (name == "subgroupSizeControl") return features.subgroupSizeControl == VK_TRUE;
        if (name == "computeFullSubgroups") return features.computeFullSubgroups == VK_TRUE;
        if (name == "synchronization2") return features.synchronization2 == VK_TRUE;
        if (name == "textureCompressionASTC_HDR") return features.textureCompressionASTC_HDR == VK_TRUE;
        if (name == "shaderZeroInitializeWorkgroupMemory") return features.shaderZeroInitializeWorkgroupMemory == VK_TRUE;
        if (name == "dynamicRendering") return features.dynamicRendering == VK_TRUE;
        if (name == "shaderIntegerDotProduct") return features.shaderIntegerDotProduct == VK_TRUE;
        if (name == "maintenance4") return features.maintenance4 == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "robustImageAccess") { features.robustImageAccess = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "inlineUniformBlock") { features.inlineUniformBlock = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "descriptorBindingInlineUniformBlockUpdateAfterBind") { features.descriptorBindingInlineUniformBlockUpdateAfterBind = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "pipelineCreationCacheControl") { features.pipelineCreationCacheControl = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "privateData") { features.privateData = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderDemoteToHelperInvocation") { features.shaderDemoteToHelperInvocation = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderTerminateInvocation") { features.shaderTerminateInvocation = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "subgroupSizeControl") { features.subgroupSizeControl = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "computeFullSubgroups") { features.computeFullSubgroups = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "synchronization2") { features.synchronization2 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "textureCompressionASTC_HDR") { features.textureCompressionASTC_HDR = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderZeroInitializeWorkgroupMemory") { features.shaderZeroInitializeWorkgroupMemory = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "dynamicRendering") { features.dynamicRendering = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderIntegerDotProduct") { features.shaderIntegerDotProduct = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "maintenance4") { features.maintenance4 = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceVulkan13Features";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceVulkan13Features;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceVulkan13Features& get() { return features; }
    const vk::PhysicalDeviceVulkan13Features& get() const { return features; }

  private:
    vk::PhysicalDeviceVulkan13Features features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceVulkan14
// Wraps: vk::PhysicalDeviceVulkan14Features
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceVulkan14 : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "globalPriorityQuery",
            "shaderSubgroupRotate",
            "shaderSubgroupRotateClustered",
            "shaderFloatControls2",
            "shaderExpectAssume",
            "rectangularLines",
            "bresenhamLines",
            "smoothLines",
            "stippledRectangularLines",
            "stippledBresenhamLines",
            "stippledSmoothLines",
            "vertexAttributeInstanceRateDivisor",
            "vertexAttributeInstanceRateZeroDivisor",
            "indexTypeUint8",
            "dynamicRenderingLocalRead",
            "maintenance5",
            "maintenance6",
            "pipelineProtectedAccess",
            "pipelineRobustness",
            "hostImageCopy",
            "pushDescriptor",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "globalPriorityQuery") return features.globalPriorityQuery == VK_TRUE;
        if (name == "shaderSubgroupRotate") return features.shaderSubgroupRotate == VK_TRUE;
        if (name == "shaderSubgroupRotateClustered") return features.shaderSubgroupRotateClustered == VK_TRUE;
        if (name == "shaderFloatControls2") return features.shaderFloatControls2 == VK_TRUE;
        if (name == "shaderExpectAssume") return features.shaderExpectAssume == VK_TRUE;
        if (name == "rectangularLines") return features.rectangularLines == VK_TRUE;
        if (name == "bresenhamLines") return features.bresenhamLines == VK_TRUE;
        if (name == "smoothLines") return features.smoothLines == VK_TRUE;
        if (name == "stippledRectangularLines") return features.stippledRectangularLines == VK_TRUE;
        if (name == "stippledBresenhamLines") return features.stippledBresenhamLines == VK_TRUE;
        if (name == "stippledSmoothLines") return features.stippledSmoothLines == VK_TRUE;
        if (name == "vertexAttributeInstanceRateDivisor") return features.vertexAttributeInstanceRateDivisor == VK_TRUE;
        if (name == "vertexAttributeInstanceRateZeroDivisor") return features.vertexAttributeInstanceRateZeroDivisor == VK_TRUE;
        if (name == "indexTypeUint8") return features.indexTypeUint8 == VK_TRUE;
        if (name == "dynamicRenderingLocalRead") return features.dynamicRenderingLocalRead == VK_TRUE;
        if (name == "maintenance5") return features.maintenance5 == VK_TRUE;
        if (name == "maintenance6") return features.maintenance6 == VK_TRUE;
        if (name == "pipelineProtectedAccess") return features.pipelineProtectedAccess == VK_TRUE;
        if (name == "pipelineRobustness") return features.pipelineRobustness == VK_TRUE;
        if (name == "hostImageCopy") return features.hostImageCopy == VK_TRUE;
        if (name == "pushDescriptor") return features.pushDescriptor == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "globalPriorityQuery") { features.globalPriorityQuery = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderSubgroupRotate") { features.shaderSubgroupRotate = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderSubgroupRotateClustered") { features.shaderSubgroupRotateClustered = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderFloatControls2") { features.shaderFloatControls2 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "shaderExpectAssume") { features.shaderExpectAssume = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "rectangularLines") { features.rectangularLines = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "bresenhamLines") { features.bresenhamLines = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "smoothLines") { features.smoothLines = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "stippledRectangularLines") { features.stippledRectangularLines = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "stippledBresenhamLines") { features.stippledBresenhamLines = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "stippledSmoothLines") { features.stippledSmoothLines = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "vertexAttributeInstanceRateDivisor") { features.vertexAttributeInstanceRateDivisor = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "vertexAttributeInstanceRateZeroDivisor") { features.vertexAttributeInstanceRateZeroDivisor = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "indexTypeUint8") { features.indexTypeUint8 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "dynamicRenderingLocalRead") { features.dynamicRenderingLocalRead = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "maintenance5") { features.maintenance5 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "maintenance6") { features.maintenance6 = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "pipelineProtectedAccess") { features.pipelineProtectedAccess = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "pipelineRobustness") { features.pipelineRobustness = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "hostImageCopy") { features.hostImageCopy = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "pushDescriptor") { features.pushDescriptor = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceVulkan14Features";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceVulkan14Features;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceVulkan14Features& get() { return features; }
    const vk::PhysicalDeviceVulkan14Features& get() const { return features; }

  private:
    vk::PhysicalDeviceVulkan14Features features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceVulkanMemoryModel
// Wraps: vk::PhysicalDeviceVulkanMemoryModelFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceVulkanMemoryModel : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "vulkanMemoryModel",
            "vulkanMemoryModelDeviceScope",
            "vulkanMemoryModelAvailabilityVisibilityChains",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "vulkanMemoryModel") return features.vulkanMemoryModel == VK_TRUE;
        if (name == "vulkanMemoryModelDeviceScope") return features.vulkanMemoryModelDeviceScope == VK_TRUE;
        if (name == "vulkanMemoryModelAvailabilityVisibilityChains") return features.vulkanMemoryModelAvailabilityVisibilityChains == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "vulkanMemoryModel") { features.vulkanMemoryModel = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "vulkanMemoryModelDeviceScope") { features.vulkanMemoryModelDeviceScope = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "vulkanMemoryModelAvailabilityVisibilityChains") { features.vulkanMemoryModelAvailabilityVisibilityChains = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceVulkanMemoryModelFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceVulkanMemoryModelFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceVulkanMemoryModelFeatures& get() { return features; }
    const vk::PhysicalDeviceVulkanMemoryModelFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceVulkanMemoryModelFeatures features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceWorkgroupMemoryExplicitLayoutKHR
// Wraps: vk::PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR
// Extension: VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceWorkgroupMemoryExplicitLayoutKHR : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "workgroupMemoryExplicitLayout",
            "workgroupMemoryExplicitLayoutScalarBlockLayout",
            "workgroupMemoryExplicitLayout8BitAccess",
            "workgroupMemoryExplicitLayout16BitAccess",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "workgroupMemoryExplicitLayout") return features.workgroupMemoryExplicitLayout == VK_TRUE;
        if (name == "workgroupMemoryExplicitLayoutScalarBlockLayout") return features.workgroupMemoryExplicitLayoutScalarBlockLayout == VK_TRUE;
        if (name == "workgroupMemoryExplicitLayout8BitAccess") return features.workgroupMemoryExplicitLayout8BitAccess == VK_TRUE;
        if (name == "workgroupMemoryExplicitLayout16BitAccess") return features.workgroupMemoryExplicitLayout16BitAccess == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "workgroupMemoryExplicitLayout") { features.workgroupMemoryExplicitLayout = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "workgroupMemoryExplicitLayoutScalarBlockLayout") { features.workgroupMemoryExplicitLayoutScalarBlockLayout = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "workgroupMemoryExplicitLayout8BitAccess") { features.workgroupMemoryExplicitLayout8BitAccess = value ? VK_TRUE : VK_FALSE; return true; }
        if (name == "workgroupMemoryExplicitLayout16BitAccess") { features.workgroupMemoryExplicitLayout16BitAccess = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR& get() { return features; }
    const vk::PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR& get() const { return features; }

  private:
    vk::PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceYcbcr2Plane444FormatsEXT
// Wraps: vk::PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT
// Extension: VK_EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceYcbcr2Plane444FormatsEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "ycbcr2plane444Formats",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "ycbcr2plane444Formats") return features.ycbcr2plane444Formats == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "ycbcr2plane444Formats") { features.ycbcr2plane444Formats = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceYcbcrDegammaQCOM
// Wraps: vk::PhysicalDeviceYcbcrDegammaFeaturesQCOM
// Extension: VK_QCOM_YCBCR_DEGAMMA_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceYcbcrDegammaQCOM : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_QCOM_YCBCR_DEGAMMA_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "ycbcrDegamma",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "ycbcrDegamma") return features.ycbcrDegamma == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "ycbcrDegamma") { features.ycbcrDegamma = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceYcbcrDegammaFeaturesQCOM";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceYcbcrDegammaFeaturesQCOM;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceYcbcrDegammaFeaturesQCOM& get() { return features; }
    const vk::PhysicalDeviceYcbcrDegammaFeaturesQCOM& get() const { return features; }

  private:
    vk::PhysicalDeviceYcbcrDegammaFeaturesQCOM features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceYcbcrImageArraysEXT
// Wraps: vk::PhysicalDeviceYcbcrImageArraysFeaturesEXT
// Extension: VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceYcbcrImageArraysEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "ycbcrImageArrays",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "ycbcrImageArrays") return features.ycbcrImageArrays == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "ycbcrImageArrays") { features.ycbcrImageArrays = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceYcbcrImageArraysFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceYcbcrImageArraysFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceYcbcrImageArraysFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceYcbcrImageArraysFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceYcbcrImageArraysFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceZeroInitializeDeviceMemoryEXT
// Wraps: vk::PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT
// Extension: VK_EXT_ZERO_INITIALIZE_DEVICE_MEMORY_EXTENSION_NAME
// Core in: VK_API_VERSION_1_1
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceZeroInitializeDeviceMemoryEXT : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_EXT_ZERO_INITIALIZE_DEVICE_MEMORY_EXTENSION_NAME};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "zeroInitializeDeviceMemory",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "zeroInitializeDeviceMemory") return features.zeroInitializeDeviceMemory == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "zeroInitializeDeviceMemory") { features.zeroInitializeDeviceMemory = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT& get() { return features; }
    const vk::PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT& get() const { return features; }

  private:
    vk::PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT features{};
};

// ----------------------------------------------------------------------
// FeaturePhysicalDeviceZeroInitializeWorkgroupMemory
// Wraps: vk::PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures
// ----------------------------------------------------------------------

class FeaturePhysicalDeviceZeroInitializeWorkgroupMemory : public Feature {
  public:
    std::vector<const char*> get_required_extensions(uint32_t vk_api_version) const override {
        (void)vk_api_version;
        return {};
    }

    std::vector<const char*> get_feature_names() const override {
        return {
            "shaderZeroInitializeWorkgroupMemory",
        };
    }

    bool get_feature(const std::string& name) const override {
        if (name == "shaderZeroInitializeWorkgroupMemory") return features.shaderZeroInitializeWorkgroupMemory == VK_TRUE;
        return false;
    }

    bool set_feature(const std::string& name, bool value) override {
        if (name == "shaderZeroInitializeWorkgroupMemory") { features.shaderZeroInitializeWorkgroupMemory = value ? VK_TRUE : VK_FALSE; return true; }
        return false;
    }

    const char* get_name() const override {
        return "PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures";
    }

    vk::StructureType get_structure_type() const override {
        return vk::StructureType::ePhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;
    }

    void* get_structure_ptr() override {
        return &features;
    }

    void set_pnext(void* p_next) override {
        features.pNext = p_next;
    }

    vk::PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures& get() { return features; }
    const vk::PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures& get() const { return features; }

  private:
    vk::PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures features{};
};

// ----------------------------------------------------------------------
// get_feature implementations
// ----------------------------------------------------------------------

FeatureHandle get_feature(vk::StructureType stype) {
    switch (stype) {
        case vk::StructureType::ePhysicalDevice16BitStorageFeatures:
            return std::make_shared<FeaturePhysicalDevice16BitStorage>();
        case vk::StructureType::ePhysicalDevice4444FormatsFeaturesEXT:
            return std::make_shared<FeaturePhysicalDevice4444FormatsEXT>();
        case vk::StructureType::ePhysicalDevice8BitStorageFeatures:
            return std::make_shared<FeaturePhysicalDevice8BitStorage>();
        case vk::StructureType::ePhysicalDeviceAstcDecodeFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceASTCDecodeEXT>();
        case vk::StructureType::ePhysicalDeviceAccelerationStructureFeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceAccelerationStructureKHR>();
        case vk::StructureType::ePhysicalDeviceAddressBindingReportFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceAddressBindingReportEXT>();
        case vk::StructureType::ePhysicalDeviceAmigoProfilingFeaturesSEC:
            return std::make_shared<FeaturePhysicalDeviceAmigoProfilingSEC>();
        case vk::StructureType::ePhysicalDeviceAntiLagFeaturesAMD:
            return std::make_shared<FeaturePhysicalDeviceAntiLagAMD>();
        case vk::StructureType::ePhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceAttachmentFeedbackLoopDynamicStateEXT>();
        case vk::StructureType::ePhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceAttachmentFeedbackLoopLayoutEXT>();
        case vk::StructureType::ePhysicalDeviceBlendOperationAdvancedFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceBlendOperationAdvancedEXT>();
        case vk::StructureType::ePhysicalDeviceBorderColorSwizzleFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceBorderColorSwizzleEXT>();
        case vk::StructureType::ePhysicalDeviceBufferDeviceAddressFeatures:
            return std::make_shared<FeaturePhysicalDeviceBufferDeviceAddress>();
        case vk::StructureType::ePhysicalDeviceBufferDeviceAddressFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceBufferDeviceAddressEXT>();
        case vk::StructureType::ePhysicalDeviceClusterAccelerationStructureFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceClusterAccelerationStructureNV>();
        case vk::StructureType::ePhysicalDeviceClusterCullingShaderFeaturesHUAWEI:
            return std::make_shared<FeaturePhysicalDeviceClusterCullingShaderHUAWEI>();
        case vk::StructureType::ePhysicalDeviceCoherentMemoryFeaturesAMD:
            return std::make_shared<FeaturePhysicalDeviceCoherentMemoryAMD>();
        case vk::StructureType::ePhysicalDeviceColorWriteEnableFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceColorWriteEnableEXT>();
        case vk::StructureType::ePhysicalDeviceCommandBufferInheritanceFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceCommandBufferInheritanceNV>();
        case vk::StructureType::ePhysicalDeviceComputeOccupancyPriorityFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceComputeOccupancyPriorityNV>();
        case vk::StructureType::ePhysicalDeviceComputeShaderDerivativesFeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceComputeShaderDerivativesKHR>();
        case vk::StructureType::ePhysicalDeviceConditionalRenderingFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceConditionalRenderingEXT>();
        case vk::StructureType::ePhysicalDeviceCooperativeMatrix2FeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceCooperativeMatrix2NV>();
        case vk::StructureType::ePhysicalDeviceCooperativeMatrixFeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceCooperativeMatrixKHR>();
        case vk::StructureType::ePhysicalDeviceCooperativeMatrixFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceCooperativeMatrixNV>();
        case vk::StructureType::ePhysicalDeviceCooperativeVectorFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceCooperativeVectorNV>();
        case vk::StructureType::ePhysicalDeviceCopyMemoryIndirectFeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceCopyMemoryIndirectKHR>();
        case vk::StructureType::ePhysicalDeviceCopyMemoryIndirectFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceCopyMemoryIndirectNV>();
        case vk::StructureType::ePhysicalDeviceCornerSampledImageFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceCornerSampledImageNV>();
        case vk::StructureType::ePhysicalDeviceCoverageReductionModeFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceCoverageReductionModeNV>();
        case vk::StructureType::ePhysicalDeviceCubicClampFeaturesQCOM:
            return std::make_shared<FeaturePhysicalDeviceCubicClampQCOM>();
        case vk::StructureType::ePhysicalDeviceCubicWeightsFeaturesQCOM:
            return std::make_shared<FeaturePhysicalDeviceCubicWeightsQCOM>();
        case vk::StructureType::ePhysicalDeviceCustomBorderColorFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceCustomBorderColorEXT>();
        case vk::StructureType::ePhysicalDeviceCustomResolveFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceCustomResolveEXT>();
        case vk::StructureType::ePhysicalDeviceDataGraphFeaturesARM:
            return std::make_shared<FeaturePhysicalDeviceDataGraphARM>();
        case vk::StructureType::ePhysicalDeviceDataGraphModelFeaturesQCOM:
            return std::make_shared<FeaturePhysicalDeviceDataGraphModelQCOM>();
        case vk::StructureType::ePhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceDedicatedAllocationImageAliasingNV>();
        case vk::StructureType::ePhysicalDeviceDepthBiasControlFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceDepthBiasControlEXT>();
        case vk::StructureType::ePhysicalDeviceDepthClampControlFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceDepthClampControlEXT>();
        case vk::StructureType::ePhysicalDeviceDepthClampZeroOneFeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceDepthClampZeroOneKHR>();
        case vk::StructureType::ePhysicalDeviceDepthClipControlFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceDepthClipControlEXT>();
        case vk::StructureType::ePhysicalDeviceDepthClipEnableFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceDepthClipEnableEXT>();
        case vk::StructureType::ePhysicalDeviceDescriptorBufferFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceDescriptorBufferEXT>();
        case vk::StructureType::ePhysicalDeviceDescriptorBufferTensorFeaturesARM:
            return std::make_shared<FeaturePhysicalDeviceDescriptorBufferTensorARM>();
        case vk::StructureType::ePhysicalDeviceDescriptorIndexingFeatures:
            return std::make_shared<FeaturePhysicalDeviceDescriptorIndexing>();
        case vk::StructureType::ePhysicalDeviceDescriptorPoolOverallocationFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceDescriptorPoolOverallocationNV>();
        case vk::StructureType::ePhysicalDeviceDescriptorSetHostMappingFeaturesVALVE:
            return std::make_shared<FeaturePhysicalDeviceDescriptorSetHostMappingVALVE>();
        case vk::StructureType::ePhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceDeviceGeneratedCommandsComputeNV>();
        case vk::StructureType::ePhysicalDeviceDeviceGeneratedCommandsFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceDeviceGeneratedCommandsEXT>();
        case vk::StructureType::ePhysicalDeviceDeviceGeneratedCommandsFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceDeviceGeneratedCommandsNV>();
        case vk::StructureType::ePhysicalDeviceDeviceMemoryReportFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceDeviceMemoryReportEXT>();
        case vk::StructureType::ePhysicalDeviceDiagnosticsConfigFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceDiagnosticsConfigNV>();
        case vk::StructureType::ePhysicalDeviceDynamicRenderingFeatures:
            return std::make_shared<FeaturePhysicalDeviceDynamicRendering>();
        case vk::StructureType::ePhysicalDeviceDynamicRenderingLocalReadFeatures:
            return std::make_shared<FeaturePhysicalDeviceDynamicRenderingLocalRead>();
        case vk::StructureType::ePhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceDynamicRenderingUnusedAttachmentsEXT>();
        case vk::StructureType::ePhysicalDeviceExclusiveScissorFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceExclusiveScissorNV>();
        case vk::StructureType::ePhysicalDeviceExtendedDynamicState2FeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceExtendedDynamicState2EXT>();
        case vk::StructureType::ePhysicalDeviceExtendedDynamicState3FeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceExtendedDynamicState3EXT>();
        case vk::StructureType::ePhysicalDeviceExtendedDynamicStateFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceExtendedDynamicStateEXT>();
        case vk::StructureType::ePhysicalDeviceExtendedSparseAddressSpaceFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceExtendedSparseAddressSpaceNV>();
        case vk::StructureType::ePhysicalDeviceExternalMemoryRdmaFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceExternalMemoryRDMANV>();
        case vk::StructureType::ePhysicalDeviceFaultFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceFaultEXT>();
        case vk::StructureType::ePhysicalDeviceFeatures2:
            return std::make_shared<FeaturePhysicalDeviceFeatures2>();
        case vk::StructureType::ePhysicalDeviceFormatPackFeaturesARM:
            return std::make_shared<FeaturePhysicalDeviceFormatPackARM>();
        case vk::StructureType::ePhysicalDeviceFragmentDensityMap2FeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceFragmentDensityMap2EXT>();
        case vk::StructureType::ePhysicalDeviceFragmentDensityMapFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceFragmentDensityMapEXT>();
        case vk::StructureType::ePhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE:
            return std::make_shared<FeaturePhysicalDeviceFragmentDensityMapLayeredVALVE>();
        case vk::StructureType::ePhysicalDeviceFragmentDensityMapOffsetFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceFragmentDensityMapOffsetEXT>();
        case vk::StructureType::ePhysicalDeviceFragmentShaderBarycentricFeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceFragmentShaderBarycentricKHR>();
        case vk::StructureType::ePhysicalDeviceFragmentShaderInterlockFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceFragmentShaderInterlockEXT>();
        case vk::StructureType::ePhysicalDeviceFragmentShadingRateEnumsFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceFragmentShadingRateEnumsNV>();
        case vk::StructureType::ePhysicalDeviceFragmentShadingRateFeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceFragmentShadingRateKHR>();
        case vk::StructureType::ePhysicalDeviceFrameBoundaryFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceFrameBoundaryEXT>();
        case vk::StructureType::ePhysicalDeviceGlobalPriorityQueryFeatures:
            return std::make_shared<FeaturePhysicalDeviceGlobalPriorityQuery>();
        case vk::StructureType::ePhysicalDeviceGraphicsPipelineLibraryFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceGraphicsPipelineLibraryEXT>();
        case vk::StructureType::ePhysicalDeviceHdrVividFeaturesHUAWEI:
            return std::make_shared<FeaturePhysicalDeviceHdrVividHUAWEI>();
        case vk::StructureType::ePhysicalDeviceHostImageCopyFeatures:
            return std::make_shared<FeaturePhysicalDeviceHostImageCopy>();
        case vk::StructureType::ePhysicalDeviceHostQueryResetFeatures:
            return std::make_shared<FeaturePhysicalDeviceHostQueryReset>();
        case vk::StructureType::ePhysicalDeviceImage2DViewOf3DFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceImage2DViewOf3DEXT>();
        case vk::StructureType::ePhysicalDeviceImageAlignmentControlFeaturesMESA:
            return std::make_shared<FeaturePhysicalDeviceImageAlignmentControlMESA>();
        case vk::StructureType::ePhysicalDeviceImageCompressionControlFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceImageCompressionControlEXT>();
        case vk::StructureType::ePhysicalDeviceImageCompressionControlSwapchainFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceImageCompressionControlSwapchainEXT>();
        case vk::StructureType::ePhysicalDeviceImageProcessing2FeaturesQCOM:
            return std::make_shared<FeaturePhysicalDeviceImageProcessing2QCOM>();
        case vk::StructureType::ePhysicalDeviceImageProcessingFeaturesQCOM:
            return std::make_shared<FeaturePhysicalDeviceImageProcessingQCOM>();
        case vk::StructureType::ePhysicalDeviceImageRobustnessFeatures:
            return std::make_shared<FeaturePhysicalDeviceImageRobustness>();
        case vk::StructureType::ePhysicalDeviceImageSlicedViewOf3DFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceImageSlicedViewOf3DEXT>();
        case vk::StructureType::ePhysicalDeviceImageViewMinLodFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceImageViewMinLodEXT>();
        case vk::StructureType::ePhysicalDeviceImagelessFramebufferFeatures:
            return std::make_shared<FeaturePhysicalDeviceImagelessFramebuffer>();
        case vk::StructureType::ePhysicalDeviceIndexTypeUint8Features:
            return std::make_shared<FeaturePhysicalDeviceIndexTypeUint8>();
        case vk::StructureType::ePhysicalDeviceInheritedViewportScissorFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceInheritedViewportScissorNV>();
        case vk::StructureType::ePhysicalDeviceInlineUniformBlockFeatures:
            return std::make_shared<FeaturePhysicalDeviceInlineUniformBlock>();
        case vk::StructureType::ePhysicalDeviceInvocationMaskFeaturesHUAWEI:
            return std::make_shared<FeaturePhysicalDeviceInvocationMaskHUAWEI>();
        case vk::StructureType::ePhysicalDeviceLegacyDitheringFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceLegacyDitheringEXT>();
        case vk::StructureType::ePhysicalDeviceLegacyVertexAttributesFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceLegacyVertexAttributesEXT>();
        case vk::StructureType::ePhysicalDeviceLineRasterizationFeatures:
            return std::make_shared<FeaturePhysicalDeviceLineRasterization>();
        case vk::StructureType::ePhysicalDeviceLinearColorAttachmentFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceLinearColorAttachmentNV>();
        case vk::StructureType::ePhysicalDeviceMaintenance10FeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceMaintenance10KHR>();
        case vk::StructureType::ePhysicalDeviceMaintenance4Features:
            return std::make_shared<FeaturePhysicalDeviceMaintenance4>();
        case vk::StructureType::ePhysicalDeviceMaintenance5Features:
            return std::make_shared<FeaturePhysicalDeviceMaintenance5>();
        case vk::StructureType::ePhysicalDeviceMaintenance6Features:
            return std::make_shared<FeaturePhysicalDeviceMaintenance6>();
        case vk::StructureType::ePhysicalDeviceMaintenance7FeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceMaintenance7KHR>();
        case vk::StructureType::ePhysicalDeviceMaintenance8FeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceMaintenance8KHR>();
        case vk::StructureType::ePhysicalDeviceMaintenance9FeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceMaintenance9KHR>();
        case vk::StructureType::ePhysicalDeviceMapMemoryPlacedFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceMapMemoryPlacedEXT>();
        case vk::StructureType::ePhysicalDeviceMemoryDecompressionFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceMemoryDecompressionEXT>();
        case vk::StructureType::ePhysicalDeviceMemoryPriorityFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceMemoryPriorityEXT>();
        case vk::StructureType::ePhysicalDeviceMeshShaderFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceMeshShaderEXT>();
        case vk::StructureType::ePhysicalDeviceMeshShaderFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceMeshShaderNV>();
        case vk::StructureType::ePhysicalDeviceMultiDrawFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceMultiDrawEXT>();
        case vk::StructureType::ePhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceMultisampledRenderToSingleSampledEXT>();
        case vk::StructureType::ePhysicalDeviceMultiviewFeatures:
            return std::make_shared<FeaturePhysicalDeviceMultiview>();
        case vk::StructureType::ePhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM:
            return std::make_shared<FeaturePhysicalDeviceMultiviewPerViewRenderAreasQCOM>();
        case vk::StructureType::ePhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM:
            return std::make_shared<FeaturePhysicalDeviceMultiviewPerViewViewportsQCOM>();
        case vk::StructureType::ePhysicalDeviceMutableDescriptorTypeFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceMutableDescriptorTypeEXT>();
        case vk::StructureType::ePhysicalDeviceNestedCommandBufferFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceNestedCommandBufferEXT>();
        case vk::StructureType::ePhysicalDeviceNonSeamlessCubeMapFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceNonSeamlessCubeMapEXT>();
        case vk::StructureType::ePhysicalDeviceOpacityMicromapFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceOpacityMicromapEXT>();
        case vk::StructureType::ePhysicalDeviceOpticalFlowFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceOpticalFlowNV>();
        case vk::StructureType::ePhysicalDevicePageableDeviceLocalMemoryFeaturesEXT:
            return std::make_shared<FeaturePhysicalDevicePageableDeviceLocalMemoryEXT>();
        case vk::StructureType::ePhysicalDevicePartitionedAccelerationStructureFeaturesNV:
            return std::make_shared<FeaturePhysicalDevicePartitionedAccelerationStructureNV>();
        case vk::StructureType::ePhysicalDevicePerStageDescriptorSetFeaturesNV:
            return std::make_shared<FeaturePhysicalDevicePerStageDescriptorSetNV>();
        case vk::StructureType::ePhysicalDevicePerformanceCountersByRegionFeaturesARM:
            return std::make_shared<FeaturePhysicalDevicePerformanceCountersByRegionARM>();
        case vk::StructureType::ePhysicalDevicePerformanceQueryFeaturesKHR:
            return std::make_shared<FeaturePhysicalDevicePerformanceQueryKHR>();
        case vk::StructureType::ePhysicalDevicePipelineBinaryFeaturesKHR:
            return std::make_shared<FeaturePhysicalDevicePipelineBinaryKHR>();
        case vk::StructureType::ePhysicalDevicePipelineCacheIncrementalModeFeaturesSEC:
            return std::make_shared<FeaturePhysicalDevicePipelineCacheIncrementalModeSEC>();
        case vk::StructureType::ePhysicalDevicePipelineCreationCacheControlFeatures:
            return std::make_shared<FeaturePhysicalDevicePipelineCreationCacheControl>();
        case vk::StructureType::ePhysicalDevicePipelineExecutablePropertiesFeaturesKHR:
            return std::make_shared<FeaturePhysicalDevicePipelineExecutablePropertiesKHR>();
        case vk::StructureType::ePhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT:
            return std::make_shared<FeaturePhysicalDevicePipelineLibraryGroupHandlesEXT>();
        case vk::StructureType::ePhysicalDevicePipelineOpacityMicromapFeaturesARM:
            return std::make_shared<FeaturePhysicalDevicePipelineOpacityMicromapARM>();
        case vk::StructureType::ePhysicalDevicePipelinePropertiesFeaturesEXT:
            return std::make_shared<FeaturePhysicalDevicePipelinePropertiesEXT>();
        case vk::StructureType::ePhysicalDevicePipelineProtectedAccessFeatures:
            return std::make_shared<FeaturePhysicalDevicePipelineProtectedAccess>();
        case vk::StructureType::ePhysicalDevicePipelineRobustnessFeatures:
            return std::make_shared<FeaturePhysicalDevicePipelineRobustness>();
        case vk::StructureType::ePhysicalDevicePresentBarrierFeaturesNV:
            return std::make_shared<FeaturePhysicalDevicePresentBarrierNV>();
        case vk::StructureType::ePhysicalDevicePresentId2FeaturesKHR:
            return std::make_shared<FeaturePhysicalDevicePresentId2KHR>();
        case vk::StructureType::ePhysicalDevicePresentIdFeaturesKHR:
            return std::make_shared<FeaturePhysicalDevicePresentIdKHR>();
        case vk::StructureType::ePhysicalDevicePresentModeFifoLatestReadyFeaturesKHR:
            return std::make_shared<FeaturePhysicalDevicePresentModeFifoLatestReadyKHR>();
        case vk::StructureType::ePhysicalDevicePresentTimingFeaturesEXT:
            return std::make_shared<FeaturePhysicalDevicePresentTimingEXT>();
        case vk::StructureType::ePhysicalDevicePresentWait2FeaturesKHR:
            return std::make_shared<FeaturePhysicalDevicePresentWait2KHR>();
        case vk::StructureType::ePhysicalDevicePresentWaitFeaturesKHR:
            return std::make_shared<FeaturePhysicalDevicePresentWaitKHR>();
        case vk::StructureType::ePhysicalDevicePrimitiveTopologyListRestartFeaturesEXT:
            return std::make_shared<FeaturePhysicalDevicePrimitiveTopologyListRestartEXT>();
        case vk::StructureType::ePhysicalDevicePrimitivesGeneratedQueryFeaturesEXT:
            return std::make_shared<FeaturePhysicalDevicePrimitivesGeneratedQueryEXT>();
        case vk::StructureType::ePhysicalDevicePrivateDataFeatures:
            return std::make_shared<FeaturePhysicalDevicePrivateData>();
        case vk::StructureType::ePhysicalDeviceProtectedMemoryFeatures:
            return std::make_shared<FeaturePhysicalDeviceProtectedMemory>();
        case vk::StructureType::ePhysicalDeviceProvokingVertexFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceProvokingVertexEXT>();
        case vk::StructureType::ePhysicalDeviceRgba10X6FormatsFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceRGBA10X6FormatsEXT>();
        case vk::StructureType::ePhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceRasterizationOrderAttachmentAccessEXT>();
        case vk::StructureType::ePhysicalDeviceRawAccessChainsFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceRawAccessChainsNV>();
        case vk::StructureType::ePhysicalDeviceRayQueryFeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceRayQueryKHR>();
        case vk::StructureType::ePhysicalDeviceRayTracingInvocationReorderFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceRayTracingInvocationReorderEXT>();
        case vk::StructureType::ePhysicalDeviceRayTracingInvocationReorderFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceRayTracingInvocationReorderNV>();
        case vk::StructureType::ePhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceRayTracingLinearSweptSpheresNV>();
        case vk::StructureType::ePhysicalDeviceRayTracingMaintenance1FeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceRayTracingMaintenance1KHR>();
        case vk::StructureType::ePhysicalDeviceRayTracingMotionBlurFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceRayTracingMotionBlurNV>();
        case vk::StructureType::ePhysicalDeviceRayTracingPipelineFeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceRayTracingPipelineKHR>();
        case vk::StructureType::ePhysicalDeviceRayTracingPositionFetchFeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceRayTracingPositionFetchKHR>();
        case vk::StructureType::ePhysicalDeviceRayTracingValidationFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceRayTracingValidationNV>();
        case vk::StructureType::ePhysicalDeviceRelaxedLineRasterizationFeaturesIMG:
            return std::make_shared<FeaturePhysicalDeviceRelaxedLineRasterizationIMG>();
        case vk::StructureType::ePhysicalDeviceRenderPassStripedFeaturesARM:
            return std::make_shared<FeaturePhysicalDeviceRenderPassStripedARM>();
        case vk::StructureType::ePhysicalDeviceRepresentativeFragmentTestFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceRepresentativeFragmentTestNV>();
        case vk::StructureType::ePhysicalDeviceRobustness2FeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceRobustness2KHR>();
        case vk::StructureType::ePhysicalDeviceSamplerYcbcrConversionFeatures:
            return std::make_shared<FeaturePhysicalDeviceSamplerYcbcrConversion>();
        case vk::StructureType::ePhysicalDeviceScalarBlockLayoutFeatures:
            return std::make_shared<FeaturePhysicalDeviceScalarBlockLayout>();
        case vk::StructureType::ePhysicalDeviceSchedulingControlsFeaturesARM:
            return std::make_shared<FeaturePhysicalDeviceSchedulingControlsARM>();
        case vk::StructureType::ePhysicalDeviceSeparateDepthStencilLayoutsFeatures:
            return std::make_shared<FeaturePhysicalDeviceSeparateDepthStencilLayouts>();
        case vk::StructureType::ePhysicalDeviceShader64BitIndexingFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceShader64BitIndexingEXT>();
        case vk::StructureType::ePhysicalDeviceShaderAtomicFloat16VectorFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceShaderAtomicFloat16VectorNV>();
        case vk::StructureType::ePhysicalDeviceShaderAtomicFloat2FeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceShaderAtomicFloat2EXT>();
        case vk::StructureType::ePhysicalDeviceShaderAtomicFloatFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceShaderAtomicFloatEXT>();
        case vk::StructureType::ePhysicalDeviceShaderAtomicInt64Features:
            return std::make_shared<FeaturePhysicalDeviceShaderAtomicInt64>();
        case vk::StructureType::ePhysicalDeviceShaderBfloat16FeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceShaderBfloat16KHR>();
        case vk::StructureType::ePhysicalDeviceShaderClockFeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceShaderClockKHR>();
        case vk::StructureType::ePhysicalDeviceShaderCoreBuiltinsFeaturesARM:
            return std::make_shared<FeaturePhysicalDeviceShaderCoreBuiltinsARM>();
        case vk::StructureType::ePhysicalDeviceShaderDemoteToHelperInvocationFeatures:
            return std::make_shared<FeaturePhysicalDeviceShaderDemoteToHelperInvocation>();
        case vk::StructureType::ePhysicalDeviceShaderDrawParametersFeatures:
            return std::make_shared<FeaturePhysicalDeviceShaderDrawParameters>();
        case vk::StructureType::ePhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD:
            return std::make_shared<FeaturePhysicalDeviceShaderEarlyAndLateFragmentTestsAMD>();
        case vk::StructureType::ePhysicalDeviceShaderExpectAssumeFeatures:
            return std::make_shared<FeaturePhysicalDeviceShaderExpectAssume>();
        case vk::StructureType::ePhysicalDeviceShaderFloat16Int8Features:
            return std::make_shared<FeaturePhysicalDeviceShaderFloat16Int8>();
        case vk::StructureType::ePhysicalDeviceShaderFloat8FeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceShaderFloat8EXT>();
        case vk::StructureType::ePhysicalDeviceShaderFloatControls2Features:
            return std::make_shared<FeaturePhysicalDeviceShaderFloatControls2>();
        case vk::StructureType::ePhysicalDeviceShaderFmaFeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceShaderFmaKHR>();
        case vk::StructureType::ePhysicalDeviceShaderImageAtomicInt64FeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceShaderImageAtomicInt64EXT>();
        case vk::StructureType::ePhysicalDeviceShaderImageFootprintFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceShaderImageFootprintNV>();
        case vk::StructureType::ePhysicalDeviceShaderIntegerDotProductFeatures:
            return std::make_shared<FeaturePhysicalDeviceShaderIntegerDotProduct>();
        case vk::StructureType::ePhysicalDeviceShaderIntegerFunctions2FeaturesINTEL:
            return std::make_shared<FeaturePhysicalDeviceShaderIntegerFunctions2INTEL>();
        case vk::StructureType::ePhysicalDeviceShaderLongVectorFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceShaderLongVectorEXT>();
        case vk::StructureType::ePhysicalDeviceShaderMaximalReconvergenceFeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceShaderMaximalReconvergenceKHR>();
        case vk::StructureType::ePhysicalDeviceShaderModuleIdentifierFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceShaderModuleIdentifierEXT>();
        case vk::StructureType::ePhysicalDeviceShaderObjectFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceShaderObjectEXT>();
        case vk::StructureType::ePhysicalDeviceShaderQuadControlFeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceShaderQuadControlKHR>();
        case vk::StructureType::ePhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceShaderRelaxedExtendedInstructionKHR>();
        case vk::StructureType::ePhysicalDeviceShaderReplicatedCompositesFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceShaderReplicatedCompositesEXT>();
        case vk::StructureType::ePhysicalDeviceShaderSmBuiltinsFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceShaderSMBuiltinsNV>();
        case vk::StructureType::ePhysicalDeviceShaderSubgroupExtendedTypesFeatures:
            return std::make_shared<FeaturePhysicalDeviceShaderSubgroupExtendedTypes>();
        case vk::StructureType::ePhysicalDeviceShaderSubgroupRotateFeatures:
            return std::make_shared<FeaturePhysicalDeviceShaderSubgroupRotate>();
        case vk::StructureType::ePhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceShaderSubgroupUniformControlFlowKHR>();
        case vk::StructureType::ePhysicalDeviceShaderTerminateInvocationFeatures:
            return std::make_shared<FeaturePhysicalDeviceShaderTerminateInvocation>();
        case vk::StructureType::ePhysicalDeviceShaderTileImageFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceShaderTileImageEXT>();
        case vk::StructureType::ePhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceShaderUniformBufferUnsizedArrayEXT>();
        case vk::StructureType::ePhysicalDeviceShaderUntypedPointersFeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceShaderUntypedPointersKHR>();
        case vk::StructureType::ePhysicalDeviceShadingRateImageFeaturesNV:
            return std::make_shared<FeaturePhysicalDeviceShadingRateImageNV>();
        case vk::StructureType::ePhysicalDeviceSubgroupSizeControlFeatures:
            return std::make_shared<FeaturePhysicalDeviceSubgroupSizeControl>();
        case vk::StructureType::ePhysicalDeviceSubpassMergeFeedbackFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceSubpassMergeFeedbackEXT>();
        case vk::StructureType::ePhysicalDeviceSubpassShadingFeaturesHUAWEI:
            return std::make_shared<FeaturePhysicalDeviceSubpassShadingHUAWEI>();
        case vk::StructureType::ePhysicalDeviceSwapchainMaintenance1FeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceSwapchainMaintenance1KHR>();
        case vk::StructureType::ePhysicalDeviceSynchronization2Features:
            return std::make_shared<FeaturePhysicalDeviceSynchronization2>();
        case vk::StructureType::ePhysicalDeviceTensorFeaturesARM:
            return std::make_shared<FeaturePhysicalDeviceTensorARM>();
        case vk::StructureType::ePhysicalDeviceTexelBufferAlignmentFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceTexelBufferAlignmentEXT>();
        case vk::StructureType::ePhysicalDeviceTextureCompressionAstc3DFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceTextureCompressionASTC3DEXT>();
        case vk::StructureType::ePhysicalDeviceTextureCompressionAstcHdrFeatures:
            return std::make_shared<FeaturePhysicalDeviceTextureCompressionASTCHDR>();
        case vk::StructureType::ePhysicalDeviceTileMemoryHeapFeaturesQCOM:
            return std::make_shared<FeaturePhysicalDeviceTileMemoryHeapQCOM>();
        case vk::StructureType::ePhysicalDeviceTilePropertiesFeaturesQCOM:
            return std::make_shared<FeaturePhysicalDeviceTilePropertiesQCOM>();
        case vk::StructureType::ePhysicalDeviceTileShadingFeaturesQCOM:
            return std::make_shared<FeaturePhysicalDeviceTileShadingQCOM>();
        case vk::StructureType::ePhysicalDeviceTimelineSemaphoreFeatures:
            return std::make_shared<FeaturePhysicalDeviceTimelineSemaphore>();
        case vk::StructureType::ePhysicalDeviceTransformFeedbackFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceTransformFeedbackEXT>();
        case vk::StructureType::ePhysicalDeviceUnifiedImageLayoutsFeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceUnifiedImageLayoutsKHR>();
        case vk::StructureType::ePhysicalDeviceUniformBufferStandardLayoutFeatures:
            return std::make_shared<FeaturePhysicalDeviceUniformBufferStandardLayout>();
        case vk::StructureType::ePhysicalDeviceVariablePointersFeatures:
            return std::make_shared<FeaturePhysicalDeviceVariablePointers>();
        case vk::StructureType::ePhysicalDeviceVertexAttributeDivisorFeatures:
            return std::make_shared<FeaturePhysicalDeviceVertexAttributeDivisor>();
        case vk::StructureType::ePhysicalDeviceVertexAttributeRobustnessFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceVertexAttributeRobustnessEXT>();
        case vk::StructureType::ePhysicalDeviceVertexInputDynamicStateFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceVertexInputDynamicStateEXT>();
        case vk::StructureType::ePhysicalDeviceVideoDecodeVp9FeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceVideoDecodeVP9KHR>();
        case vk::StructureType::ePhysicalDeviceVideoEncodeAv1FeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceVideoEncodeAV1KHR>();
        case vk::StructureType::ePhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceVideoEncodeIntraRefreshKHR>();
        case vk::StructureType::ePhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceVideoEncodeQuantizationMapKHR>();
        case vk::StructureType::ePhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE:
            return std::make_shared<FeaturePhysicalDeviceVideoEncodeRgbConversionVALVE>();
        case vk::StructureType::ePhysicalDeviceVideoMaintenance1FeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceVideoMaintenance1KHR>();
        case vk::StructureType::ePhysicalDeviceVideoMaintenance2FeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceVideoMaintenance2KHR>();
        case vk::StructureType::ePhysicalDeviceVulkan11Features:
            return std::make_shared<FeaturePhysicalDeviceVulkan11>();
        case vk::StructureType::ePhysicalDeviceVulkan12Features:
            return std::make_shared<FeaturePhysicalDeviceVulkan12>();
        case vk::StructureType::ePhysicalDeviceVulkan13Features:
            return std::make_shared<FeaturePhysicalDeviceVulkan13>();
        case vk::StructureType::ePhysicalDeviceVulkan14Features:
            return std::make_shared<FeaturePhysicalDeviceVulkan14>();
        case vk::StructureType::ePhysicalDeviceVulkanMemoryModelFeatures:
            return std::make_shared<FeaturePhysicalDeviceVulkanMemoryModel>();
        case vk::StructureType::ePhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR:
            return std::make_shared<FeaturePhysicalDeviceWorkgroupMemoryExplicitLayoutKHR>();
        case vk::StructureType::ePhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceYcbcr2Plane444FormatsEXT>();
        case vk::StructureType::ePhysicalDeviceYcbcrDegammaFeaturesQCOM:
            return std::make_shared<FeaturePhysicalDeviceYcbcrDegammaQCOM>();
        case vk::StructureType::ePhysicalDeviceYcbcrImageArraysFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceYcbcrImageArraysEXT>();
        case vk::StructureType::ePhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT:
            return std::make_shared<FeaturePhysicalDeviceZeroInitializeDeviceMemoryEXT>();
        case vk::StructureType::ePhysicalDeviceZeroInitializeWorkgroupMemoryFeatures:
            return std::make_shared<FeaturePhysicalDeviceZeroInitializeWorkgroupMemory>();
        default:
            return nullptr;
    }
}

std::optional<vk::StructureType> structure_type_for_feature_name(const std::string& name) {
    static const std::unordered_map<std::string, vk::StructureType> name_map = {
        {"PhysicalDevice16BitStorageFeatures", vk::StructureType::ePhysicalDevice16BitStorageFeatures},
        {"16BitStorage", vk::StructureType::ePhysicalDevice16BitStorageFeatures},
        {"PhysicalDevice4444FormatsFeaturesEXT", vk::StructureType::ePhysicalDevice4444FormatsFeaturesEXT},
        {"4444Formats", vk::StructureType::ePhysicalDevice4444FormatsFeaturesEXT},
        {"PhysicalDevice8BitStorageFeatures", vk::StructureType::ePhysicalDevice8BitStorageFeatures},
        {"8BitStorage", vk::StructureType::ePhysicalDevice8BitStorageFeatures},
        {"PhysicalDeviceASTCDecodeFeaturesEXT", vk::StructureType::ePhysicalDeviceAstcDecodeFeaturesEXT},
        {"ASTCDecode", vk::StructureType::ePhysicalDeviceAstcDecodeFeaturesEXT},
        {"PhysicalDeviceAccelerationStructureFeaturesKHR", vk::StructureType::ePhysicalDeviceAccelerationStructureFeaturesKHR},
        {"AccelerationStructure", vk::StructureType::ePhysicalDeviceAccelerationStructureFeaturesKHR},
        {"PhysicalDeviceAddressBindingReportFeaturesEXT", vk::StructureType::ePhysicalDeviceAddressBindingReportFeaturesEXT},
        {"AddressBindingReport", vk::StructureType::ePhysicalDeviceAddressBindingReportFeaturesEXT},
        {"PhysicalDeviceAmigoProfilingFeaturesSEC", vk::StructureType::ePhysicalDeviceAmigoProfilingFeaturesSEC},
        {"AmigoProfiling", vk::StructureType::ePhysicalDeviceAmigoProfilingFeaturesSEC},
        {"PhysicalDeviceAntiLagFeaturesAMD", vk::StructureType::ePhysicalDeviceAntiLagFeaturesAMD},
        {"AntiLag", vk::StructureType::ePhysicalDeviceAntiLagFeaturesAMD},
        {"PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT", vk::StructureType::ePhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT},
        {"AttachmentFeedbackLoopDynamicState", vk::StructureType::ePhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT},
        {"PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT", vk::StructureType::ePhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT},
        {"AttachmentFeedbackLoopLayout", vk::StructureType::ePhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT},
        {"PhysicalDeviceBlendOperationAdvancedFeaturesEXT", vk::StructureType::ePhysicalDeviceBlendOperationAdvancedFeaturesEXT},
        {"BlendOperationAdvanced", vk::StructureType::ePhysicalDeviceBlendOperationAdvancedFeaturesEXT},
        {"PhysicalDeviceBorderColorSwizzleFeaturesEXT", vk::StructureType::ePhysicalDeviceBorderColorSwizzleFeaturesEXT},
        {"BorderColorSwizzle", vk::StructureType::ePhysicalDeviceBorderColorSwizzleFeaturesEXT},
        {"PhysicalDeviceBufferDeviceAddressFeatures", vk::StructureType::ePhysicalDeviceBufferDeviceAddressFeatures},
        {"BufferDeviceAddress", vk::StructureType::ePhysicalDeviceBufferDeviceAddressFeatures},
        {"PhysicalDeviceBufferDeviceAddressFeaturesEXT", vk::StructureType::ePhysicalDeviceBufferDeviceAddressFeaturesEXT},
        {"BufferDeviceAddress", vk::StructureType::ePhysicalDeviceBufferDeviceAddressFeaturesEXT},
        {"PhysicalDeviceClusterAccelerationStructureFeaturesNV", vk::StructureType::ePhysicalDeviceClusterAccelerationStructureFeaturesNV},
        {"ClusterAccelerationStructure", vk::StructureType::ePhysicalDeviceClusterAccelerationStructureFeaturesNV},
        {"PhysicalDeviceClusterCullingShaderFeaturesHUAWEI", vk::StructureType::ePhysicalDeviceClusterCullingShaderFeaturesHUAWEI},
        {"ClusterCullingShader", vk::StructureType::ePhysicalDeviceClusterCullingShaderFeaturesHUAWEI},
        {"PhysicalDeviceCoherentMemoryFeaturesAMD", vk::StructureType::ePhysicalDeviceCoherentMemoryFeaturesAMD},
        {"CoherentMemory", vk::StructureType::ePhysicalDeviceCoherentMemoryFeaturesAMD},
        {"PhysicalDeviceColorWriteEnableFeaturesEXT", vk::StructureType::ePhysicalDeviceColorWriteEnableFeaturesEXT},
        {"ColorWriteEnable", vk::StructureType::ePhysicalDeviceColorWriteEnableFeaturesEXT},
        {"PhysicalDeviceCommandBufferInheritanceFeaturesNV", vk::StructureType::ePhysicalDeviceCommandBufferInheritanceFeaturesNV},
        {"CommandBufferInheritance", vk::StructureType::ePhysicalDeviceCommandBufferInheritanceFeaturesNV},
        {"PhysicalDeviceComputeOccupancyPriorityFeaturesNV", vk::StructureType::ePhysicalDeviceComputeOccupancyPriorityFeaturesNV},
        {"ComputeOccupancyPriority", vk::StructureType::ePhysicalDeviceComputeOccupancyPriorityFeaturesNV},
        {"PhysicalDeviceComputeShaderDerivativesFeaturesKHR", vk::StructureType::ePhysicalDeviceComputeShaderDerivativesFeaturesKHR},
        {"ComputeShaderDerivatives", vk::StructureType::ePhysicalDeviceComputeShaderDerivativesFeaturesKHR},
        {"PhysicalDeviceConditionalRenderingFeaturesEXT", vk::StructureType::ePhysicalDeviceConditionalRenderingFeaturesEXT},
        {"ConditionalRendering", vk::StructureType::ePhysicalDeviceConditionalRenderingFeaturesEXT},
        {"PhysicalDeviceCooperativeMatrix2FeaturesNV", vk::StructureType::ePhysicalDeviceCooperativeMatrix2FeaturesNV},
        {"CooperativeMatrix2", vk::StructureType::ePhysicalDeviceCooperativeMatrix2FeaturesNV},
        {"PhysicalDeviceCooperativeMatrixFeaturesKHR", vk::StructureType::ePhysicalDeviceCooperativeMatrixFeaturesKHR},
        {"CooperativeMatrix", vk::StructureType::ePhysicalDeviceCooperativeMatrixFeaturesKHR},
        {"PhysicalDeviceCooperativeMatrixFeaturesNV", vk::StructureType::ePhysicalDeviceCooperativeMatrixFeaturesNV},
        {"CooperativeMatrix", vk::StructureType::ePhysicalDeviceCooperativeMatrixFeaturesNV},
        {"PhysicalDeviceCooperativeVectorFeaturesNV", vk::StructureType::ePhysicalDeviceCooperativeVectorFeaturesNV},
        {"CooperativeVector", vk::StructureType::ePhysicalDeviceCooperativeVectorFeaturesNV},
        {"PhysicalDeviceCopyMemoryIndirectFeaturesKHR", vk::StructureType::ePhysicalDeviceCopyMemoryIndirectFeaturesKHR},
        {"CopyMemoryIndirect", vk::StructureType::ePhysicalDeviceCopyMemoryIndirectFeaturesKHR},
        {"PhysicalDeviceCopyMemoryIndirectFeaturesNV", vk::StructureType::ePhysicalDeviceCopyMemoryIndirectFeaturesNV},
        {"CopyMemoryIndirect", vk::StructureType::ePhysicalDeviceCopyMemoryIndirectFeaturesNV},
        {"PhysicalDeviceCornerSampledImageFeaturesNV", vk::StructureType::ePhysicalDeviceCornerSampledImageFeaturesNV},
        {"CornerSampledImage", vk::StructureType::ePhysicalDeviceCornerSampledImageFeaturesNV},
        {"PhysicalDeviceCoverageReductionModeFeaturesNV", vk::StructureType::ePhysicalDeviceCoverageReductionModeFeaturesNV},
        {"CoverageReductionMode", vk::StructureType::ePhysicalDeviceCoverageReductionModeFeaturesNV},
        {"PhysicalDeviceCubicClampFeaturesQCOM", vk::StructureType::ePhysicalDeviceCubicClampFeaturesQCOM},
        {"CubicClamp", vk::StructureType::ePhysicalDeviceCubicClampFeaturesQCOM},
        {"PhysicalDeviceCubicWeightsFeaturesQCOM", vk::StructureType::ePhysicalDeviceCubicWeightsFeaturesQCOM},
        {"CubicWeights", vk::StructureType::ePhysicalDeviceCubicWeightsFeaturesQCOM},
        {"PhysicalDeviceCustomBorderColorFeaturesEXT", vk::StructureType::ePhysicalDeviceCustomBorderColorFeaturesEXT},
        {"CustomBorderColor", vk::StructureType::ePhysicalDeviceCustomBorderColorFeaturesEXT},
        {"PhysicalDeviceCustomResolveFeaturesEXT", vk::StructureType::ePhysicalDeviceCustomResolveFeaturesEXT},
        {"CustomResolve", vk::StructureType::ePhysicalDeviceCustomResolveFeaturesEXT},
        {"PhysicalDeviceDataGraphFeaturesARM", vk::StructureType::ePhysicalDeviceDataGraphFeaturesARM},
        {"DataGraph", vk::StructureType::ePhysicalDeviceDataGraphFeaturesARM},
        {"PhysicalDeviceDataGraphModelFeaturesQCOM", vk::StructureType::ePhysicalDeviceDataGraphModelFeaturesQCOM},
        {"DataGraphModel", vk::StructureType::ePhysicalDeviceDataGraphModelFeaturesQCOM},
        {"PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV", vk::StructureType::ePhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV},
        {"DedicatedAllocationImageAliasing", vk::StructureType::ePhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV},
        {"PhysicalDeviceDepthBiasControlFeaturesEXT", vk::StructureType::ePhysicalDeviceDepthBiasControlFeaturesEXT},
        {"DepthBiasControl", vk::StructureType::ePhysicalDeviceDepthBiasControlFeaturesEXT},
        {"PhysicalDeviceDepthClampControlFeaturesEXT", vk::StructureType::ePhysicalDeviceDepthClampControlFeaturesEXT},
        {"DepthClampControl", vk::StructureType::ePhysicalDeviceDepthClampControlFeaturesEXT},
        {"PhysicalDeviceDepthClampZeroOneFeaturesKHR", vk::StructureType::ePhysicalDeviceDepthClampZeroOneFeaturesKHR},
        {"DepthClampZeroOne", vk::StructureType::ePhysicalDeviceDepthClampZeroOneFeaturesKHR},
        {"PhysicalDeviceDepthClipControlFeaturesEXT", vk::StructureType::ePhysicalDeviceDepthClipControlFeaturesEXT},
        {"DepthClipControl", vk::StructureType::ePhysicalDeviceDepthClipControlFeaturesEXT},
        {"PhysicalDeviceDepthClipEnableFeaturesEXT", vk::StructureType::ePhysicalDeviceDepthClipEnableFeaturesEXT},
        {"DepthClipEnable", vk::StructureType::ePhysicalDeviceDepthClipEnableFeaturesEXT},
        {"PhysicalDeviceDescriptorBufferFeaturesEXT", vk::StructureType::ePhysicalDeviceDescriptorBufferFeaturesEXT},
        {"DescriptorBuffer", vk::StructureType::ePhysicalDeviceDescriptorBufferFeaturesEXT},
        {"PhysicalDeviceDescriptorBufferTensorFeaturesARM", vk::StructureType::ePhysicalDeviceDescriptorBufferTensorFeaturesARM},
        {"DescriptorBufferTensor", vk::StructureType::ePhysicalDeviceDescriptorBufferTensorFeaturesARM},
        {"PhysicalDeviceDescriptorIndexingFeatures", vk::StructureType::ePhysicalDeviceDescriptorIndexingFeatures},
        {"DescriptorIndexing", vk::StructureType::ePhysicalDeviceDescriptorIndexingFeatures},
        {"PhysicalDeviceDescriptorPoolOverallocationFeaturesNV", vk::StructureType::ePhysicalDeviceDescriptorPoolOverallocationFeaturesNV},
        {"DescriptorPoolOverallocation", vk::StructureType::ePhysicalDeviceDescriptorPoolOverallocationFeaturesNV},
        {"PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE", vk::StructureType::ePhysicalDeviceDescriptorSetHostMappingFeaturesVALVE},
        {"DescriptorSetHostMapping", vk::StructureType::ePhysicalDeviceDescriptorSetHostMappingFeaturesVALVE},
        {"PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV", vk::StructureType::ePhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV},
        {"DeviceGeneratedCommandsCompute", vk::StructureType::ePhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV},
        {"PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT", vk::StructureType::ePhysicalDeviceDeviceGeneratedCommandsFeaturesEXT},
        {"DeviceGeneratedCommands", vk::StructureType::ePhysicalDeviceDeviceGeneratedCommandsFeaturesEXT},
        {"PhysicalDeviceDeviceGeneratedCommandsFeaturesNV", vk::StructureType::ePhysicalDeviceDeviceGeneratedCommandsFeaturesNV},
        {"DeviceGeneratedCommands", vk::StructureType::ePhysicalDeviceDeviceGeneratedCommandsFeaturesNV},
        {"PhysicalDeviceDeviceMemoryReportFeaturesEXT", vk::StructureType::ePhysicalDeviceDeviceMemoryReportFeaturesEXT},
        {"DeviceMemoryReport", vk::StructureType::ePhysicalDeviceDeviceMemoryReportFeaturesEXT},
        {"PhysicalDeviceDiagnosticsConfigFeaturesNV", vk::StructureType::ePhysicalDeviceDiagnosticsConfigFeaturesNV},
        {"DiagnosticsConfig", vk::StructureType::ePhysicalDeviceDiagnosticsConfigFeaturesNV},
        {"PhysicalDeviceDynamicRenderingFeatures", vk::StructureType::ePhysicalDeviceDynamicRenderingFeatures},
        {"DynamicRendering", vk::StructureType::ePhysicalDeviceDynamicRenderingFeatures},
        {"PhysicalDeviceDynamicRenderingLocalReadFeatures", vk::StructureType::ePhysicalDeviceDynamicRenderingLocalReadFeatures},
        {"DynamicRenderingLocalRead", vk::StructureType::ePhysicalDeviceDynamicRenderingLocalReadFeatures},
        {"PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT", vk::StructureType::ePhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT},
        {"DynamicRenderingUnusedAttachments", vk::StructureType::ePhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT},
        {"PhysicalDeviceExclusiveScissorFeaturesNV", vk::StructureType::ePhysicalDeviceExclusiveScissorFeaturesNV},
        {"ExclusiveScissor", vk::StructureType::ePhysicalDeviceExclusiveScissorFeaturesNV},
        {"PhysicalDeviceExtendedDynamicState2FeaturesEXT", vk::StructureType::ePhysicalDeviceExtendedDynamicState2FeaturesEXT},
        {"ExtendedDynamicState2", vk::StructureType::ePhysicalDeviceExtendedDynamicState2FeaturesEXT},
        {"PhysicalDeviceExtendedDynamicState3FeaturesEXT", vk::StructureType::ePhysicalDeviceExtendedDynamicState3FeaturesEXT},
        {"ExtendedDynamicState3", vk::StructureType::ePhysicalDeviceExtendedDynamicState3FeaturesEXT},
        {"PhysicalDeviceExtendedDynamicStateFeaturesEXT", vk::StructureType::ePhysicalDeviceExtendedDynamicStateFeaturesEXT},
        {"ExtendedDynamicState", vk::StructureType::ePhysicalDeviceExtendedDynamicStateFeaturesEXT},
        {"PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV", vk::StructureType::ePhysicalDeviceExtendedSparseAddressSpaceFeaturesNV},
        {"ExtendedSparseAddressSpace", vk::StructureType::ePhysicalDeviceExtendedSparseAddressSpaceFeaturesNV},
        {"PhysicalDeviceExternalMemoryRDMAFeaturesNV", vk::StructureType::ePhysicalDeviceExternalMemoryRdmaFeaturesNV},
        {"ExternalMemoryRDMA", vk::StructureType::ePhysicalDeviceExternalMemoryRdmaFeaturesNV},
        {"PhysicalDeviceFaultFeaturesEXT", vk::StructureType::ePhysicalDeviceFaultFeaturesEXT},
        {"Fault", vk::StructureType::ePhysicalDeviceFaultFeaturesEXT},
        {"PhysicalDeviceFeatures2", vk::StructureType::ePhysicalDeviceFeatures2},
        {"Vulkan10", vk::StructureType::ePhysicalDeviceFeatures2},
        {"PhysicalDeviceFormatPackFeaturesARM", vk::StructureType::ePhysicalDeviceFormatPackFeaturesARM},
        {"FormatPack", vk::StructureType::ePhysicalDeviceFormatPackFeaturesARM},
        {"PhysicalDeviceFragmentDensityMap2FeaturesEXT", vk::StructureType::ePhysicalDeviceFragmentDensityMap2FeaturesEXT},
        {"FragmentDensityMap2", vk::StructureType::ePhysicalDeviceFragmentDensityMap2FeaturesEXT},
        {"PhysicalDeviceFragmentDensityMapFeaturesEXT", vk::StructureType::ePhysicalDeviceFragmentDensityMapFeaturesEXT},
        {"FragmentDensityMap", vk::StructureType::ePhysicalDeviceFragmentDensityMapFeaturesEXT},
        {"PhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE", vk::StructureType::ePhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE},
        {"FragmentDensityMapLayered", vk::StructureType::ePhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE},
        {"PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT", vk::StructureType::ePhysicalDeviceFragmentDensityMapOffsetFeaturesEXT},
        {"FragmentDensityMapOffset", vk::StructureType::ePhysicalDeviceFragmentDensityMapOffsetFeaturesEXT},
        {"PhysicalDeviceFragmentShaderBarycentricFeaturesKHR", vk::StructureType::ePhysicalDeviceFragmentShaderBarycentricFeaturesKHR},
        {"FragmentShaderBarycentric", vk::StructureType::ePhysicalDeviceFragmentShaderBarycentricFeaturesKHR},
        {"PhysicalDeviceFragmentShaderInterlockFeaturesEXT", vk::StructureType::ePhysicalDeviceFragmentShaderInterlockFeaturesEXT},
        {"FragmentShaderInterlock", vk::StructureType::ePhysicalDeviceFragmentShaderInterlockFeaturesEXT},
        {"PhysicalDeviceFragmentShadingRateEnumsFeaturesNV", vk::StructureType::ePhysicalDeviceFragmentShadingRateEnumsFeaturesNV},
        {"FragmentShadingRateEnums", vk::StructureType::ePhysicalDeviceFragmentShadingRateEnumsFeaturesNV},
        {"PhysicalDeviceFragmentShadingRateFeaturesKHR", vk::StructureType::ePhysicalDeviceFragmentShadingRateFeaturesKHR},
        {"FragmentShadingRate", vk::StructureType::ePhysicalDeviceFragmentShadingRateFeaturesKHR},
        {"PhysicalDeviceFrameBoundaryFeaturesEXT", vk::StructureType::ePhysicalDeviceFrameBoundaryFeaturesEXT},
        {"FrameBoundary", vk::StructureType::ePhysicalDeviceFrameBoundaryFeaturesEXT},
        {"PhysicalDeviceGlobalPriorityQueryFeatures", vk::StructureType::ePhysicalDeviceGlobalPriorityQueryFeatures},
        {"GlobalPriorityQuery", vk::StructureType::ePhysicalDeviceGlobalPriorityQueryFeatures},
        {"PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT", vk::StructureType::ePhysicalDeviceGraphicsPipelineLibraryFeaturesEXT},
        {"GraphicsPipelineLibrary", vk::StructureType::ePhysicalDeviceGraphicsPipelineLibraryFeaturesEXT},
        {"PhysicalDeviceHdrVividFeaturesHUAWEI", vk::StructureType::ePhysicalDeviceHdrVividFeaturesHUAWEI},
        {"HdrVivid", vk::StructureType::ePhysicalDeviceHdrVividFeaturesHUAWEI},
        {"PhysicalDeviceHostImageCopyFeatures", vk::StructureType::ePhysicalDeviceHostImageCopyFeatures},
        {"HostImageCopy", vk::StructureType::ePhysicalDeviceHostImageCopyFeatures},
        {"PhysicalDeviceHostQueryResetFeatures", vk::StructureType::ePhysicalDeviceHostQueryResetFeatures},
        {"HostQueryReset", vk::StructureType::ePhysicalDeviceHostQueryResetFeatures},
        {"PhysicalDeviceImage2DViewOf3DFeaturesEXT", vk::StructureType::ePhysicalDeviceImage2DViewOf3DFeaturesEXT},
        {"Image2DViewOf3D", vk::StructureType::ePhysicalDeviceImage2DViewOf3DFeaturesEXT},
        {"PhysicalDeviceImageAlignmentControlFeaturesMESA", vk::StructureType::ePhysicalDeviceImageAlignmentControlFeaturesMESA},
        {"ImageAlignmentControl", vk::StructureType::ePhysicalDeviceImageAlignmentControlFeaturesMESA},
        {"PhysicalDeviceImageCompressionControlFeaturesEXT", vk::StructureType::ePhysicalDeviceImageCompressionControlFeaturesEXT},
        {"ImageCompressionControl", vk::StructureType::ePhysicalDeviceImageCompressionControlFeaturesEXT},
        {"PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT", vk::StructureType::ePhysicalDeviceImageCompressionControlSwapchainFeaturesEXT},
        {"ImageCompressionControlSwapchain", vk::StructureType::ePhysicalDeviceImageCompressionControlSwapchainFeaturesEXT},
        {"PhysicalDeviceImageProcessing2FeaturesQCOM", vk::StructureType::ePhysicalDeviceImageProcessing2FeaturesQCOM},
        {"ImageProcessing2", vk::StructureType::ePhysicalDeviceImageProcessing2FeaturesQCOM},
        {"PhysicalDeviceImageProcessingFeaturesQCOM", vk::StructureType::ePhysicalDeviceImageProcessingFeaturesQCOM},
        {"ImageProcessing", vk::StructureType::ePhysicalDeviceImageProcessingFeaturesQCOM},
        {"PhysicalDeviceImageRobustnessFeatures", vk::StructureType::ePhysicalDeviceImageRobustnessFeatures},
        {"ImageRobustness", vk::StructureType::ePhysicalDeviceImageRobustnessFeatures},
        {"PhysicalDeviceImageSlicedViewOf3DFeaturesEXT", vk::StructureType::ePhysicalDeviceImageSlicedViewOf3DFeaturesEXT},
        {"ImageSlicedViewOf3D", vk::StructureType::ePhysicalDeviceImageSlicedViewOf3DFeaturesEXT},
        {"PhysicalDeviceImageViewMinLodFeaturesEXT", vk::StructureType::ePhysicalDeviceImageViewMinLodFeaturesEXT},
        {"ImageViewMinLod", vk::StructureType::ePhysicalDeviceImageViewMinLodFeaturesEXT},
        {"PhysicalDeviceImagelessFramebufferFeatures", vk::StructureType::ePhysicalDeviceImagelessFramebufferFeatures},
        {"ImagelessFramebuffer", vk::StructureType::ePhysicalDeviceImagelessFramebufferFeatures},
        {"PhysicalDeviceIndexTypeUint8Features", vk::StructureType::ePhysicalDeviceIndexTypeUint8Features},
        {"IndexTypeUint8", vk::StructureType::ePhysicalDeviceIndexTypeUint8Features},
        {"PhysicalDeviceInheritedViewportScissorFeaturesNV", vk::StructureType::ePhysicalDeviceInheritedViewportScissorFeaturesNV},
        {"InheritedViewportScissor", vk::StructureType::ePhysicalDeviceInheritedViewportScissorFeaturesNV},
        {"PhysicalDeviceInlineUniformBlockFeatures", vk::StructureType::ePhysicalDeviceInlineUniformBlockFeatures},
        {"InlineUniformBlock", vk::StructureType::ePhysicalDeviceInlineUniformBlockFeatures},
        {"PhysicalDeviceInvocationMaskFeaturesHUAWEI", vk::StructureType::ePhysicalDeviceInvocationMaskFeaturesHUAWEI},
        {"InvocationMask", vk::StructureType::ePhysicalDeviceInvocationMaskFeaturesHUAWEI},
        {"PhysicalDeviceLegacyDitheringFeaturesEXT", vk::StructureType::ePhysicalDeviceLegacyDitheringFeaturesEXT},
        {"LegacyDithering", vk::StructureType::ePhysicalDeviceLegacyDitheringFeaturesEXT},
        {"PhysicalDeviceLegacyVertexAttributesFeaturesEXT", vk::StructureType::ePhysicalDeviceLegacyVertexAttributesFeaturesEXT},
        {"LegacyVertexAttributes", vk::StructureType::ePhysicalDeviceLegacyVertexAttributesFeaturesEXT},
        {"PhysicalDeviceLineRasterizationFeatures", vk::StructureType::ePhysicalDeviceLineRasterizationFeatures},
        {"LineRasterization", vk::StructureType::ePhysicalDeviceLineRasterizationFeatures},
        {"PhysicalDeviceLinearColorAttachmentFeaturesNV", vk::StructureType::ePhysicalDeviceLinearColorAttachmentFeaturesNV},
        {"LinearColorAttachment", vk::StructureType::ePhysicalDeviceLinearColorAttachmentFeaturesNV},
        {"PhysicalDeviceMaintenance10FeaturesKHR", vk::StructureType::ePhysicalDeviceMaintenance10FeaturesKHR},
        {"Maintenance10", vk::StructureType::ePhysicalDeviceMaintenance10FeaturesKHR},
        {"PhysicalDeviceMaintenance4Features", vk::StructureType::ePhysicalDeviceMaintenance4Features},
        {"Maintenance4", vk::StructureType::ePhysicalDeviceMaintenance4Features},
        {"PhysicalDeviceMaintenance5Features", vk::StructureType::ePhysicalDeviceMaintenance5Features},
        {"Maintenance5", vk::StructureType::ePhysicalDeviceMaintenance5Features},
        {"PhysicalDeviceMaintenance6Features", vk::StructureType::ePhysicalDeviceMaintenance6Features},
        {"Maintenance6", vk::StructureType::ePhysicalDeviceMaintenance6Features},
        {"PhysicalDeviceMaintenance7FeaturesKHR", vk::StructureType::ePhysicalDeviceMaintenance7FeaturesKHR},
        {"Maintenance7", vk::StructureType::ePhysicalDeviceMaintenance7FeaturesKHR},
        {"PhysicalDeviceMaintenance8FeaturesKHR", vk::StructureType::ePhysicalDeviceMaintenance8FeaturesKHR},
        {"Maintenance8", vk::StructureType::ePhysicalDeviceMaintenance8FeaturesKHR},
        {"PhysicalDeviceMaintenance9FeaturesKHR", vk::StructureType::ePhysicalDeviceMaintenance9FeaturesKHR},
        {"Maintenance9", vk::StructureType::ePhysicalDeviceMaintenance9FeaturesKHR},
        {"PhysicalDeviceMapMemoryPlacedFeaturesEXT", vk::StructureType::ePhysicalDeviceMapMemoryPlacedFeaturesEXT},
        {"MapMemoryPlaced", vk::StructureType::ePhysicalDeviceMapMemoryPlacedFeaturesEXT},
        {"PhysicalDeviceMemoryDecompressionFeaturesEXT", vk::StructureType::ePhysicalDeviceMemoryDecompressionFeaturesEXT},
        {"MemoryDecompression", vk::StructureType::ePhysicalDeviceMemoryDecompressionFeaturesEXT},
        {"PhysicalDeviceMemoryPriorityFeaturesEXT", vk::StructureType::ePhysicalDeviceMemoryPriorityFeaturesEXT},
        {"MemoryPriority", vk::StructureType::ePhysicalDeviceMemoryPriorityFeaturesEXT},
        {"PhysicalDeviceMeshShaderFeaturesEXT", vk::StructureType::ePhysicalDeviceMeshShaderFeaturesEXT},
        {"MeshShader", vk::StructureType::ePhysicalDeviceMeshShaderFeaturesEXT},
        {"PhysicalDeviceMeshShaderFeaturesNV", vk::StructureType::ePhysicalDeviceMeshShaderFeaturesNV},
        {"MeshShader", vk::StructureType::ePhysicalDeviceMeshShaderFeaturesNV},
        {"PhysicalDeviceMultiDrawFeaturesEXT", vk::StructureType::ePhysicalDeviceMultiDrawFeaturesEXT},
        {"MultiDraw", vk::StructureType::ePhysicalDeviceMultiDrawFeaturesEXT},
        {"PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT", vk::StructureType::ePhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT},
        {"MultisampledRenderToSingleSampled", vk::StructureType::ePhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT},
        {"PhysicalDeviceMultiviewFeatures", vk::StructureType::ePhysicalDeviceMultiviewFeatures},
        {"Multiview", vk::StructureType::ePhysicalDeviceMultiviewFeatures},
        {"PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM", vk::StructureType::ePhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM},
        {"MultiviewPerViewRenderAreas", vk::StructureType::ePhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM},
        {"PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM", vk::StructureType::ePhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM},
        {"MultiviewPerViewViewports", vk::StructureType::ePhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM},
        {"PhysicalDeviceMutableDescriptorTypeFeaturesEXT", vk::StructureType::ePhysicalDeviceMutableDescriptorTypeFeaturesEXT},
        {"MutableDescriptorType", vk::StructureType::ePhysicalDeviceMutableDescriptorTypeFeaturesEXT},
        {"PhysicalDeviceNestedCommandBufferFeaturesEXT", vk::StructureType::ePhysicalDeviceNestedCommandBufferFeaturesEXT},
        {"NestedCommandBuffer", vk::StructureType::ePhysicalDeviceNestedCommandBufferFeaturesEXT},
        {"PhysicalDeviceNonSeamlessCubeMapFeaturesEXT", vk::StructureType::ePhysicalDeviceNonSeamlessCubeMapFeaturesEXT},
        {"NonSeamlessCubeMap", vk::StructureType::ePhysicalDeviceNonSeamlessCubeMapFeaturesEXT},
        {"PhysicalDeviceOpacityMicromapFeaturesEXT", vk::StructureType::ePhysicalDeviceOpacityMicromapFeaturesEXT},
        {"OpacityMicromap", vk::StructureType::ePhysicalDeviceOpacityMicromapFeaturesEXT},
        {"PhysicalDeviceOpticalFlowFeaturesNV", vk::StructureType::ePhysicalDeviceOpticalFlowFeaturesNV},
        {"OpticalFlow", vk::StructureType::ePhysicalDeviceOpticalFlowFeaturesNV},
        {"PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT", vk::StructureType::ePhysicalDevicePageableDeviceLocalMemoryFeaturesEXT},
        {"PageableDeviceLocalMemory", vk::StructureType::ePhysicalDevicePageableDeviceLocalMemoryFeaturesEXT},
        {"PhysicalDevicePartitionedAccelerationStructureFeaturesNV", vk::StructureType::ePhysicalDevicePartitionedAccelerationStructureFeaturesNV},
        {"PartitionedAccelerationStructure", vk::StructureType::ePhysicalDevicePartitionedAccelerationStructureFeaturesNV},
        {"PhysicalDevicePerStageDescriptorSetFeaturesNV", vk::StructureType::ePhysicalDevicePerStageDescriptorSetFeaturesNV},
        {"PerStageDescriptorSet", vk::StructureType::ePhysicalDevicePerStageDescriptorSetFeaturesNV},
        {"PhysicalDevicePerformanceCountersByRegionFeaturesARM", vk::StructureType::ePhysicalDevicePerformanceCountersByRegionFeaturesARM},
        {"PerformanceCountersByRegion", vk::StructureType::ePhysicalDevicePerformanceCountersByRegionFeaturesARM},
        {"PhysicalDevicePerformanceQueryFeaturesKHR", vk::StructureType::ePhysicalDevicePerformanceQueryFeaturesKHR},
        {"PerformanceQuery", vk::StructureType::ePhysicalDevicePerformanceQueryFeaturesKHR},
        {"PhysicalDevicePipelineBinaryFeaturesKHR", vk::StructureType::ePhysicalDevicePipelineBinaryFeaturesKHR},
        {"PipelineBinary", vk::StructureType::ePhysicalDevicePipelineBinaryFeaturesKHR},
        {"PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC", vk::StructureType::ePhysicalDevicePipelineCacheIncrementalModeFeaturesSEC},
        {"PipelineCacheIncrementalMode", vk::StructureType::ePhysicalDevicePipelineCacheIncrementalModeFeaturesSEC},
        {"PhysicalDevicePipelineCreationCacheControlFeatures", vk::StructureType::ePhysicalDevicePipelineCreationCacheControlFeatures},
        {"PipelineCreationCacheControl", vk::StructureType::ePhysicalDevicePipelineCreationCacheControlFeatures},
        {"PhysicalDevicePipelineExecutablePropertiesFeaturesKHR", vk::StructureType::ePhysicalDevicePipelineExecutablePropertiesFeaturesKHR},
        {"PipelineExecutableProperties", vk::StructureType::ePhysicalDevicePipelineExecutablePropertiesFeaturesKHR},
        {"PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT", vk::StructureType::ePhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT},
        {"PipelineLibraryGroupHandles", vk::StructureType::ePhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT},
        {"PhysicalDevicePipelineOpacityMicromapFeaturesARM", vk::StructureType::ePhysicalDevicePipelineOpacityMicromapFeaturesARM},
        {"PipelineOpacityMicromap", vk::StructureType::ePhysicalDevicePipelineOpacityMicromapFeaturesARM},
        {"PhysicalDevicePipelinePropertiesFeaturesEXT", vk::StructureType::ePhysicalDevicePipelinePropertiesFeaturesEXT},
        {"PipelineProperties", vk::StructureType::ePhysicalDevicePipelinePropertiesFeaturesEXT},
        {"PhysicalDevicePipelineProtectedAccessFeatures", vk::StructureType::ePhysicalDevicePipelineProtectedAccessFeatures},
        {"PipelineProtectedAccess", vk::StructureType::ePhysicalDevicePipelineProtectedAccessFeatures},
        {"PhysicalDevicePipelineRobustnessFeatures", vk::StructureType::ePhysicalDevicePipelineRobustnessFeatures},
        {"PipelineRobustness", vk::StructureType::ePhysicalDevicePipelineRobustnessFeatures},
        {"PhysicalDevicePresentBarrierFeaturesNV", vk::StructureType::ePhysicalDevicePresentBarrierFeaturesNV},
        {"PresentBarrier", vk::StructureType::ePhysicalDevicePresentBarrierFeaturesNV},
        {"PhysicalDevicePresentId2FeaturesKHR", vk::StructureType::ePhysicalDevicePresentId2FeaturesKHR},
        {"PresentId2", vk::StructureType::ePhysicalDevicePresentId2FeaturesKHR},
        {"PhysicalDevicePresentIdFeaturesKHR", vk::StructureType::ePhysicalDevicePresentIdFeaturesKHR},
        {"PresentId", vk::StructureType::ePhysicalDevicePresentIdFeaturesKHR},
        {"PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR", vk::StructureType::ePhysicalDevicePresentModeFifoLatestReadyFeaturesKHR},
        {"PresentModeFifoLatestReady", vk::StructureType::ePhysicalDevicePresentModeFifoLatestReadyFeaturesKHR},
        {"PhysicalDevicePresentTimingFeaturesEXT", vk::StructureType::ePhysicalDevicePresentTimingFeaturesEXT},
        {"PresentTiming", vk::StructureType::ePhysicalDevicePresentTimingFeaturesEXT},
        {"PhysicalDevicePresentWait2FeaturesKHR", vk::StructureType::ePhysicalDevicePresentWait2FeaturesKHR},
        {"PresentWait2", vk::StructureType::ePhysicalDevicePresentWait2FeaturesKHR},
        {"PhysicalDevicePresentWaitFeaturesKHR", vk::StructureType::ePhysicalDevicePresentWaitFeaturesKHR},
        {"PresentWait", vk::StructureType::ePhysicalDevicePresentWaitFeaturesKHR},
        {"PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT", vk::StructureType::ePhysicalDevicePrimitiveTopologyListRestartFeaturesEXT},
        {"PrimitiveTopologyListRestart", vk::StructureType::ePhysicalDevicePrimitiveTopologyListRestartFeaturesEXT},
        {"PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT", vk::StructureType::ePhysicalDevicePrimitivesGeneratedQueryFeaturesEXT},
        {"PrimitivesGeneratedQuery", vk::StructureType::ePhysicalDevicePrimitivesGeneratedQueryFeaturesEXT},
        {"PhysicalDevicePrivateDataFeatures", vk::StructureType::ePhysicalDevicePrivateDataFeatures},
        {"PrivateData", vk::StructureType::ePhysicalDevicePrivateDataFeatures},
        {"PhysicalDeviceProtectedMemoryFeatures", vk::StructureType::ePhysicalDeviceProtectedMemoryFeatures},
        {"ProtectedMemory", vk::StructureType::ePhysicalDeviceProtectedMemoryFeatures},
        {"PhysicalDeviceProvokingVertexFeaturesEXT", vk::StructureType::ePhysicalDeviceProvokingVertexFeaturesEXT},
        {"ProvokingVertex", vk::StructureType::ePhysicalDeviceProvokingVertexFeaturesEXT},
        {"PhysicalDeviceRGBA10X6FormatsFeaturesEXT", vk::StructureType::ePhysicalDeviceRgba10X6FormatsFeaturesEXT},
        {"RGBA10X6Formats", vk::StructureType::ePhysicalDeviceRgba10X6FormatsFeaturesEXT},
        {"PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT", vk::StructureType::ePhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT},
        {"RasterizationOrderAttachmentAccess", vk::StructureType::ePhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT},
        {"PhysicalDeviceRawAccessChainsFeaturesNV", vk::StructureType::ePhysicalDeviceRawAccessChainsFeaturesNV},
        {"RawAccessChains", vk::StructureType::ePhysicalDeviceRawAccessChainsFeaturesNV},
        {"PhysicalDeviceRayQueryFeaturesKHR", vk::StructureType::ePhysicalDeviceRayQueryFeaturesKHR},
        {"RayQuery", vk::StructureType::ePhysicalDeviceRayQueryFeaturesKHR},
        {"PhysicalDeviceRayTracingInvocationReorderFeaturesEXT", vk::StructureType::ePhysicalDeviceRayTracingInvocationReorderFeaturesEXT},
        {"RayTracingInvocationReorder", vk::StructureType::ePhysicalDeviceRayTracingInvocationReorderFeaturesEXT},
        {"PhysicalDeviceRayTracingInvocationReorderFeaturesNV", vk::StructureType::ePhysicalDeviceRayTracingInvocationReorderFeaturesNV},
        {"RayTracingInvocationReorder", vk::StructureType::ePhysicalDeviceRayTracingInvocationReorderFeaturesNV},
        {"PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV", vk::StructureType::ePhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV},
        {"RayTracingLinearSweptSpheres", vk::StructureType::ePhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV},
        {"PhysicalDeviceRayTracingMaintenance1FeaturesKHR", vk::StructureType::ePhysicalDeviceRayTracingMaintenance1FeaturesKHR},
        {"RayTracingMaintenance1", vk::StructureType::ePhysicalDeviceRayTracingMaintenance1FeaturesKHR},
        {"PhysicalDeviceRayTracingMotionBlurFeaturesNV", vk::StructureType::ePhysicalDeviceRayTracingMotionBlurFeaturesNV},
        {"RayTracingMotionBlur", vk::StructureType::ePhysicalDeviceRayTracingMotionBlurFeaturesNV},
        {"PhysicalDeviceRayTracingPipelineFeaturesKHR", vk::StructureType::ePhysicalDeviceRayTracingPipelineFeaturesKHR},
        {"RayTracingPipeline", vk::StructureType::ePhysicalDeviceRayTracingPipelineFeaturesKHR},
        {"PhysicalDeviceRayTracingPositionFetchFeaturesKHR", vk::StructureType::ePhysicalDeviceRayTracingPositionFetchFeaturesKHR},
        {"RayTracingPositionFetch", vk::StructureType::ePhysicalDeviceRayTracingPositionFetchFeaturesKHR},
        {"PhysicalDeviceRayTracingValidationFeaturesNV", vk::StructureType::ePhysicalDeviceRayTracingValidationFeaturesNV},
        {"RayTracingValidation", vk::StructureType::ePhysicalDeviceRayTracingValidationFeaturesNV},
        {"PhysicalDeviceRelaxedLineRasterizationFeaturesIMG", vk::StructureType::ePhysicalDeviceRelaxedLineRasterizationFeaturesIMG},
        {"RelaxedLineRasterization", vk::StructureType::ePhysicalDeviceRelaxedLineRasterizationFeaturesIMG},
        {"PhysicalDeviceRenderPassStripedFeaturesARM", vk::StructureType::ePhysicalDeviceRenderPassStripedFeaturesARM},
        {"RenderPassStriped", vk::StructureType::ePhysicalDeviceRenderPassStripedFeaturesARM},
        {"PhysicalDeviceRepresentativeFragmentTestFeaturesNV", vk::StructureType::ePhysicalDeviceRepresentativeFragmentTestFeaturesNV},
        {"RepresentativeFragmentTest", vk::StructureType::ePhysicalDeviceRepresentativeFragmentTestFeaturesNV},
        {"PhysicalDeviceRobustness2FeaturesKHR", vk::StructureType::ePhysicalDeviceRobustness2FeaturesKHR},
        {"Robustness2", vk::StructureType::ePhysicalDeviceRobustness2FeaturesKHR},
        {"PhysicalDeviceSamplerYcbcrConversionFeatures", vk::StructureType::ePhysicalDeviceSamplerYcbcrConversionFeatures},
        {"SamplerYcbcrConversion", vk::StructureType::ePhysicalDeviceSamplerYcbcrConversionFeatures},
        {"PhysicalDeviceScalarBlockLayoutFeatures", vk::StructureType::ePhysicalDeviceScalarBlockLayoutFeatures},
        {"ScalarBlockLayout", vk::StructureType::ePhysicalDeviceScalarBlockLayoutFeatures},
        {"PhysicalDeviceSchedulingControlsFeaturesARM", vk::StructureType::ePhysicalDeviceSchedulingControlsFeaturesARM},
        {"SchedulingControls", vk::StructureType::ePhysicalDeviceSchedulingControlsFeaturesARM},
        {"PhysicalDeviceSeparateDepthStencilLayoutsFeatures", vk::StructureType::ePhysicalDeviceSeparateDepthStencilLayoutsFeatures},
        {"SeparateDepthStencilLayouts", vk::StructureType::ePhysicalDeviceSeparateDepthStencilLayoutsFeatures},
        {"PhysicalDeviceShader64BitIndexingFeaturesEXT", vk::StructureType::ePhysicalDeviceShader64BitIndexingFeaturesEXT},
        {"Shader64BitIndexing", vk::StructureType::ePhysicalDeviceShader64BitIndexingFeaturesEXT},
        {"PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV", vk::StructureType::ePhysicalDeviceShaderAtomicFloat16VectorFeaturesNV},
        {"ShaderAtomicFloat16Vector", vk::StructureType::ePhysicalDeviceShaderAtomicFloat16VectorFeaturesNV},
        {"PhysicalDeviceShaderAtomicFloat2FeaturesEXT", vk::StructureType::ePhysicalDeviceShaderAtomicFloat2FeaturesEXT},
        {"ShaderAtomicFloat2", vk::StructureType::ePhysicalDeviceShaderAtomicFloat2FeaturesEXT},
        {"PhysicalDeviceShaderAtomicFloatFeaturesEXT", vk::StructureType::ePhysicalDeviceShaderAtomicFloatFeaturesEXT},
        {"ShaderAtomicFloat", vk::StructureType::ePhysicalDeviceShaderAtomicFloatFeaturesEXT},
        {"PhysicalDeviceShaderAtomicInt64Features", vk::StructureType::ePhysicalDeviceShaderAtomicInt64Features},
        {"ShaderAtomicInt64", vk::StructureType::ePhysicalDeviceShaderAtomicInt64Features},
        {"PhysicalDeviceShaderBfloat16FeaturesKHR", vk::StructureType::ePhysicalDeviceShaderBfloat16FeaturesKHR},
        {"ShaderBfloat16", vk::StructureType::ePhysicalDeviceShaderBfloat16FeaturesKHR},
        {"PhysicalDeviceShaderClockFeaturesKHR", vk::StructureType::ePhysicalDeviceShaderClockFeaturesKHR},
        {"ShaderClock", vk::StructureType::ePhysicalDeviceShaderClockFeaturesKHR},
        {"PhysicalDeviceShaderCoreBuiltinsFeaturesARM", vk::StructureType::ePhysicalDeviceShaderCoreBuiltinsFeaturesARM},
        {"ShaderCoreBuiltins", vk::StructureType::ePhysicalDeviceShaderCoreBuiltinsFeaturesARM},
        {"PhysicalDeviceShaderDemoteToHelperInvocationFeatures", vk::StructureType::ePhysicalDeviceShaderDemoteToHelperInvocationFeatures},
        {"ShaderDemoteToHelperInvocation", vk::StructureType::ePhysicalDeviceShaderDemoteToHelperInvocationFeatures},
        {"PhysicalDeviceShaderDrawParametersFeatures", vk::StructureType::ePhysicalDeviceShaderDrawParametersFeatures},
        {"ShaderDrawParameters", vk::StructureType::ePhysicalDeviceShaderDrawParametersFeatures},
        {"PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD", vk::StructureType::ePhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD},
        {"ShaderEarlyAndLateFragmentTests", vk::StructureType::ePhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD},
        {"PhysicalDeviceShaderExpectAssumeFeatures", vk::StructureType::ePhysicalDeviceShaderExpectAssumeFeatures},
        {"ShaderExpectAssume", vk::StructureType::ePhysicalDeviceShaderExpectAssumeFeatures},
        {"PhysicalDeviceShaderFloat16Int8Features", vk::StructureType::ePhysicalDeviceShaderFloat16Int8Features},
        {"ShaderFloat16Int8", vk::StructureType::ePhysicalDeviceShaderFloat16Int8Features},
        {"PhysicalDeviceShaderFloat8FeaturesEXT", vk::StructureType::ePhysicalDeviceShaderFloat8FeaturesEXT},
        {"ShaderFloat8", vk::StructureType::ePhysicalDeviceShaderFloat8FeaturesEXT},
        {"PhysicalDeviceShaderFloatControls2Features", vk::StructureType::ePhysicalDeviceShaderFloatControls2Features},
        {"ShaderFloatControls2", vk::StructureType::ePhysicalDeviceShaderFloatControls2Features},
        {"PhysicalDeviceShaderFmaFeaturesKHR", vk::StructureType::ePhysicalDeviceShaderFmaFeaturesKHR},
        {"ShaderFma", vk::StructureType::ePhysicalDeviceShaderFmaFeaturesKHR},
        {"PhysicalDeviceShaderImageAtomicInt64FeaturesEXT", vk::StructureType::ePhysicalDeviceShaderImageAtomicInt64FeaturesEXT},
        {"ShaderImageAtomicInt64", vk::StructureType::ePhysicalDeviceShaderImageAtomicInt64FeaturesEXT},
        {"PhysicalDeviceShaderImageFootprintFeaturesNV", vk::StructureType::ePhysicalDeviceShaderImageFootprintFeaturesNV},
        {"ShaderImageFootprint", vk::StructureType::ePhysicalDeviceShaderImageFootprintFeaturesNV},
        {"PhysicalDeviceShaderIntegerDotProductFeatures", vk::StructureType::ePhysicalDeviceShaderIntegerDotProductFeatures},
        {"ShaderIntegerDotProduct", vk::StructureType::ePhysicalDeviceShaderIntegerDotProductFeatures},
        {"PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL", vk::StructureType::ePhysicalDeviceShaderIntegerFunctions2FeaturesINTEL},
        {"ShaderIntegerFunctions2", vk::StructureType::ePhysicalDeviceShaderIntegerFunctions2FeaturesINTEL},
        {"PhysicalDeviceShaderLongVectorFeaturesEXT", vk::StructureType::ePhysicalDeviceShaderLongVectorFeaturesEXT},
        {"ShaderLongVector", vk::StructureType::ePhysicalDeviceShaderLongVectorFeaturesEXT},
        {"PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR", vk::StructureType::ePhysicalDeviceShaderMaximalReconvergenceFeaturesKHR},
        {"ShaderMaximalReconvergence", vk::StructureType::ePhysicalDeviceShaderMaximalReconvergenceFeaturesKHR},
        {"PhysicalDeviceShaderModuleIdentifierFeaturesEXT", vk::StructureType::ePhysicalDeviceShaderModuleIdentifierFeaturesEXT},
        {"ShaderModuleIdentifier", vk::StructureType::ePhysicalDeviceShaderModuleIdentifierFeaturesEXT},
        {"PhysicalDeviceShaderObjectFeaturesEXT", vk::StructureType::ePhysicalDeviceShaderObjectFeaturesEXT},
        {"ShaderObject", vk::StructureType::ePhysicalDeviceShaderObjectFeaturesEXT},
        {"PhysicalDeviceShaderQuadControlFeaturesKHR", vk::StructureType::ePhysicalDeviceShaderQuadControlFeaturesKHR},
        {"ShaderQuadControl", vk::StructureType::ePhysicalDeviceShaderQuadControlFeaturesKHR},
        {"PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR", vk::StructureType::ePhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR},
        {"ShaderRelaxedExtendedInstruction", vk::StructureType::ePhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR},
        {"PhysicalDeviceShaderReplicatedCompositesFeaturesEXT", vk::StructureType::ePhysicalDeviceShaderReplicatedCompositesFeaturesEXT},
        {"ShaderReplicatedComposites", vk::StructureType::ePhysicalDeviceShaderReplicatedCompositesFeaturesEXT},
        {"PhysicalDeviceShaderSMBuiltinsFeaturesNV", vk::StructureType::ePhysicalDeviceShaderSmBuiltinsFeaturesNV},
        {"ShaderSMBuiltins", vk::StructureType::ePhysicalDeviceShaderSmBuiltinsFeaturesNV},
        {"PhysicalDeviceShaderSubgroupExtendedTypesFeatures", vk::StructureType::ePhysicalDeviceShaderSubgroupExtendedTypesFeatures},
        {"ShaderSubgroupExtendedTypes", vk::StructureType::ePhysicalDeviceShaderSubgroupExtendedTypesFeatures},
        {"PhysicalDeviceShaderSubgroupRotateFeatures", vk::StructureType::ePhysicalDeviceShaderSubgroupRotateFeatures},
        {"ShaderSubgroupRotate", vk::StructureType::ePhysicalDeviceShaderSubgroupRotateFeatures},
        {"PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR", vk::StructureType::ePhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR},
        {"ShaderSubgroupUniformControlFlow", vk::StructureType::ePhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR},
        {"PhysicalDeviceShaderTerminateInvocationFeatures", vk::StructureType::ePhysicalDeviceShaderTerminateInvocationFeatures},
        {"ShaderTerminateInvocation", vk::StructureType::ePhysicalDeviceShaderTerminateInvocationFeatures},
        {"PhysicalDeviceShaderTileImageFeaturesEXT", vk::StructureType::ePhysicalDeviceShaderTileImageFeaturesEXT},
        {"ShaderTileImage", vk::StructureType::ePhysicalDeviceShaderTileImageFeaturesEXT},
        {"PhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT", vk::StructureType::ePhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT},
        {"ShaderUniformBufferUnsizedArray", vk::StructureType::ePhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT},
        {"PhysicalDeviceShaderUntypedPointersFeaturesKHR", vk::StructureType::ePhysicalDeviceShaderUntypedPointersFeaturesKHR},
        {"ShaderUntypedPointers", vk::StructureType::ePhysicalDeviceShaderUntypedPointersFeaturesKHR},
        {"PhysicalDeviceShadingRateImageFeaturesNV", vk::StructureType::ePhysicalDeviceShadingRateImageFeaturesNV},
        {"ShadingRateImage", vk::StructureType::ePhysicalDeviceShadingRateImageFeaturesNV},
        {"PhysicalDeviceSubgroupSizeControlFeatures", vk::StructureType::ePhysicalDeviceSubgroupSizeControlFeatures},
        {"SubgroupSizeControl", vk::StructureType::ePhysicalDeviceSubgroupSizeControlFeatures},
        {"PhysicalDeviceSubpassMergeFeedbackFeaturesEXT", vk::StructureType::ePhysicalDeviceSubpassMergeFeedbackFeaturesEXT},
        {"SubpassMergeFeedback", vk::StructureType::ePhysicalDeviceSubpassMergeFeedbackFeaturesEXT},
        {"PhysicalDeviceSubpassShadingFeaturesHUAWEI", vk::StructureType::ePhysicalDeviceSubpassShadingFeaturesHUAWEI},
        {"SubpassShading", vk::StructureType::ePhysicalDeviceSubpassShadingFeaturesHUAWEI},
        {"PhysicalDeviceSwapchainMaintenance1FeaturesKHR", vk::StructureType::ePhysicalDeviceSwapchainMaintenance1FeaturesKHR},
        {"SwapchainMaintenance1", vk::StructureType::ePhysicalDeviceSwapchainMaintenance1FeaturesKHR},
        {"PhysicalDeviceSynchronization2Features", vk::StructureType::ePhysicalDeviceSynchronization2Features},
        {"Synchronization2", vk::StructureType::ePhysicalDeviceSynchronization2Features},
        {"PhysicalDeviceTensorFeaturesARM", vk::StructureType::ePhysicalDeviceTensorFeaturesARM},
        {"Tensor", vk::StructureType::ePhysicalDeviceTensorFeaturesARM},
        {"PhysicalDeviceTexelBufferAlignmentFeaturesEXT", vk::StructureType::ePhysicalDeviceTexelBufferAlignmentFeaturesEXT},
        {"TexelBufferAlignment", vk::StructureType::ePhysicalDeviceTexelBufferAlignmentFeaturesEXT},
        {"PhysicalDeviceTextureCompressionASTC3DFeaturesEXT", vk::StructureType::ePhysicalDeviceTextureCompressionAstc3DFeaturesEXT},
        {"TextureCompressionASTC3D", vk::StructureType::ePhysicalDeviceTextureCompressionAstc3DFeaturesEXT},
        {"PhysicalDeviceTextureCompressionASTCHDRFeatures", vk::StructureType::ePhysicalDeviceTextureCompressionAstcHdrFeatures},
        {"TextureCompressionASTCHDR", vk::StructureType::ePhysicalDeviceTextureCompressionAstcHdrFeatures},
        {"PhysicalDeviceTileMemoryHeapFeaturesQCOM", vk::StructureType::ePhysicalDeviceTileMemoryHeapFeaturesQCOM},
        {"TileMemoryHeap", vk::StructureType::ePhysicalDeviceTileMemoryHeapFeaturesQCOM},
        {"PhysicalDeviceTilePropertiesFeaturesQCOM", vk::StructureType::ePhysicalDeviceTilePropertiesFeaturesQCOM},
        {"TileProperties", vk::StructureType::ePhysicalDeviceTilePropertiesFeaturesQCOM},
        {"PhysicalDeviceTileShadingFeaturesQCOM", vk::StructureType::ePhysicalDeviceTileShadingFeaturesQCOM},
        {"TileShading", vk::StructureType::ePhysicalDeviceTileShadingFeaturesQCOM},
        {"PhysicalDeviceTimelineSemaphoreFeatures", vk::StructureType::ePhysicalDeviceTimelineSemaphoreFeatures},
        {"TimelineSemaphore", vk::StructureType::ePhysicalDeviceTimelineSemaphoreFeatures},
        {"PhysicalDeviceTransformFeedbackFeaturesEXT", vk::StructureType::ePhysicalDeviceTransformFeedbackFeaturesEXT},
        {"TransformFeedback", vk::StructureType::ePhysicalDeviceTransformFeedbackFeaturesEXT},
        {"PhysicalDeviceUnifiedImageLayoutsFeaturesKHR", vk::StructureType::ePhysicalDeviceUnifiedImageLayoutsFeaturesKHR},
        {"UnifiedImageLayouts", vk::StructureType::ePhysicalDeviceUnifiedImageLayoutsFeaturesKHR},
        {"PhysicalDeviceUniformBufferStandardLayoutFeatures", vk::StructureType::ePhysicalDeviceUniformBufferStandardLayoutFeatures},
        {"UniformBufferStandardLayout", vk::StructureType::ePhysicalDeviceUniformBufferStandardLayoutFeatures},
        {"PhysicalDeviceVariablePointersFeatures", vk::StructureType::ePhysicalDeviceVariablePointersFeatures},
        {"VariablePointers", vk::StructureType::ePhysicalDeviceVariablePointersFeatures},
        {"PhysicalDeviceVertexAttributeDivisorFeatures", vk::StructureType::ePhysicalDeviceVertexAttributeDivisorFeatures},
        {"VertexAttributeDivisor", vk::StructureType::ePhysicalDeviceVertexAttributeDivisorFeatures},
        {"PhysicalDeviceVertexAttributeRobustnessFeaturesEXT", vk::StructureType::ePhysicalDeviceVertexAttributeRobustnessFeaturesEXT},
        {"VertexAttributeRobustness", vk::StructureType::ePhysicalDeviceVertexAttributeRobustnessFeaturesEXT},
        {"PhysicalDeviceVertexInputDynamicStateFeaturesEXT", vk::StructureType::ePhysicalDeviceVertexInputDynamicStateFeaturesEXT},
        {"VertexInputDynamicState", vk::StructureType::ePhysicalDeviceVertexInputDynamicStateFeaturesEXT},
        {"PhysicalDeviceVideoDecodeVP9FeaturesKHR", vk::StructureType::ePhysicalDeviceVideoDecodeVp9FeaturesKHR},
        {"VideoDecodeVP9", vk::StructureType::ePhysicalDeviceVideoDecodeVp9FeaturesKHR},
        {"PhysicalDeviceVideoEncodeAV1FeaturesKHR", vk::StructureType::ePhysicalDeviceVideoEncodeAv1FeaturesKHR},
        {"VideoEncodeAV1", vk::StructureType::ePhysicalDeviceVideoEncodeAv1FeaturesKHR},
        {"PhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR", vk::StructureType::ePhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR},
        {"VideoEncodeIntraRefresh", vk::StructureType::ePhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR},
        {"PhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR", vk::StructureType::ePhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR},
        {"VideoEncodeQuantizationMap", vk::StructureType::ePhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR},
        {"PhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE", vk::StructureType::ePhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE},
        {"VideoEncodeRgbConversion", vk::StructureType::ePhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE},
        {"PhysicalDeviceVideoMaintenance1FeaturesKHR", vk::StructureType::ePhysicalDeviceVideoMaintenance1FeaturesKHR},
        {"VideoMaintenance1", vk::StructureType::ePhysicalDeviceVideoMaintenance1FeaturesKHR},
        {"PhysicalDeviceVideoMaintenance2FeaturesKHR", vk::StructureType::ePhysicalDeviceVideoMaintenance2FeaturesKHR},
        {"VideoMaintenance2", vk::StructureType::ePhysicalDeviceVideoMaintenance2FeaturesKHR},
        {"PhysicalDeviceVulkan11Features", vk::StructureType::ePhysicalDeviceVulkan11Features},
        {"Vulkan11", vk::StructureType::ePhysicalDeviceVulkan11Features},
        {"PhysicalDeviceVulkan12Features", vk::StructureType::ePhysicalDeviceVulkan12Features},
        {"Vulkan12", vk::StructureType::ePhysicalDeviceVulkan12Features},
        {"PhysicalDeviceVulkan13Features", vk::StructureType::ePhysicalDeviceVulkan13Features},
        {"Vulkan13", vk::StructureType::ePhysicalDeviceVulkan13Features},
        {"PhysicalDeviceVulkan14Features", vk::StructureType::ePhysicalDeviceVulkan14Features},
        {"Vulkan14", vk::StructureType::ePhysicalDeviceVulkan14Features},
        {"PhysicalDeviceVulkanMemoryModelFeatures", vk::StructureType::ePhysicalDeviceVulkanMemoryModelFeatures},
        {"VulkanMemoryModel", vk::StructureType::ePhysicalDeviceVulkanMemoryModelFeatures},
        {"PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR", vk::StructureType::ePhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR},
        {"WorkgroupMemoryExplicitLayout", vk::StructureType::ePhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR},
        {"PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT", vk::StructureType::ePhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT},
        {"Ycbcr2Plane444Formats", vk::StructureType::ePhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT},
        {"PhysicalDeviceYcbcrDegammaFeaturesQCOM", vk::StructureType::ePhysicalDeviceYcbcrDegammaFeaturesQCOM},
        {"YcbcrDegamma", vk::StructureType::ePhysicalDeviceYcbcrDegammaFeaturesQCOM},
        {"PhysicalDeviceYcbcrImageArraysFeaturesEXT", vk::StructureType::ePhysicalDeviceYcbcrImageArraysFeaturesEXT},
        {"YcbcrImageArrays", vk::StructureType::ePhysicalDeviceYcbcrImageArraysFeaturesEXT},
        {"PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT", vk::StructureType::ePhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT},
        {"ZeroInitializeDeviceMemory", vk::StructureType::ePhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT},
        {"PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures", vk::StructureType::ePhysicalDeviceZeroInitializeWorkgroupMemoryFeatures},
        {"ZeroInitializeWorkgroupMemory", vk::StructureType::ePhysicalDeviceZeroInitializeWorkgroupMemoryFeatures},
    };

    auto it = name_map.find(name);
    if (it != name_map.end()) {
        return it->second;
    }
    return std::nullopt;
}

FeatureHandle get_feature(const std::string& name) {
    auto stype = structure_type_for_feature_name(name);
    if (stype) {
        return get_feature(*stype);
    }
    return nullptr;
}

std::vector<FeatureHandle> get_all_features() {
    return {
        std::make_shared<FeaturePhysicalDevice16BitStorage>(),
        std::make_shared<FeaturePhysicalDevice4444FormatsEXT>(),
        std::make_shared<FeaturePhysicalDevice8BitStorage>(),
        std::make_shared<FeaturePhysicalDeviceASTCDecodeEXT>(),
        std::make_shared<FeaturePhysicalDeviceAccelerationStructureKHR>(),
        std::make_shared<FeaturePhysicalDeviceAddressBindingReportEXT>(),
        std::make_shared<FeaturePhysicalDeviceAmigoProfilingSEC>(),
        std::make_shared<FeaturePhysicalDeviceAntiLagAMD>(),
        std::make_shared<FeaturePhysicalDeviceAttachmentFeedbackLoopDynamicStateEXT>(),
        std::make_shared<FeaturePhysicalDeviceAttachmentFeedbackLoopLayoutEXT>(),
        std::make_shared<FeaturePhysicalDeviceBlendOperationAdvancedEXT>(),
        std::make_shared<FeaturePhysicalDeviceBorderColorSwizzleEXT>(),
        std::make_shared<FeaturePhysicalDeviceBufferDeviceAddress>(),
        std::make_shared<FeaturePhysicalDeviceBufferDeviceAddressEXT>(),
        std::make_shared<FeaturePhysicalDeviceClusterAccelerationStructureNV>(),
        std::make_shared<FeaturePhysicalDeviceClusterCullingShaderHUAWEI>(),
        std::make_shared<FeaturePhysicalDeviceCoherentMemoryAMD>(),
        std::make_shared<FeaturePhysicalDeviceColorWriteEnableEXT>(),
        std::make_shared<FeaturePhysicalDeviceCommandBufferInheritanceNV>(),
        std::make_shared<FeaturePhysicalDeviceComputeOccupancyPriorityNV>(),
        std::make_shared<FeaturePhysicalDeviceComputeShaderDerivativesKHR>(),
        std::make_shared<FeaturePhysicalDeviceConditionalRenderingEXT>(),
        std::make_shared<FeaturePhysicalDeviceCooperativeMatrix2NV>(),
        std::make_shared<FeaturePhysicalDeviceCooperativeMatrixKHR>(),
        std::make_shared<FeaturePhysicalDeviceCooperativeMatrixNV>(),
        std::make_shared<FeaturePhysicalDeviceCooperativeVectorNV>(),
        std::make_shared<FeaturePhysicalDeviceCopyMemoryIndirectKHR>(),
        std::make_shared<FeaturePhysicalDeviceCopyMemoryIndirectNV>(),
        std::make_shared<FeaturePhysicalDeviceCornerSampledImageNV>(),
        std::make_shared<FeaturePhysicalDeviceCoverageReductionModeNV>(),
        std::make_shared<FeaturePhysicalDeviceCubicClampQCOM>(),
        std::make_shared<FeaturePhysicalDeviceCubicWeightsQCOM>(),
        std::make_shared<FeaturePhysicalDeviceCustomBorderColorEXT>(),
        std::make_shared<FeaturePhysicalDeviceCustomResolveEXT>(),
        std::make_shared<FeaturePhysicalDeviceDataGraphARM>(),
        std::make_shared<FeaturePhysicalDeviceDataGraphModelQCOM>(),
        std::make_shared<FeaturePhysicalDeviceDedicatedAllocationImageAliasingNV>(),
        std::make_shared<FeaturePhysicalDeviceDepthBiasControlEXT>(),
        std::make_shared<FeaturePhysicalDeviceDepthClampControlEXT>(),
        std::make_shared<FeaturePhysicalDeviceDepthClampZeroOneKHR>(),
        std::make_shared<FeaturePhysicalDeviceDepthClipControlEXT>(),
        std::make_shared<FeaturePhysicalDeviceDepthClipEnableEXT>(),
        std::make_shared<FeaturePhysicalDeviceDescriptorBufferEXT>(),
        std::make_shared<FeaturePhysicalDeviceDescriptorBufferTensorARM>(),
        std::make_shared<FeaturePhysicalDeviceDescriptorIndexing>(),
        std::make_shared<FeaturePhysicalDeviceDescriptorPoolOverallocationNV>(),
        std::make_shared<FeaturePhysicalDeviceDescriptorSetHostMappingVALVE>(),
        std::make_shared<FeaturePhysicalDeviceDeviceGeneratedCommandsComputeNV>(),
        std::make_shared<FeaturePhysicalDeviceDeviceGeneratedCommandsEXT>(),
        std::make_shared<FeaturePhysicalDeviceDeviceGeneratedCommandsNV>(),
        std::make_shared<FeaturePhysicalDeviceDeviceMemoryReportEXT>(),
        std::make_shared<FeaturePhysicalDeviceDiagnosticsConfigNV>(),
        std::make_shared<FeaturePhysicalDeviceDynamicRendering>(),
        std::make_shared<FeaturePhysicalDeviceDynamicRenderingLocalRead>(),
        std::make_shared<FeaturePhysicalDeviceDynamicRenderingUnusedAttachmentsEXT>(),
        std::make_shared<FeaturePhysicalDeviceExclusiveScissorNV>(),
        std::make_shared<FeaturePhysicalDeviceExtendedDynamicState2EXT>(),
        std::make_shared<FeaturePhysicalDeviceExtendedDynamicState3EXT>(),
        std::make_shared<FeaturePhysicalDeviceExtendedDynamicStateEXT>(),
        std::make_shared<FeaturePhysicalDeviceExtendedSparseAddressSpaceNV>(),
        std::make_shared<FeaturePhysicalDeviceExternalMemoryRDMANV>(),
        std::make_shared<FeaturePhysicalDeviceFaultEXT>(),
        std::make_shared<FeaturePhysicalDeviceFeatures2>(),
        std::make_shared<FeaturePhysicalDeviceFormatPackARM>(),
        std::make_shared<FeaturePhysicalDeviceFragmentDensityMap2EXT>(),
        std::make_shared<FeaturePhysicalDeviceFragmentDensityMapEXT>(),
        std::make_shared<FeaturePhysicalDeviceFragmentDensityMapLayeredVALVE>(),
        std::make_shared<FeaturePhysicalDeviceFragmentDensityMapOffsetEXT>(),
        std::make_shared<FeaturePhysicalDeviceFragmentShaderBarycentricKHR>(),
        std::make_shared<FeaturePhysicalDeviceFragmentShaderInterlockEXT>(),
        std::make_shared<FeaturePhysicalDeviceFragmentShadingRateEnumsNV>(),
        std::make_shared<FeaturePhysicalDeviceFragmentShadingRateKHR>(),
        std::make_shared<FeaturePhysicalDeviceFrameBoundaryEXT>(),
        std::make_shared<FeaturePhysicalDeviceGlobalPriorityQuery>(),
        std::make_shared<FeaturePhysicalDeviceGraphicsPipelineLibraryEXT>(),
        std::make_shared<FeaturePhysicalDeviceHdrVividHUAWEI>(),
        std::make_shared<FeaturePhysicalDeviceHostImageCopy>(),
        std::make_shared<FeaturePhysicalDeviceHostQueryReset>(),
        std::make_shared<FeaturePhysicalDeviceImage2DViewOf3DEXT>(),
        std::make_shared<FeaturePhysicalDeviceImageAlignmentControlMESA>(),
        std::make_shared<FeaturePhysicalDeviceImageCompressionControlEXT>(),
        std::make_shared<FeaturePhysicalDeviceImageCompressionControlSwapchainEXT>(),
        std::make_shared<FeaturePhysicalDeviceImageProcessing2QCOM>(),
        std::make_shared<FeaturePhysicalDeviceImageProcessingQCOM>(),
        std::make_shared<FeaturePhysicalDeviceImageRobustness>(),
        std::make_shared<FeaturePhysicalDeviceImageSlicedViewOf3DEXT>(),
        std::make_shared<FeaturePhysicalDeviceImageViewMinLodEXT>(),
        std::make_shared<FeaturePhysicalDeviceImagelessFramebuffer>(),
        std::make_shared<FeaturePhysicalDeviceIndexTypeUint8>(),
        std::make_shared<FeaturePhysicalDeviceInheritedViewportScissorNV>(),
        std::make_shared<FeaturePhysicalDeviceInlineUniformBlock>(),
        std::make_shared<FeaturePhysicalDeviceInvocationMaskHUAWEI>(),
        std::make_shared<FeaturePhysicalDeviceLegacyDitheringEXT>(),
        std::make_shared<FeaturePhysicalDeviceLegacyVertexAttributesEXT>(),
        std::make_shared<FeaturePhysicalDeviceLineRasterization>(),
        std::make_shared<FeaturePhysicalDeviceLinearColorAttachmentNV>(),
        std::make_shared<FeaturePhysicalDeviceMaintenance10KHR>(),
        std::make_shared<FeaturePhysicalDeviceMaintenance4>(),
        std::make_shared<FeaturePhysicalDeviceMaintenance5>(),
        std::make_shared<FeaturePhysicalDeviceMaintenance6>(),
        std::make_shared<FeaturePhysicalDeviceMaintenance7KHR>(),
        std::make_shared<FeaturePhysicalDeviceMaintenance8KHR>(),
        std::make_shared<FeaturePhysicalDeviceMaintenance9KHR>(),
        std::make_shared<FeaturePhysicalDeviceMapMemoryPlacedEXT>(),
        std::make_shared<FeaturePhysicalDeviceMemoryDecompressionEXT>(),
        std::make_shared<FeaturePhysicalDeviceMemoryPriorityEXT>(),
        std::make_shared<FeaturePhysicalDeviceMeshShaderEXT>(),
        std::make_shared<FeaturePhysicalDeviceMeshShaderNV>(),
        std::make_shared<FeaturePhysicalDeviceMultiDrawEXT>(),
        std::make_shared<FeaturePhysicalDeviceMultisampledRenderToSingleSampledEXT>(),
        std::make_shared<FeaturePhysicalDeviceMultiview>(),
        std::make_shared<FeaturePhysicalDeviceMultiviewPerViewRenderAreasQCOM>(),
        std::make_shared<FeaturePhysicalDeviceMultiviewPerViewViewportsQCOM>(),
        std::make_shared<FeaturePhysicalDeviceMutableDescriptorTypeEXT>(),
        std::make_shared<FeaturePhysicalDeviceNestedCommandBufferEXT>(),
        std::make_shared<FeaturePhysicalDeviceNonSeamlessCubeMapEXT>(),
        std::make_shared<FeaturePhysicalDeviceOpacityMicromapEXT>(),
        std::make_shared<FeaturePhysicalDeviceOpticalFlowNV>(),
        std::make_shared<FeaturePhysicalDevicePageableDeviceLocalMemoryEXT>(),
        std::make_shared<FeaturePhysicalDevicePartitionedAccelerationStructureNV>(),
        std::make_shared<FeaturePhysicalDevicePerStageDescriptorSetNV>(),
        std::make_shared<FeaturePhysicalDevicePerformanceCountersByRegionARM>(),
        std::make_shared<FeaturePhysicalDevicePerformanceQueryKHR>(),
        std::make_shared<FeaturePhysicalDevicePipelineBinaryKHR>(),
        std::make_shared<FeaturePhysicalDevicePipelineCacheIncrementalModeSEC>(),
        std::make_shared<FeaturePhysicalDevicePipelineCreationCacheControl>(),
        std::make_shared<FeaturePhysicalDevicePipelineExecutablePropertiesKHR>(),
        std::make_shared<FeaturePhysicalDevicePipelineLibraryGroupHandlesEXT>(),
        std::make_shared<FeaturePhysicalDevicePipelineOpacityMicromapARM>(),
        std::make_shared<FeaturePhysicalDevicePipelinePropertiesEXT>(),
        std::make_shared<FeaturePhysicalDevicePipelineProtectedAccess>(),
        std::make_shared<FeaturePhysicalDevicePipelineRobustness>(),
        std::make_shared<FeaturePhysicalDevicePresentBarrierNV>(),
        std::make_shared<FeaturePhysicalDevicePresentId2KHR>(),
        std::make_shared<FeaturePhysicalDevicePresentIdKHR>(),
        std::make_shared<FeaturePhysicalDevicePresentModeFifoLatestReadyKHR>(),
        std::make_shared<FeaturePhysicalDevicePresentTimingEXT>(),
        std::make_shared<FeaturePhysicalDevicePresentWait2KHR>(),
        std::make_shared<FeaturePhysicalDevicePresentWaitKHR>(),
        std::make_shared<FeaturePhysicalDevicePrimitiveTopologyListRestartEXT>(),
        std::make_shared<FeaturePhysicalDevicePrimitivesGeneratedQueryEXT>(),
        std::make_shared<FeaturePhysicalDevicePrivateData>(),
        std::make_shared<FeaturePhysicalDeviceProtectedMemory>(),
        std::make_shared<FeaturePhysicalDeviceProvokingVertexEXT>(),
        std::make_shared<FeaturePhysicalDeviceRGBA10X6FormatsEXT>(),
        std::make_shared<FeaturePhysicalDeviceRasterizationOrderAttachmentAccessEXT>(),
        std::make_shared<FeaturePhysicalDeviceRawAccessChainsNV>(),
        std::make_shared<FeaturePhysicalDeviceRayQueryKHR>(),
        std::make_shared<FeaturePhysicalDeviceRayTracingInvocationReorderEXT>(),
        std::make_shared<FeaturePhysicalDeviceRayTracingInvocationReorderNV>(),
        std::make_shared<FeaturePhysicalDeviceRayTracingLinearSweptSpheresNV>(),
        std::make_shared<FeaturePhysicalDeviceRayTracingMaintenance1KHR>(),
        std::make_shared<FeaturePhysicalDeviceRayTracingMotionBlurNV>(),
        std::make_shared<FeaturePhysicalDeviceRayTracingPipelineKHR>(),
        std::make_shared<FeaturePhysicalDeviceRayTracingPositionFetchKHR>(),
        std::make_shared<FeaturePhysicalDeviceRayTracingValidationNV>(),
        std::make_shared<FeaturePhysicalDeviceRelaxedLineRasterizationIMG>(),
        std::make_shared<FeaturePhysicalDeviceRenderPassStripedARM>(),
        std::make_shared<FeaturePhysicalDeviceRepresentativeFragmentTestNV>(),
        std::make_shared<FeaturePhysicalDeviceRobustness2KHR>(),
        std::make_shared<FeaturePhysicalDeviceSamplerYcbcrConversion>(),
        std::make_shared<FeaturePhysicalDeviceScalarBlockLayout>(),
        std::make_shared<FeaturePhysicalDeviceSchedulingControlsARM>(),
        std::make_shared<FeaturePhysicalDeviceSeparateDepthStencilLayouts>(),
        std::make_shared<FeaturePhysicalDeviceShader64BitIndexingEXT>(),
        std::make_shared<FeaturePhysicalDeviceShaderAtomicFloat16VectorNV>(),
        std::make_shared<FeaturePhysicalDeviceShaderAtomicFloat2EXT>(),
        std::make_shared<FeaturePhysicalDeviceShaderAtomicFloatEXT>(),
        std::make_shared<FeaturePhysicalDeviceShaderAtomicInt64>(),
        std::make_shared<FeaturePhysicalDeviceShaderBfloat16KHR>(),
        std::make_shared<FeaturePhysicalDeviceShaderClockKHR>(),
        std::make_shared<FeaturePhysicalDeviceShaderCoreBuiltinsARM>(),
        std::make_shared<FeaturePhysicalDeviceShaderDemoteToHelperInvocation>(),
        std::make_shared<FeaturePhysicalDeviceShaderDrawParameters>(),
        std::make_shared<FeaturePhysicalDeviceShaderEarlyAndLateFragmentTestsAMD>(),
        std::make_shared<FeaturePhysicalDeviceShaderExpectAssume>(),
        std::make_shared<FeaturePhysicalDeviceShaderFloat16Int8>(),
        std::make_shared<FeaturePhysicalDeviceShaderFloat8EXT>(),
        std::make_shared<FeaturePhysicalDeviceShaderFloatControls2>(),
        std::make_shared<FeaturePhysicalDeviceShaderFmaKHR>(),
        std::make_shared<FeaturePhysicalDeviceShaderImageAtomicInt64EXT>(),
        std::make_shared<FeaturePhysicalDeviceShaderImageFootprintNV>(),
        std::make_shared<FeaturePhysicalDeviceShaderIntegerDotProduct>(),
        std::make_shared<FeaturePhysicalDeviceShaderIntegerFunctions2INTEL>(),
        std::make_shared<FeaturePhysicalDeviceShaderLongVectorEXT>(),
        std::make_shared<FeaturePhysicalDeviceShaderMaximalReconvergenceKHR>(),
        std::make_shared<FeaturePhysicalDeviceShaderModuleIdentifierEXT>(),
        std::make_shared<FeaturePhysicalDeviceShaderObjectEXT>(),
        std::make_shared<FeaturePhysicalDeviceShaderQuadControlKHR>(),
        std::make_shared<FeaturePhysicalDeviceShaderRelaxedExtendedInstructionKHR>(),
        std::make_shared<FeaturePhysicalDeviceShaderReplicatedCompositesEXT>(),
        std::make_shared<FeaturePhysicalDeviceShaderSMBuiltinsNV>(),
        std::make_shared<FeaturePhysicalDeviceShaderSubgroupExtendedTypes>(),
        std::make_shared<FeaturePhysicalDeviceShaderSubgroupRotate>(),
        std::make_shared<FeaturePhysicalDeviceShaderSubgroupUniformControlFlowKHR>(),
        std::make_shared<FeaturePhysicalDeviceShaderTerminateInvocation>(),
        std::make_shared<FeaturePhysicalDeviceShaderTileImageEXT>(),
        std::make_shared<FeaturePhysicalDeviceShaderUniformBufferUnsizedArrayEXT>(),
        std::make_shared<FeaturePhysicalDeviceShaderUntypedPointersKHR>(),
        std::make_shared<FeaturePhysicalDeviceShadingRateImageNV>(),
        std::make_shared<FeaturePhysicalDeviceSubgroupSizeControl>(),
        std::make_shared<FeaturePhysicalDeviceSubpassMergeFeedbackEXT>(),
        std::make_shared<FeaturePhysicalDeviceSubpassShadingHUAWEI>(),
        std::make_shared<FeaturePhysicalDeviceSwapchainMaintenance1KHR>(),
        std::make_shared<FeaturePhysicalDeviceSynchronization2>(),
        std::make_shared<FeaturePhysicalDeviceTensorARM>(),
        std::make_shared<FeaturePhysicalDeviceTexelBufferAlignmentEXT>(),
        std::make_shared<FeaturePhysicalDeviceTextureCompressionASTC3DEXT>(),
        std::make_shared<FeaturePhysicalDeviceTextureCompressionASTCHDR>(),
        std::make_shared<FeaturePhysicalDeviceTileMemoryHeapQCOM>(),
        std::make_shared<FeaturePhysicalDeviceTilePropertiesQCOM>(),
        std::make_shared<FeaturePhysicalDeviceTileShadingQCOM>(),
        std::make_shared<FeaturePhysicalDeviceTimelineSemaphore>(),
        std::make_shared<FeaturePhysicalDeviceTransformFeedbackEXT>(),
        std::make_shared<FeaturePhysicalDeviceUnifiedImageLayoutsKHR>(),
        std::make_shared<FeaturePhysicalDeviceUniformBufferStandardLayout>(),
        std::make_shared<FeaturePhysicalDeviceVariablePointers>(),
        std::make_shared<FeaturePhysicalDeviceVertexAttributeDivisor>(),
        std::make_shared<FeaturePhysicalDeviceVertexAttributeRobustnessEXT>(),
        std::make_shared<FeaturePhysicalDeviceVertexInputDynamicStateEXT>(),
        std::make_shared<FeaturePhysicalDeviceVideoDecodeVP9KHR>(),
        std::make_shared<FeaturePhysicalDeviceVideoEncodeAV1KHR>(),
        std::make_shared<FeaturePhysicalDeviceVideoEncodeIntraRefreshKHR>(),
        std::make_shared<FeaturePhysicalDeviceVideoEncodeQuantizationMapKHR>(),
        std::make_shared<FeaturePhysicalDeviceVideoEncodeRgbConversionVALVE>(),
        std::make_shared<FeaturePhysicalDeviceVideoMaintenance1KHR>(),
        std::make_shared<FeaturePhysicalDeviceVideoMaintenance2KHR>(),
        std::make_shared<FeaturePhysicalDeviceVulkan11>(),
        std::make_shared<FeaturePhysicalDeviceVulkan12>(),
        std::make_shared<FeaturePhysicalDeviceVulkan13>(),
        std::make_shared<FeaturePhysicalDeviceVulkan14>(),
        std::make_shared<FeaturePhysicalDeviceVulkanMemoryModel>(),
        std::make_shared<FeaturePhysicalDeviceWorkgroupMemoryExplicitLayoutKHR>(),
        std::make_shared<FeaturePhysicalDeviceYcbcr2Plane444FormatsEXT>(),
        std::make_shared<FeaturePhysicalDeviceYcbcrDegammaQCOM>(),
        std::make_shared<FeaturePhysicalDeviceYcbcrImageArraysEXT>(),
        std::make_shared<FeaturePhysicalDeviceZeroInitializeDeviceMemoryEXT>(),
        std::make_shared<FeaturePhysicalDeviceZeroInitializeWorkgroupMemory>(),
    };
}

} // namespace merian
