// This file was autogenerated for Vulkan v1.4.342.
// Do not edit manually!

#include "merian/vk/utils/vulkan_spirv.hpp"

#include <string_view>
#include <unordered_map>
#include <unordered_set>

namespace merian {

const std::vector<const char*>& get_spirv_extensions() {
    static const std::vector<const char*> extensions = {
        "SPV_AMD_gcn_shader",
        "SPV_AMD_gpu_shader_half_float",
        "SPV_AMD_gpu_shader_int16",
        "SPV_AMD_shader_ballot",
        "SPV_AMD_shader_early_and_late_fragment_tests",
        "SPV_AMD_shader_explicit_vertex_parameter",
        "SPV_AMD_shader_fragment_mask",
        "SPV_AMD_shader_image_load_store_lod",
        "SPV_AMD_shader_trinary_minmax",
        "SPV_AMD_texture_gather_bias_lod",
        "SPV_ARM_core_builtins",
        "SPV_ARM_graph",
        "SPV_ARM_tensors",
        "SPV_EXT_demote_to_helper_invocation",
        "SPV_EXT_descriptor_heap",
        "SPV_EXT_descriptor_indexing",
        "SPV_EXT_float8",
        "SPV_EXT_fragment_fully_covered",
        "SPV_EXT_fragment_invocation_density",
        "SPV_EXT_fragment_shader_interlock",
        "SPV_EXT_long_vector",
        "SPV_EXT_mesh_shader",
        "SPV_EXT_opacity_micromap",
        "SPV_EXT_physical_storage_buffer",
        "SPV_EXT_replicated_composites",
        "SPV_EXT_shader_64bit_indexing",
        "SPV_EXT_shader_atomic_float16_add",
        "SPV_EXT_shader_atomic_float_add",
        "SPV_EXT_shader_atomic_float_min_max",
        "SPV_EXT_shader_image_int64",
        "SPV_EXT_shader_invocation_reorder",
        "SPV_EXT_shader_stencil_export",
        "SPV_EXT_shader_subgroup_partitioned",
        "SPV_EXT_shader_tile_image",
        "SPV_EXT_shader_viewport_index_layer",
        "SPV_GOOGLE_decorate_string",
        "SPV_GOOGLE_hlsl_functionality1",
        "SPV_GOOGLE_user_type",
        "SPV_HUAWEI_cluster_culling_shader",
        "SPV_HUAWEI_subpass_shading",
        "SPV_INTEL_shader_integer_functions2",
        "SPV_KHR_16bit_storage",
        "SPV_KHR_8bit_storage",
        "SPV_KHR_bfloat16",
        "SPV_KHR_compute_shader_derivatives",
        "SPV_KHR_cooperative_matrix",
        "SPV_KHR_device_group",
        "SPV_KHR_expect_assume",
        "SPV_KHR_float_controls",
        "SPV_KHR_float_controls2",
        "SPV_KHR_fma",
        "SPV_KHR_fragment_shader_barycentric",
        "SPV_KHR_fragment_shading_rate",
        "SPV_KHR_integer_dot_product",
        "SPV_KHR_maximal_reconvergence",
        "SPV_KHR_multiview",
        "SPV_KHR_non_semantic_info",
        "SPV_KHR_physical_storage_buffer",
        "SPV_KHR_post_depth_coverage",
        "SPV_KHR_quad_control",
        "SPV_KHR_ray_cull_mask",
        "SPV_KHR_ray_query",
        "SPV_KHR_ray_tracing",
        "SPV_KHR_ray_tracing_position_fetch",
        "SPV_KHR_relaxed_extended_instruction",
        "SPV_KHR_shader_ballot",
        "SPV_KHR_shader_clock",
        "SPV_KHR_shader_draw_parameters",
        "SPV_KHR_storage_buffer_storage_class",
        "SPV_KHR_subgroup_rotate",
        "SPV_KHR_subgroup_uniform_control_flow",
        "SPV_KHR_subgroup_vote",
        "SPV_KHR_terminate_invocation",
        "SPV_KHR_untyped_pointers",
        "SPV_KHR_variable_pointers",
        "SPV_KHR_vulkan_memory_model",
        "SPV_KHR_workgroup_memory_explicit_layout",
        "SPV_NVX_multiview_per_view_attributes",
        "SPV_NV_cluster_acceleration_structure",
        "SPV_NV_compute_shader_derivatives",
        "SPV_NV_cooperative_matrix",
        "SPV_NV_cooperative_matrix2",
        "SPV_NV_cooperative_vector",
        "SPV_NV_fragment_shader_barycentric",
        "SPV_NV_geometry_shader_passthrough",
        "SPV_NV_linear_swept_spheres",
        "SPV_NV_mesh_shader",
        "SPV_NV_push_constant_bank",
        "SPV_NV_raw_access_chains",
        "SPV_NV_ray_tracing",
        "SPV_NV_ray_tracing_motion_blur",
        "SPV_NV_sample_mask_override_coverage",
        "SPV_NV_shader_atomic_fp16_vector",
        "SPV_NV_shader_image_footprint",
        "SPV_NV_shader_invocation_reorder",
        "SPV_NV_shader_sm_builtins",
        "SPV_NV_shader_subgroup_partitioned",
        "SPV_NV_shading_rate",
        "SPV_NV_tensor_addressing",
        "SPV_NV_viewport_array2",
        "SPV_QCOM_image_processing",
        "SPV_QCOM_image_processing2",
        "SPV_QCOM_tile_shading",
    };
    return extensions;
}

namespace {
struct SpirvExtReq {
    uint32_t satisfied_by_version;
    std::vector<const char*> extensions;
};

// NOLINTNEXTLINE(cert-err58-cpp)
const std::unordered_map<std::string_view, SpirvExtReq> spirv_ext_req_map = {
    {"SPV_AMD_gcn_shader", {0, {VK_AMD_GCN_SHADER_EXTENSION_NAME}}},
    {"SPV_AMD_gpu_shader_half_float", {0, {VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME}}},
    {"SPV_AMD_gpu_shader_int16", {0, {VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME}}},
    {"SPV_AMD_shader_ballot", {0, {VK_AMD_SHADER_BALLOT_EXTENSION_NAME}}},
    {"SPV_AMD_shader_early_and_late_fragment_tests", {0, {VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION_NAME}}},
    {"SPV_AMD_shader_explicit_vertex_parameter", {0, {VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME}}},
    {"SPV_AMD_shader_fragment_mask", {0, {VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME}}},
    {"SPV_AMD_shader_image_load_store_lod", {0, {VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME}}},
    {"SPV_AMD_shader_trinary_minmax", {0, {VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME}}},
    {"SPV_AMD_texture_gather_bias_lod", {0, {VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME}}},
    {"SPV_ARM_core_builtins", {0, {VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME}}},
    {"SPV_ARM_graph", {0, {VK_ARM_DATA_GRAPH_EXTENSION_NAME}}},
    {"SPV_ARM_tensors", {0, {VK_ARM_TENSORS_EXTENSION_NAME}}},
    {"SPV_EXT_demote_to_helper_invocation", {VK_API_VERSION_1_3, {VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME}}},
    {"SPV_EXT_descriptor_heap", {0, {VK_EXT_DESCRIPTOR_HEAP_EXTENSION_NAME}}},
    {"SPV_EXT_descriptor_indexing", {VK_API_VERSION_1_2, {VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME}}},
    {"SPV_EXT_float8", {0, {VK_EXT_SHADER_FLOAT8_EXTENSION_NAME}}},
    {"SPV_EXT_fragment_fully_covered", {0, {VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME}}},
    {"SPV_EXT_fragment_invocation_density", {0, {VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME}}},
    {"SPV_EXT_fragment_shader_interlock", {0, {VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME}}},
    {"SPV_EXT_long_vector", {0, {VK_EXT_SHADER_LONG_VECTOR_EXTENSION_NAME}}},
    {"SPV_EXT_mesh_shader", {0, {VK_EXT_MESH_SHADER_EXTENSION_NAME}}},
    {"SPV_EXT_opacity_micromap", {0, {VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME}}},
    {"SPV_EXT_physical_storage_buffer", {0, {VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME}}},
    {"SPV_EXT_replicated_composites", {0, {VK_EXT_SHADER_REPLICATED_COMPOSITES_EXTENSION_NAME}}},
    {"SPV_EXT_shader_64bit_indexing", {0, {VK_EXT_SHADER_64BIT_INDEXING_EXTENSION_NAME}}},
    {"SPV_EXT_shader_atomic_float16_add", {0, {VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME}}},
    {"SPV_EXT_shader_atomic_float_add", {0, {VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME}}},
    {"SPV_EXT_shader_atomic_float_min_max", {0, {VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME}}},
    {"SPV_EXT_shader_image_int64", {0, {VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME}}},
    {"SPV_EXT_shader_invocation_reorder", {0, {VK_EXT_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME}}},
    {"SPV_EXT_shader_stencil_export", {0, {VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME}}},
    {"SPV_EXT_shader_subgroup_partitioned", {0, {VK_EXT_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME}}},
    {"SPV_EXT_shader_tile_image", {0, {VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME}}},
    {"SPV_EXT_shader_viewport_index_layer", {VK_API_VERSION_1_2, {VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME}}},
    {"SPV_GOOGLE_decorate_string", {0, {VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME}}},
    {"SPV_GOOGLE_hlsl_functionality1", {0, {VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME}}},
    {"SPV_GOOGLE_user_type", {0, {VK_GOOGLE_USER_TYPE_EXTENSION_NAME}}},
    {"SPV_HUAWEI_cluster_culling_shader", {0, {VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME}}},
    {"SPV_HUAWEI_subpass_shading", {0, {VK_HUAWEI_SUBPASS_SHADING_EXTENSION_NAME}}},
    {"SPV_INTEL_shader_integer_functions2", {0, {VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME}}},
    {"SPV_KHR_16bit_storage", {VK_API_VERSION_1_1, {VK_KHR_16BIT_STORAGE_EXTENSION_NAME}}},
    {"SPV_KHR_8bit_storage", {VK_API_VERSION_1_2, {VK_KHR_8BIT_STORAGE_EXTENSION_NAME}}},
    {"SPV_KHR_bfloat16", {0, {VK_KHR_SHADER_BFLOAT16_EXTENSION_NAME}}},
    {"SPV_KHR_compute_shader_derivatives", {0, {VK_KHR_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME}}},
    {"SPV_KHR_cooperative_matrix", {0, {VK_KHR_COOPERATIVE_MATRIX_EXTENSION_NAME}}},
    {"SPV_KHR_device_group", {VK_API_VERSION_1_1, {VK_KHR_DEVICE_GROUP_EXTENSION_NAME}}},
    {"SPV_KHR_expect_assume", {VK_API_VERSION_1_4, {VK_KHR_SHADER_EXPECT_ASSUME_EXTENSION_NAME}}},
    {"SPV_KHR_float_controls", {VK_API_VERSION_1_2, {VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME}}},
    {"SPV_KHR_float_controls2", {VK_API_VERSION_1_4, {VK_KHR_SHADER_FLOAT_CONTROLS_2_EXTENSION_NAME}}},
    {"SPV_KHR_fma", {0, {VK_KHR_SHADER_FMA_EXTENSION_NAME}}},
    {"SPV_KHR_fragment_shader_barycentric", {0, {VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME}}},
    {"SPV_KHR_fragment_shading_rate", {0, {VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME}}},
    {"SPV_KHR_integer_dot_product", {VK_API_VERSION_1_3, {VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME}}},
    {"SPV_KHR_maximal_reconvergence", {0, {VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_EXTENSION_NAME}}},
    {"SPV_KHR_multiview", {VK_API_VERSION_1_1, {VK_KHR_MULTIVIEW_EXTENSION_NAME}}},
    {"SPV_KHR_non_semantic_info", {VK_API_VERSION_1_3, {VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME}}},
    {"SPV_KHR_physical_storage_buffer", {VK_API_VERSION_1_2, {VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME}}},
    {"SPV_KHR_post_depth_coverage", {0, {VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME}}},
    {"SPV_KHR_quad_control", {0, {VK_KHR_SHADER_QUAD_CONTROL_EXTENSION_NAME}}},
    {"SPV_KHR_ray_cull_mask", {0, {VK_KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME}}},
    {"SPV_KHR_ray_query", {0, {VK_KHR_RAY_QUERY_EXTENSION_NAME}}},
    {"SPV_KHR_ray_tracing", {0, {VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME}}},
    {"SPV_KHR_ray_tracing_position_fetch", {0, {VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME}}},
    {"SPV_KHR_relaxed_extended_instruction", {0, {VK_KHR_SHADER_RELAXED_EXTENDED_INSTRUCTION_EXTENSION_NAME}}},
    {"SPV_KHR_shader_ballot", {0, {VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME}}},
    {"SPV_KHR_shader_clock", {0, {VK_KHR_SHADER_CLOCK_EXTENSION_NAME}}},
    {"SPV_KHR_shader_draw_parameters", {VK_API_VERSION_1_1, {VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME}}},
    {"SPV_KHR_storage_buffer_storage_class", {VK_API_VERSION_1_1, {VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME}}},
    {"SPV_KHR_subgroup_rotate", {VK_API_VERSION_1_4, {VK_KHR_SHADER_SUBGROUP_ROTATE_EXTENSION_NAME}}},
    {"SPV_KHR_subgroup_uniform_control_flow", {0, {VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME}}},
    {"SPV_KHR_subgroup_vote", {0, {VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME}}},
    {"SPV_KHR_terminate_invocation", {VK_API_VERSION_1_3, {VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME}}},
    {"SPV_KHR_untyped_pointers", {0, {VK_KHR_SHADER_UNTYPED_POINTERS_EXTENSION_NAME}}},
    {"SPV_KHR_variable_pointers", {VK_API_VERSION_1_1, {VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME}}},
    {"SPV_KHR_vulkan_memory_model", {VK_API_VERSION_1_2, {VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME}}},
    {"SPV_KHR_workgroup_memory_explicit_layout", {0, {VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME}}},
    {"SPV_NVX_multiview_per_view_attributes", {0, {VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME}}},
    {"SPV_NV_cluster_acceleration_structure", {0, {VK_NV_CLUSTER_ACCELERATION_STRUCTURE_EXTENSION_NAME}}},
    {"SPV_NV_compute_shader_derivatives", {0, {VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME}}},
    {"SPV_NV_cooperative_matrix", {0, {VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME}}},
    {"SPV_NV_cooperative_matrix2", {0, {VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME}}},
    {"SPV_NV_cooperative_vector", {0, {VK_NV_COOPERATIVE_VECTOR_EXTENSION_NAME}}},
    {"SPV_NV_fragment_shader_barycentric", {0, {VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME}}},
    {"SPV_NV_geometry_shader_passthrough", {0, {VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME}}},
    {"SPV_NV_linear_swept_spheres", {0, {VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_EXTENSION_NAME}}},
    {"SPV_NV_mesh_shader", {0, {VK_NV_MESH_SHADER_EXTENSION_NAME}}},
    {"SPV_NV_push_constant_bank", {0, {VK_NV_PUSH_CONSTANT_BANK_EXTENSION_NAME}}},
    {"SPV_NV_raw_access_chains", {0, {VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME}}},
    {"SPV_NV_ray_tracing", {0, {VK_NV_RAY_TRACING_EXTENSION_NAME}}},
    {"SPV_NV_ray_tracing_motion_blur", {0, {VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME}}},
    {"SPV_NV_sample_mask_override_coverage", {0, {VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME}}},
    {"SPV_NV_shader_atomic_fp16_vector", {0, {VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_EXTENSION_NAME}}},
    {"SPV_NV_shader_image_footprint", {0, {VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME}}},
    {"SPV_NV_shader_invocation_reorder", {0, {VK_NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME}}},
    {"SPV_NV_shader_sm_builtins", {0, {VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME}}},
    {"SPV_NV_shader_subgroup_partitioned", {0, {VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME, VK_EXT_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME}}},
    {"SPV_NV_shading_rate", {0, {VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME}}},
    {"SPV_NV_tensor_addressing", {0, {VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME}}},
    {"SPV_NV_viewport_array2", {0, {VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME}}},
    {"SPV_QCOM_image_processing", {0, {VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME}}},
    {"SPV_QCOM_image_processing2", {0, {VK_QCOM_IMAGE_PROCESSING_2_EXTENSION_NAME}}},
    {"SPV_QCOM_tile_shading", {0, {VK_QCOM_TILE_SHADING_EXTENSION_NAME}}},
};
} // namespace

std::vector<const char*> get_spirv_extension_requirements(
    const char* spirv_extension,
    uint32_t vk_api_version) {

    const auto it = spirv_ext_req_map.find(spirv_extension);
    if (it == spirv_ext_req_map.end()) {
        return {};
    }
    if (it->second.satisfied_by_version != 0 &&
        vk_api_version >= it->second.satisfied_by_version) {
        return {};
    }
    return it->second.extensions;
}

const std::vector<const char*>& get_spirv_capabilities() {
    static const std::vector<const char*> capabilities = {
        "AtomicFloat16AddEXT",
        "AtomicFloat16MinMaxEXT",
        "AtomicFloat16VectorNV",
        "AtomicFloat32AddEXT",
        "AtomicFloat32MinMaxEXT",
        "AtomicFloat64AddEXT",
        "AtomicFloat64MinMaxEXT",
        "BFloat16CooperativeMatrixKHR",
        "BFloat16DotProductKHR",
        "BFloat16TypeKHR",
        "ClipDistance",
        "ClusterCullingShadingHUAWEI",
        "ComputeDerivativeGroupLinearKHR",
        "ComputeDerivativeGroupQuadsKHR",
        "CooperativeMatrixBlockLoadsNV",
        "CooperativeMatrixConversionQCOM",
        "CooperativeMatrixConversionsNV",
        "CooperativeMatrixKHR",
        "CooperativeMatrixNV",
        "CooperativeMatrixPerElementOperationsNV",
        "CooperativeMatrixReductionsNV",
        "CooperativeMatrixTensorAddressingNV",
        "CooperativeVectorNV",
        "CooperativeVectorTrainingNV",
        "CoreBuiltinsARM",
        "CullDistance",
        "DemoteToHelperInvocation",
        "DenormFlushToZero",
        "DenormPreserve",
        "DerivativeControl",
        "DescriptorHeapEXT",
        "DeviceGroup",
        "DotProduct",
        "DotProductInput4x8Bit",
        "DotProductInput4x8BitPacked",
        "DotProductInputAll",
        "DrawParameters",
        "ExpectAssumeKHR",
        "FMAKHR",
        "Float16",
        "Float64",
        "Float8CooperativeMatrixEXT",
        "Float8EXT",
        "FloatControls2",
        "FragmentBarycentricKHR",
        "FragmentDensityEXT",
        "FragmentFullyCoveredEXT",
        "FragmentMaskAMD",
        "FragmentShaderPixelInterlockEXT",
        "FragmentShaderSampleInterlockEXT",
        "FragmentShaderShadingRateInterlockEXT",
        "FragmentShadingRateKHR",
        "Geometry",
        "GeometryPointSize",
        "GeometryShaderPassthroughNV",
        "GeometryStreams",
        "GraphARM",
        "GroupNonUniform",
        "GroupNonUniformArithmetic",
        "GroupNonUniformBallot",
        "GroupNonUniformClustered",
        "GroupNonUniformPartitionedEXT",
        "GroupNonUniformQuad",
        "GroupNonUniformRotateKHR",
        "GroupNonUniformShuffle",
        "GroupNonUniformShuffleRelative",
        "GroupNonUniformVote",
        "Image1D",
        "ImageBuffer",
        "ImageCubeArray",
        "ImageFootprintNV",
        "ImageGatherBiasLodAMD",
        "ImageGatherExtended",
        "ImageMSArray",
        "ImageQuery",
        "ImageReadWriteLodAMD",
        "InputAttachment",
        "InputAttachmentArrayDynamicIndexing",
        "InputAttachmentArrayNonUniformIndexing",
        "Int16",
        "Int64",
        "Int64Atomics",
        "Int64ImageEXT",
        "Int8",
        "IntegerFunctions2INTEL",
        "InterpolationFunction",
        "LongVectorEXT",
        "Matrix",
        "MeshShadingEXT",
        "MeshShadingNV",
        "MinLod",
        "MultiView",
        "MultiViewport",
        "PerViewAttributesNV",
        "PhysicalStorageBufferAddresses",
        "PushConstantBanksNV",
        "QuadControlKHR",
        "RawAccessChainsNV",
        "RayCullMaskKHR",
        "RayQueryKHR",
        "RayQueryPositionFetchKHR",
        "RayTracingClusterAccelerationStructureNV",
        "RayTracingKHR",
        "RayTracingLinearSweptSpheresGeometryNV",
        "RayTracingMotionBlurNV",
        "RayTracingNV",
        "RayTracingOpacityMicromapEXT",
        "RayTracingPositionFetchKHR",
        "RayTracingSpheresGeometryNV",
        "RayTraversalPrimitiveCullingKHR",
        "ReplicatedCompositesEXT",
        "RoundingModeRTE",
        "RoundingModeRTZ",
        "RuntimeDescriptorArray",
        "SampleMaskOverrideCoverageNV",
        "SampleMaskPostDepthCoverage",
        "SampleRateShading",
        "Sampled1D",
        "SampledBuffer",
        "SampledCubeArray",
        "SampledImageArrayDynamicIndexing",
        "SampledImageArrayNonUniformIndexing",
        "Shader",
        "Shader64BitIndexingEXT",
        "ShaderClockKHR",
        "ShaderEnqueueAMDX",
        "ShaderInvocationReorderEXT",
        "ShaderInvocationReorderNV",
        "ShaderLayer",
        "ShaderNonUniform",
        "ShaderSMBuiltinsNV",
        "ShaderViewportIndex",
        "ShaderViewportIndexLayerEXT",
        "ShaderViewportMaskNV",
        "SignedZeroInfNanPreserve",
        "SparseResidency",
        "StencilExportEXT",
        "StorageBuffer16BitAccess",
        "StorageBuffer8BitAccess",
        "StorageBufferArrayDynamicIndexing",
        "StorageBufferArrayNonUniformIndexing",
        "StorageImageArrayDynamicIndexing",
        "StorageImageArrayNonUniformIndexing",
        "StorageImageExtendedFormats",
        "StorageImageMultisample",
        "StorageImageReadWithoutFormat",
        "StorageImageWriteWithoutFormat",
        "StorageInputOutput16",
        "StoragePushConstant16",
        "StoragePushConstant8",
        "StorageTensorArrayDynamicIndexingARM",
        "StorageTensorArrayNonUniformIndexingARM",
        "StorageTexelBufferArrayDynamicIndexing",
        "StorageTexelBufferArrayNonUniformIndexing",
        "SubgroupBallotKHR",
        "SubgroupVoteKHR",
        "TensorAddressingNV",
        "TensorsARM",
        "Tessellation",
        "TessellationPointSize",
        "TextureBlockMatch2QCOM",
        "TextureBlockMatchQCOM",
        "TextureBoxFilterQCOM",
        "TextureSampleWeightedQCOM",
        "TileImageColorReadAccessEXT",
        "TileImageDepthReadAccessEXT",
        "TileImageStencilReadAccessEXT",
        "TileShadingQCOM",
        "TransformFeedback",
        "UniformAndStorageBuffer16BitAccess",
        "UniformAndStorageBuffer8BitAccess",
        "UniformBufferArrayDynamicIndexing",
        "UniformBufferArrayNonUniformIndexing",
        "UniformTexelBufferArrayDynamicIndexing",
        "UniformTexelBufferArrayNonUniformIndexing",
        "UntypedPointersKHR",
        "VariablePointers",
        "VariablePointersStorageBuffer",
        "VulkanMemoryModel",
        "VulkanMemoryModelDeviceScope",
        "WorkgroupMemoryExplicitLayout16BitAccessKHR",
        "WorkgroupMemoryExplicitLayout8BitAccessKHR",
        "WorkgroupMemoryExplicitLayoutKHR",
    };
    return capabilities;
}

namespace {

// AtomicFloat16AddEXT
bool check_capability_AtomicFloat16AddEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_shader_atomic_float2)
    if (enabled_extensions.contains(VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME)) {
        if (features.get_feature("shaderBufferFloat16AtomicAdd") ||
            features.get_feature("shaderSharedFloat16AtomicAdd")) {
            return true;
        }
    }

    return false;
}

// AtomicFloat16MinMaxEXT
bool check_capability_AtomicFloat16MinMaxEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_shader_atomic_float2)
    if (enabled_extensions.contains(VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME)) {
        if (features.get_feature("shaderBufferFloat16AtomicMinMax") ||
            features.get_feature("shaderSharedFloat16AtomicMinMax")) {
            return true;
        }
    }

    return false;
}

// AtomicFloat16VectorNV
bool check_capability_AtomicFloat16VectorNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_NV_shader_atomic_float16_vector)
    if (enabled_extensions.contains(VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_EXTENSION_NAME)) {
        if (features.get_feature("shaderFloat16VectorAtomics")) {
            return true;
        }
    }

    return false;
}

// AtomicFloat32AddEXT
bool check_capability_AtomicFloat32AddEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_shader_atomic_float)
    if (enabled_extensions.contains(VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME)) {
        if (features.get_feature("shaderBufferFloat32AtomicAdd") ||
            features.get_feature("shaderSharedFloat32AtomicAdd") ||
            features.get_feature("shaderImageFloat32AtomicAdd")) {
            return true;
        }
    }

    return false;
}

// AtomicFloat32MinMaxEXT
bool check_capability_AtomicFloat32MinMaxEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_shader_atomic_float2)
    if (enabled_extensions.contains(VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME)) {
        if (features.get_feature("shaderBufferFloat32AtomicMinMax") ||
            features.get_feature("shaderSharedFloat32AtomicMinMax") ||
            features.get_feature("shaderImageFloat32AtomicMinMax")) {
            return true;
        }
    }

    return false;
}

// AtomicFloat64AddEXT
bool check_capability_AtomicFloat64AddEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_shader_atomic_float)
    if (enabled_extensions.contains(VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME)) {
        if (features.get_feature("shaderBufferFloat64AtomicAdd") ||
            features.get_feature("shaderSharedFloat64AtomicAdd")) {
            return true;
        }
    }

    return false;
}

// AtomicFloat64MinMaxEXT
bool check_capability_AtomicFloat64MinMaxEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_shader_atomic_float2)
    if (enabled_extensions.contains(VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME)) {
        if (features.get_feature("shaderBufferFloat64AtomicMinMax") ||
            features.get_feature("shaderSharedFloat64AtomicMinMax")) {
            return true;
        }
    }

    return false;
}

// BFloat16CooperativeMatrixKHR
bool check_capability_BFloat16CooperativeMatrixKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_KHR_shader_bfloat16)
    if (enabled_extensions.contains(VK_KHR_SHADER_BFLOAT16_EXTENSION_NAME)) {
        if (features.get_feature("shaderBFloat16CooperativeMatrix")) {
            return true;
        }
    }

    return false;
}

// BFloat16DotProductKHR
bool check_capability_BFloat16DotProductKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_KHR_shader_bfloat16)
    if (enabled_extensions.contains(VK_KHR_SHADER_BFLOAT16_EXTENSION_NAME)) {
        if (features.get_feature("shaderBFloat16DotProduct")) {
            return true;
        }
    }

    return false;
}

// BFloat16TypeKHR
bool check_capability_BFloat16TypeKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_KHR_shader_bfloat16)
    if (enabled_extensions.contains(VK_KHR_SHADER_BFLOAT16_EXTENSION_NAME)) {
        if (features.get_feature("shaderBFloat16Type")) {
            return true;
        }
    }

    return false;
}

// ClipDistance
bool check_capability_ClipDistance(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("shaderClipDistance")) {
            return true;
        }
    }

    return false;
}

// ClusterCullingShadingHUAWEI
bool check_capability_ClusterCullingShadingHUAWEI(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_HUAWEI_cluster_culling_shader)
    if (enabled_extensions.contains(VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME)) {
        if (features.get_feature("clustercullingShader")) {
            return true;
        }
    }

    return false;
}

// ComputeDerivativeGroupLinearKHR
bool check_capability_ComputeDerivativeGroupLinearKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_KHR_compute_shader_derivatives)
    if (enabled_extensions.contains(VK_KHR_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME)) {
        if (features.get_feature("computeDerivativeGroupLinear")) {
            return true;
        }
    }

    // Enable: requires (VK_NV_compute_shader_derivatives)
    if (enabled_extensions.contains(VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME)) {
        if (features.get_feature("computeDerivativeGroupLinear")) {
            return true;
        }
    }

    return false;
}

// ComputeDerivativeGroupQuadsKHR
bool check_capability_ComputeDerivativeGroupQuadsKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_KHR_compute_shader_derivatives)
    if (enabled_extensions.contains(VK_KHR_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME)) {
        if (features.get_feature("computeDerivativeGroupQuads")) {
            return true;
        }
    }

    // Enable: requires (VK_NV_compute_shader_derivatives)
    if (enabled_extensions.contains(VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME)) {
        if (features.get_feature("computeDerivativeGroupQuads")) {
            return true;
        }
    }

    return false;
}

// CooperativeMatrixBlockLoadsNV
bool check_capability_CooperativeMatrixBlockLoadsNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_NV_cooperative_matrix2)
    if (enabled_extensions.contains(VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME)) {
        if (features.get_feature("cooperativeMatrixBlockLoads")) {
            return true;
        }
    }

    return false;
}

// CooperativeMatrixConversionQCOM
bool check_capability_CooperativeMatrixConversionQCOM(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_QCOM_cooperative_matrix_conversion)
    if (enabled_extensions.contains(VK_QCOM_COOPERATIVE_MATRIX_CONVERSION_EXTENSION_NAME)) {
        if (features.get_feature("cooperativeMatrixConversion")) {
            return true;
        }
    }

    return false;
}

// CooperativeMatrixConversionsNV
bool check_capability_CooperativeMatrixConversionsNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_NV_cooperative_matrix2)
    if (enabled_extensions.contains(VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME)) {
        if (features.get_feature("cooperativeMatrixConversions")) {
            return true;
        }
    }

    return false;
}

// CooperativeMatrixKHR
bool check_capability_CooperativeMatrixKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_KHR_cooperative_matrix)
    if (enabled_extensions.contains(VK_KHR_COOPERATIVE_MATRIX_EXTENSION_NAME)) {
        if (features.get_feature("cooperativeMatrix")) {
            return true;
        }
    }

    return false;
}

// CooperativeMatrixNV
bool check_capability_CooperativeMatrixNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_NV_cooperative_matrix)
    if (enabled_extensions.contains(VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME)) {
        if (features.get_feature("cooperativeMatrix")) {
            return true;
        }
    }

    return false;
}

// CooperativeMatrixPerElementOperationsNV
bool check_capability_CooperativeMatrixPerElementOperationsNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_NV_cooperative_matrix2)
    if (enabled_extensions.contains(VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME)) {
        if (features.get_feature("cooperativeMatrixPerElementOperations")) {
            return true;
        }
    }

    return false;
}

// CooperativeMatrixReductionsNV
bool check_capability_CooperativeMatrixReductionsNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_NV_cooperative_matrix2)
    if (enabled_extensions.contains(VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME)) {
        if (features.get_feature("cooperativeMatrixReductions")) {
            return true;
        }
    }

    return false;
}

// CooperativeMatrixTensorAddressingNV
bool check_capability_CooperativeMatrixTensorAddressingNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_NV_cooperative_matrix2)
    if (enabled_extensions.contains(VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME)) {
        if (features.get_feature("cooperativeMatrixTensorAddressing")) {
            return true;
        }
    }

    return false;
}

// CooperativeVectorNV
bool check_capability_CooperativeVectorNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_NV_cooperative_vector)
    if (enabled_extensions.contains(VK_NV_COOPERATIVE_VECTOR_EXTENSION_NAME)) {
        if (features.get_feature("cooperativeVector")) {
            return true;
        }
    }

    return false;
}

// CooperativeVectorTrainingNV
bool check_capability_CooperativeVectorTrainingNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_NV_cooperative_vector)
    if (enabled_extensions.contains(VK_NV_COOPERATIVE_VECTOR_EXTENSION_NAME)) {
        if (features.get_feature("cooperativeVectorTraining")) {
            return true;
        }
    }

    return false;
}

// CoreBuiltinsARM
bool check_capability_CoreBuiltinsARM(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_ARM_shader_core_builtins)
    if (enabled_extensions.contains(VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME)) {
        if (features.get_feature("shaderCoreBuiltins")) {
            return true;
        }
    }

    return false;
}

// CullDistance
bool check_capability_CullDistance(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("shaderCullDistance")) {
            return true;
        }
    }

    return false;
}

// DemoteToHelperInvocation
bool check_capability_DemoteToHelperInvocation(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_3,VK_EXT_shader_demote_to_helper_invocation)
    if (vk_api_version >= VK_API_VERSION_1_3 || enabled_extensions.contains(VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME)) {
        if (features.get_feature("shaderDemoteToHelperInvocation")) {
            return true;
        }
    }

    // Enable: requires (VK_EXT_shader_demote_to_helper_invocation)
    if (enabled_extensions.contains(VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME)) {
        if (features.get_feature("shaderDemoteToHelperInvocation")) {
            return true;
        }
    }

    return false;
}

// DenormFlushToZero
bool check_capability_DenormFlushToZero(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_KHR_shader_float_controls)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME)) {
        if ((properties.is_available<vk::PhysicalDeviceFloatControlsProperties>() && properties.get<vk::PhysicalDeviceFloatControlsProperties>().shaderDenormFlushToZeroFloat16 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsPropertiesKHR>() && properties.get<vk::PhysicalDeviceFloatControlsPropertiesKHR>().shaderDenormFlushToZeroFloat16 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceVulkan12Properties>() && properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderDenormFlushToZeroFloat16 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsProperties>() && properties.get<vk::PhysicalDeviceFloatControlsProperties>().shaderDenormFlushToZeroFloat32 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsPropertiesKHR>() && properties.get<vk::PhysicalDeviceFloatControlsPropertiesKHR>().shaderDenormFlushToZeroFloat32 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceVulkan12Properties>() && properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderDenormFlushToZeroFloat32 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsProperties>() && properties.get<vk::PhysicalDeviceFloatControlsProperties>().shaderDenormFlushToZeroFloat64 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsPropertiesKHR>() && properties.get<vk::PhysicalDeviceFloatControlsPropertiesKHR>().shaderDenormFlushToZeroFloat64 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceVulkan12Properties>() && properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderDenormFlushToZeroFloat64 == VK_TRUE)) {
            return true;
        }
    }

    return false;
}

// DenormPreserve
bool check_capability_DenormPreserve(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_KHR_shader_float_controls)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME)) {
        if ((properties.is_available<vk::PhysicalDeviceFloatControlsProperties>() && properties.get<vk::PhysicalDeviceFloatControlsProperties>().shaderDenormPreserveFloat16 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsPropertiesKHR>() && properties.get<vk::PhysicalDeviceFloatControlsPropertiesKHR>().shaderDenormPreserveFloat16 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceVulkan12Properties>() && properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderDenormPreserveFloat16 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsProperties>() && properties.get<vk::PhysicalDeviceFloatControlsProperties>().shaderDenormPreserveFloat32 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsPropertiesKHR>() && properties.get<vk::PhysicalDeviceFloatControlsPropertiesKHR>().shaderDenormPreserveFloat32 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceVulkan12Properties>() && properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderDenormPreserveFloat32 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsProperties>() && properties.get<vk::PhysicalDeviceFloatControlsProperties>().shaderDenormPreserveFloat64 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsPropertiesKHR>() && properties.get<vk::PhysicalDeviceFloatControlsPropertiesKHR>().shaderDenormPreserveFloat64 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceVulkan12Properties>() && properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderDenormPreserveFloat64 == VK_TRUE)) {
            return true;
        }
    }

    return false;
}

// DerivativeControl
bool check_capability_DerivativeControl(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (vk_api_version >= VK_API_VERSION_1_0) {
        return true;
    }

    return false;
}

// DescriptorHeapEXT
bool check_capability_DescriptorHeapEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_descriptor_heap)
    if (enabled_extensions.contains(VK_EXT_DESCRIPTOR_HEAP_EXTENSION_NAME)) {
        if (features.get_feature("descriptorHeap")) {
            return true;
        }
    }

    return false;
}

// DeviceGroup
bool check_capability_DeviceGroup(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (vk_api_version >= VK_API_VERSION_1_1 ||
        enabled_extensions.contains(VK_KHR_DEVICE_GROUP_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// DotProduct
bool check_capability_DotProduct(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_3,VK_KHR_shader_integer_dot_product)
    if (vk_api_version >= VK_API_VERSION_1_3 || enabled_extensions.contains(VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME)) {
        if (features.get_feature("shaderIntegerDotProduct")) {
            return true;
        }
    }

    // Enable: requires (VK_KHR_shader_integer_dot_product)
    if (enabled_extensions.contains(VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME)) {
        if (features.get_feature("shaderIntegerDotProduct")) {
            return true;
        }
    }

    return false;
}

// DotProductInput4x8Bit
bool check_capability_DotProductInput4x8Bit(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_3,VK_KHR_shader_integer_dot_product)
    if (vk_api_version >= VK_API_VERSION_1_3 || enabled_extensions.contains(VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME)) {
        if (features.get_feature("shaderIntegerDotProduct")) {
            return true;
        }
    }

    // Enable: requires (VK_KHR_shader_integer_dot_product)
    if (enabled_extensions.contains(VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME)) {
        if (features.get_feature("shaderIntegerDotProduct")) {
            return true;
        }
    }

    return false;
}

// DotProductInput4x8BitPacked
bool check_capability_DotProductInput4x8BitPacked(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_3,VK_KHR_shader_integer_dot_product)
    if (vk_api_version >= VK_API_VERSION_1_3 || enabled_extensions.contains(VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME)) {
        if (features.get_feature("shaderIntegerDotProduct")) {
            return true;
        }
    }

    // Enable: requires (VK_KHR_shader_integer_dot_product)
    if (enabled_extensions.contains(VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME)) {
        if (features.get_feature("shaderIntegerDotProduct")) {
            return true;
        }
    }

    return false;
}

// DotProductInputAll
bool check_capability_DotProductInputAll(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_3,VK_KHR_shader_integer_dot_product)
    if (vk_api_version >= VK_API_VERSION_1_3 || enabled_extensions.contains(VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME)) {
        if (features.get_feature("shaderIntegerDotProduct")) {
            return true;
        }
    }

    // Enable: requires (VK_KHR_shader_integer_dot_product)
    if (enabled_extensions.contains(VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME)) {
        if (features.get_feature("shaderIntegerDotProduct")) {
            return true;
        }
    }

    return false;
}

// DrawParameters
bool check_capability_DrawParameters(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2)
    if (vk_api_version >= VK_API_VERSION_1_2) {
        if (features.get_feature("shaderDrawParameters")) {
            return true;
        }
    }

    // Enable: requires (VK_VERSION_1_1)
    if (vk_api_version >= VK_API_VERSION_1_1) {
        if (features.get_feature("shaderDrawParameters")) {
            return true;
        }
    }

    // Enable: no requires
    if (enabled_extensions.contains(VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// ExpectAssumeKHR
bool check_capability_ExpectAssumeKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_4,VK_KHR_shader_expect_assume)
    if (vk_api_version >= VK_API_VERSION_1_4 || enabled_extensions.contains(VK_KHR_SHADER_EXPECT_ASSUME_EXTENSION_NAME)) {
        if (features.get_feature("shaderExpectAssume")) {
            return true;
        }
    }

    // Enable: requires (VK_KHR_shader_expect_assume)
    if (enabled_extensions.contains(VK_KHR_SHADER_EXPECT_ASSUME_EXTENSION_NAME)) {
        if (features.get_feature("shaderExpectAssume")) {
            return true;
        }
    }

    return false;
}

// FMAKHR
bool check_capability_FMAKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_KHR_shader_fma)
    if (enabled_extensions.contains(VK_KHR_SHADER_FMA_EXTENSION_NAME)) {
        if (features.get_feature("shaderFmaFloat16") ||
            features.get_feature("shaderFmaFloat32") ||
            features.get_feature("shaderFmaFloat64")) {
            return true;
        }
    }

    return false;
}

// Float16
bool check_capability_Float16(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_KHR_shader_float16_int8)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME)) {
        if (features.get_feature("shaderFloat16")) {
            return true;
        }
    }

    // Enable: no requires
    if (enabled_extensions.contains(VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// Float64
bool check_capability_Float64(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("shaderFloat64")) {
            return true;
        }
    }

    return false;
}

// Float8CooperativeMatrixEXT
bool check_capability_Float8CooperativeMatrixEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_shader_float8)
    if (enabled_extensions.contains(VK_EXT_SHADER_FLOAT8_EXTENSION_NAME)) {
        if (features.get_feature("shaderFloat8CooperativeMatrix")) {
            return true;
        }
    }

    return false;
}

// Float8EXT
bool check_capability_Float8EXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_shader_float8)
    if (enabled_extensions.contains(VK_EXT_SHADER_FLOAT8_EXTENSION_NAME)) {
        if (features.get_feature("shaderFloat8")) {
            return true;
        }
    }

    return false;
}

// FloatControls2
bool check_capability_FloatControls2(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_4,VK_KHR_shader_float_controls2)
    if (vk_api_version >= VK_API_VERSION_1_4 || enabled_extensions.contains(VK_KHR_SHADER_FLOAT_CONTROLS_2_EXTENSION_NAME)) {
        if (features.get_feature("shaderFloatControls2")) {
            return true;
        }
    }

    // Enable: requires (VK_KHR_shader_float_controls2)
    if (enabled_extensions.contains(VK_KHR_SHADER_FLOAT_CONTROLS_2_EXTENSION_NAME)) {
        if (features.get_feature("shaderFloatControls2")) {
            return true;
        }
    }

    return false;
}

// FragmentBarycentricKHR
bool check_capability_FragmentBarycentricKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_KHR_fragment_shader_barycentric)
    if (enabled_extensions.contains(VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME)) {
        if (features.get_feature("fragmentShaderBarycentric")) {
            return true;
        }
    }

    // Enable: requires (VK_NV_fragment_shader_barycentric)
    if (enabled_extensions.contains(VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME)) {
        if (features.get_feature("fragmentShaderBarycentric")) {
            return true;
        }
    }

    return false;
}

// FragmentDensityEXT
bool check_capability_FragmentDensityEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_fragment_density_map)
    if (enabled_extensions.contains(VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME)) {
        if (features.get_feature("fragmentDensityMap")) {
            return true;
        }
    }

    // Enable: requires (VK_NV_shading_rate_image)
    if (enabled_extensions.contains(VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME)) {
        if (features.get_feature("shadingRateImage")) {
            return true;
        }
    }

    return false;
}

// FragmentFullyCoveredEXT
bool check_capability_FragmentFullyCoveredEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (enabled_extensions.contains(VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// FragmentMaskAMD
bool check_capability_FragmentMaskAMD(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (enabled_extensions.contains(VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// FragmentShaderPixelInterlockEXT
bool check_capability_FragmentShaderPixelInterlockEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_fragment_shader_interlock)
    if (enabled_extensions.contains(VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME)) {
        if (features.get_feature("fragmentShaderPixelInterlock")) {
            return true;
        }
    }

    return false;
}

// FragmentShaderSampleInterlockEXT
bool check_capability_FragmentShaderSampleInterlockEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_fragment_shader_interlock)
    if (enabled_extensions.contains(VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME)) {
        if (features.get_feature("fragmentShaderSampleInterlock")) {
            return true;
        }
    }

    return false;
}

// FragmentShaderShadingRateInterlockEXT
bool check_capability_FragmentShaderShadingRateInterlockEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_fragment_shader_interlock)
    if (enabled_extensions.contains(VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME)) {
        if (features.get_feature("fragmentShaderShadingRateInterlock")) {
            return true;
        }
    }

    // Enable: requires (VK_NV_shading_rate_image)
    if (enabled_extensions.contains(VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME)) {
        if (features.get_feature("shadingRateImage")) {
            return true;
        }
    }

    return false;
}

// FragmentShadingRateKHR
bool check_capability_FragmentShadingRateKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_KHR_fragment_shading_rate)
    if (enabled_extensions.contains(VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME)) {
        if (features.get_feature("pipelineFragmentShadingRate") ||
            features.get_feature("primitiveFragmentShadingRate") ||
            features.get_feature("attachmentFragmentShadingRate")) {
            return true;
        }
    }

    return false;
}

// Geometry
bool check_capability_Geometry(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("geometryShader")) {
            return true;
        }
    }

    return false;
}

// GeometryPointSize
bool check_capability_GeometryPointSize(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("shaderTessellationAndGeometryPointSize")) {
            return true;
        }
    }

    return false;
}

// GeometryShaderPassthroughNV
bool check_capability_GeometryShaderPassthroughNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (enabled_extensions.contains(VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// GeometryStreams
bool check_capability_GeometryStreams(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_transform_feedback)
    if (enabled_extensions.contains(VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME)) {
        if (features.get_feature("geometryStreams")) {
            return true;
        }
    }

    return false;
}

// GraphARM
bool check_capability_GraphARM(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_ARM_data_graph)
    if (enabled_extensions.contains(VK_ARM_DATA_GRAPH_EXTENSION_NAME)) {
        if (features.get_feature("dataGraph")) {
            return true;
        }
    }

    return false;
}

// GroupNonUniform
bool check_capability_GroupNonUniform(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_1)
    if (vk_api_version >= VK_API_VERSION_1_1) {
        if ((properties.is_available<vk::PhysicalDeviceSubgroupProperties>() && (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceSubgroupProperties>().supportedOperations) & VK_SUBGROUP_FEATURE_BASIC_BIT)) ||
            (properties.is_available<vk::PhysicalDeviceVulkan11Properties>() && (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceVulkan11Properties>().subgroupSupportedOperations) & VK_SUBGROUP_FEATURE_BASIC_BIT))) {
            return true;
        }
    }

    return false;
}

// GroupNonUniformArithmetic
bool check_capability_GroupNonUniformArithmetic(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_1)
    if (vk_api_version >= VK_API_VERSION_1_1) {
        if ((properties.is_available<vk::PhysicalDeviceSubgroupProperties>() && (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceSubgroupProperties>().supportedOperations) & VK_SUBGROUP_FEATURE_ARITHMETIC_BIT)) ||
            (properties.is_available<vk::PhysicalDeviceVulkan11Properties>() && (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceVulkan11Properties>().subgroupSupportedOperations) & VK_SUBGROUP_FEATURE_ARITHMETIC_BIT))) {
            return true;
        }
    }

    return false;
}

// GroupNonUniformBallot
bool check_capability_GroupNonUniformBallot(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_1)
    if (vk_api_version >= VK_API_VERSION_1_1) {
        if ((properties.is_available<vk::PhysicalDeviceSubgroupProperties>() && (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceSubgroupProperties>().supportedOperations) & VK_SUBGROUP_FEATURE_BALLOT_BIT)) ||
            (properties.is_available<vk::PhysicalDeviceVulkan11Properties>() && (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceVulkan11Properties>().subgroupSupportedOperations) & VK_SUBGROUP_FEATURE_BALLOT_BIT))) {
            return true;
        }
    }

    return false;
}

// GroupNonUniformClustered
bool check_capability_GroupNonUniformClustered(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_1)
    if (vk_api_version >= VK_API_VERSION_1_1) {
        if ((properties.is_available<vk::PhysicalDeviceSubgroupProperties>() && (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceSubgroupProperties>().supportedOperations) & VK_SUBGROUP_FEATURE_CLUSTERED_BIT)) ||
            (properties.is_available<vk::PhysicalDeviceVulkan11Properties>() && (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceVulkan11Properties>().subgroupSupportedOperations) & VK_SUBGROUP_FEATURE_CLUSTERED_BIT))) {
            return true;
        }
    }

    return false;
}

// GroupNonUniformPartitionedEXT
bool check_capability_GroupNonUniformPartitionedEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_shader_subgroup_partitioned)
    if (enabled_extensions.contains(VK_EXT_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME)) {
        if (features.get_feature("shaderSubgroupPartitioned")) {
            return true;
        }
    }

    // Enable: requires (VK_NV_shader_subgroup_partitioned)
    if (enabled_extensions.contains(VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME)) {
        if ((properties.is_available<vk::PhysicalDeviceSubgroupProperties>() && (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceSubgroupProperties>().supportedOperations) & VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV)) ||
            (properties.is_available<vk::PhysicalDeviceVulkan11Properties>() && (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceVulkan11Properties>().subgroupSupportedOperations) & VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV))) {
            return true;
        }
    }

    return false;
}

// GroupNonUniformQuad
bool check_capability_GroupNonUniformQuad(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_1)
    if (vk_api_version >= VK_API_VERSION_1_1) {
        if ((properties.is_available<vk::PhysicalDeviceSubgroupProperties>() && (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceSubgroupProperties>().supportedOperations) & VK_SUBGROUP_FEATURE_QUAD_BIT)) ||
            (properties.is_available<vk::PhysicalDeviceVulkan11Properties>() && (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceVulkan11Properties>().subgroupSupportedOperations) & VK_SUBGROUP_FEATURE_QUAD_BIT))) {
            return true;
        }
    }

    return false;
}

// GroupNonUniformRotateKHR
bool check_capability_GroupNonUniformRotateKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_4,VK_KHR_shader_subgroup_rotate)
    if (vk_api_version >= VK_API_VERSION_1_4 || enabled_extensions.contains(VK_KHR_SHADER_SUBGROUP_ROTATE_EXTENSION_NAME)) {
        if (features.get_feature("shaderSubgroupRotate")) {
            return true;
        }
    }

    // Enable: requires (VK_KHR_shader_subgroup_rotate)
    if (enabled_extensions.contains(VK_KHR_SHADER_SUBGROUP_ROTATE_EXTENSION_NAME)) {
        if (features.get_feature("shaderSubgroupRotate")) {
            return true;
        }
    }

    return false;
}

// GroupNonUniformShuffle
bool check_capability_GroupNonUniformShuffle(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_1)
    if (vk_api_version >= VK_API_VERSION_1_1) {
        if ((properties.is_available<vk::PhysicalDeviceSubgroupProperties>() && (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceSubgroupProperties>().supportedOperations) & VK_SUBGROUP_FEATURE_SHUFFLE_BIT)) ||
            (properties.is_available<vk::PhysicalDeviceVulkan11Properties>() && (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceVulkan11Properties>().subgroupSupportedOperations) & VK_SUBGROUP_FEATURE_SHUFFLE_BIT))) {
            return true;
        }
    }

    return false;
}

// GroupNonUniformShuffleRelative
bool check_capability_GroupNonUniformShuffleRelative(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_1)
    if (vk_api_version >= VK_API_VERSION_1_1) {
        if ((properties.is_available<vk::PhysicalDeviceSubgroupProperties>() && (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceSubgroupProperties>().supportedOperations) & VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT)) ||
            (properties.is_available<vk::PhysicalDeviceVulkan11Properties>() && (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceVulkan11Properties>().subgroupSupportedOperations) & VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT))) {
            return true;
        }
    }

    return false;
}

// GroupNonUniformVote
bool check_capability_GroupNonUniformVote(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_1)
    if (vk_api_version >= VK_API_VERSION_1_1) {
        if ((properties.is_available<vk::PhysicalDeviceSubgroupProperties>() && (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceSubgroupProperties>().supportedOperations) & VK_SUBGROUP_FEATURE_VOTE_BIT)) ||
            (properties.is_available<vk::PhysicalDeviceVulkan11Properties>() && (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceVulkan11Properties>().subgroupSupportedOperations) & VK_SUBGROUP_FEATURE_VOTE_BIT))) {
            return true;
        }
    }

    return false;
}

// Image1D
bool check_capability_Image1D(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (vk_api_version >= VK_API_VERSION_1_0) {
        return true;
    }

    return false;
}

// ImageBuffer
bool check_capability_ImageBuffer(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (vk_api_version >= VK_API_VERSION_1_0) {
        return true;
    }

    return false;
}

// ImageCubeArray
bool check_capability_ImageCubeArray(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("imageCubeArray")) {
            return true;
        }
    }

    return false;
}

// ImageFootprintNV
bool check_capability_ImageFootprintNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_NV_shader_image_footprint)
    if (enabled_extensions.contains(VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME)) {
        if (features.get_feature("imageFootprint")) {
            return true;
        }
    }

    return false;
}

// ImageGatherBiasLodAMD
bool check_capability_ImageGatherBiasLodAMD(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (enabled_extensions.contains(VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// ImageGatherExtended
bool check_capability_ImageGatherExtended(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("shaderImageGatherExtended")) {
            return true;
        }
    }

    return false;
}

// ImageMSArray
bool check_capability_ImageMSArray(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("shaderStorageImageMultisample")) {
            return true;
        }
    }

    return false;
}

// ImageQuery
bool check_capability_ImageQuery(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (vk_api_version >= VK_API_VERSION_1_0) {
        return true;
    }

    return false;
}

// ImageReadWriteLodAMD
bool check_capability_ImageReadWriteLodAMD(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (enabled_extensions.contains(VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// InputAttachment
bool check_capability_InputAttachment(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (vk_api_version >= VK_API_VERSION_1_0) {
        return true;
    }

    return false;
}

// InputAttachmentArrayDynamicIndexing
bool check_capability_InputAttachmentArrayDynamicIndexing(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_EXT_descriptor_indexing)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME)) {
        if (features.get_feature("shaderInputAttachmentArrayDynamicIndexing")) {
            return true;
        }
    }

    return false;
}

// InputAttachmentArrayNonUniformIndexing
bool check_capability_InputAttachmentArrayNonUniformIndexing(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_EXT_descriptor_indexing)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME)) {
        if (features.get_feature("shaderInputAttachmentArrayNonUniformIndexing")) {
            return true;
        }
    }

    return false;
}

// Int16
bool check_capability_Int16(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("shaderInt16")) {
            return true;
        }
    }

    return false;
}

// Int64
bool check_capability_Int64(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("shaderInt64")) {
            return true;
        }
    }

    return false;
}

// Int64Atomics
bool check_capability_Int64Atomics(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_KHR_shader_atomic_int64)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME)) {
        if (features.get_feature("shaderBufferInt64Atomics") ||
            features.get_feature("shaderSharedInt64Atomics")) {
            return true;
        }
    }

    // Enable: requires (VK_EXT_shader_image_atomic_int64)
    if (enabled_extensions.contains(VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME)) {
        if (features.get_feature("shaderImageInt64Atomics")) {
            return true;
        }
    }

    return false;
}

// Int64ImageEXT
bool check_capability_Int64ImageEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_shader_image_atomic_int64)
    if (enabled_extensions.contains(VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME)) {
        if (features.get_feature("shaderImageInt64Atomics")) {
            return true;
        }
    }

    return false;
}

// Int8
bool check_capability_Int8(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_KHR_shader_float16_int8)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME)) {
        if (features.get_feature("shaderInt8")) {
            return true;
        }
    }

    return false;
}

// IntegerFunctions2INTEL
bool check_capability_IntegerFunctions2INTEL(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_INTEL_shader_integer_functions2)
    if (enabled_extensions.contains(VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME)) {
        if (features.get_feature("shaderIntegerFunctions2")) {
            return true;
        }
    }

    return false;
}

// InterpolationFunction
bool check_capability_InterpolationFunction(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("sampleRateShading")) {
            return true;
        }
    }

    return false;
}

// LongVectorEXT
bool check_capability_LongVectorEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_shader_long_vector)
    if (enabled_extensions.contains(VK_EXT_SHADER_LONG_VECTOR_EXTENSION_NAME)) {
        if (features.get_feature("longVector")) {
            return true;
        }
    }

    return false;
}

// Matrix
bool check_capability_Matrix(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (vk_api_version >= VK_API_VERSION_1_0) {
        return true;
    }

    return false;
}

// MeshShadingEXT
bool check_capability_MeshShadingEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (enabled_extensions.contains(VK_EXT_MESH_SHADER_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// MeshShadingNV
bool check_capability_MeshShadingNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (enabled_extensions.contains(VK_NV_MESH_SHADER_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// MinLod
bool check_capability_MinLod(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("shaderResourceMinLod")) {
            return true;
        }
    }

    return false;
}

// MultiView
bool check_capability_MultiView(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2)
    if (vk_api_version >= VK_API_VERSION_1_2) {
        if (features.get_feature("multiview")) {
            return true;
        }
    }

    // Enable: requires (VK_KHR_multiview)
    if (enabled_extensions.contains(VK_KHR_MULTIVIEW_EXTENSION_NAME)) {
        if (features.get_feature("multiview")) {
            return true;
        }
    }

    return false;
}

// MultiViewport
bool check_capability_MultiViewport(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("multiViewport")) {
            return true;
        }
    }

    return false;
}

// PerViewAttributesNV
bool check_capability_PerViewAttributesNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (enabled_extensions.contains(VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// PhysicalStorageBufferAddresses
bool check_capability_PhysicalStorageBufferAddresses(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_KHR_buffer_device_address)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME)) {
        if (features.get_feature("bufferDeviceAddress")) {
            return true;
        }
    }

    // Enable: requires (VK_EXT_buffer_device_address)
    if (enabled_extensions.contains(VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME)) {
        if (features.get_feature("bufferDeviceAddress")) {
            return true;
        }
    }

    return false;
}

// PushConstantBanksNV
bool check_capability_PushConstantBanksNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_NV_push_constant_bank)
    if (enabled_extensions.contains(VK_NV_PUSH_CONSTANT_BANK_EXTENSION_NAME)) {
        if (features.get_feature("pushConstantBank")) {
            return true;
        }
    }

    return false;
}

// QuadControlKHR
bool check_capability_QuadControlKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_KHR_shader_quad_control)
    if (enabled_extensions.contains(VK_KHR_SHADER_QUAD_CONTROL_EXTENSION_NAME)) {
        if (features.get_feature("shaderQuadControl")) {
            return true;
        }
    }

    return false;
}

// RawAccessChainsNV
bool check_capability_RawAccessChainsNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_NV_raw_access_chains)
    if (enabled_extensions.contains(VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME)) {
        if (features.get_feature("shaderRawAccessChains")) {
            return true;
        }
    }

    return false;
}

// RayCullMaskKHR
bool check_capability_RayCullMaskKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_KHR_ray_tracing_maintenance1)
    if (enabled_extensions.contains(VK_KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME)) {
        if (features.get_feature("rayTracingMaintenance1")) {
            return true;
        }
    }

    return false;
}

// RayQueryKHR
bool check_capability_RayQueryKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_KHR_ray_query)
    if (enabled_extensions.contains(VK_KHR_RAY_QUERY_EXTENSION_NAME)) {
        if (features.get_feature("rayQuery")) {
            return true;
        }
    }

    return false;
}

// RayQueryPositionFetchKHR
bool check_capability_RayQueryPositionFetchKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_KHR_ray_tracing_position_fetch)
    if (enabled_extensions.contains(VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME)) {
        if (features.get_feature("rayTracingPositionFetch")) {
            return true;
        }
    }

    return false;
}

// RayTracingClusterAccelerationStructureNV
bool check_capability_RayTracingClusterAccelerationStructureNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_NV_cluster_acceleration_structure)
    if (enabled_extensions.contains(VK_NV_CLUSTER_ACCELERATION_STRUCTURE_EXTENSION_NAME)) {
        if (features.get_feature("clusterAccelerationStructure")) {
            return true;
        }
    }

    return false;
}

// RayTracingKHR
bool check_capability_RayTracingKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_KHR_ray_tracing_pipeline)
    if (enabled_extensions.contains(VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME)) {
        if (features.get_feature("rayTracingPipeline")) {
            return true;
        }
    }

    return false;
}

// RayTracingLinearSweptSpheresGeometryNV
bool check_capability_RayTracingLinearSweptSpheresGeometryNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_NV_ray_tracing_linear_swept_spheres)
    if (enabled_extensions.contains(VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_EXTENSION_NAME)) {
        if (features.get_feature("linearSweptSpheres")) {
            return true;
        }
    }

    return false;
}

// RayTracingMotionBlurNV
bool check_capability_RayTracingMotionBlurNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_NV_ray_tracing_motion_blur)
    if (enabled_extensions.contains(VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME)) {
        if (features.get_feature("rayTracingMotionBlur")) {
            return true;
        }
    }

    return false;
}

// RayTracingNV
bool check_capability_RayTracingNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (enabled_extensions.contains(VK_NV_RAY_TRACING_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// RayTracingOpacityMicromapEXT
bool check_capability_RayTracingOpacityMicromapEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (enabled_extensions.contains(VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// RayTracingPositionFetchKHR
bool check_capability_RayTracingPositionFetchKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_KHR_ray_tracing_position_fetch)
    if (enabled_extensions.contains(VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME)) {
        if (features.get_feature("rayTracingPositionFetch")) {
            return true;
        }
    }

    return false;
}

// RayTracingSpheresGeometryNV
bool check_capability_RayTracingSpheresGeometryNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_NV_ray_tracing_linear_swept_spheres)
    if (enabled_extensions.contains(VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_EXTENSION_NAME)) {
        if (features.get_feature("spheres")) {
            return true;
        }
    }

    return false;
}

// RayTraversalPrimitiveCullingKHR
bool check_capability_RayTraversalPrimitiveCullingKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_KHR_ray_tracing_pipeline)
    if (enabled_extensions.contains(VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME)) {
        if (features.get_feature("rayTraversalPrimitiveCulling")) {
            return true;
        }
    }

    // Enable: requires (VK_KHR_ray_query)
    if (enabled_extensions.contains(VK_KHR_RAY_QUERY_EXTENSION_NAME)) {
        if (features.get_feature("rayQuery")) {
            return true;
        }
    }

    return false;
}

// ReplicatedCompositesEXT
bool check_capability_ReplicatedCompositesEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_shader_replicated_composites)
    if (enabled_extensions.contains(VK_EXT_SHADER_REPLICATED_COMPOSITES_EXTENSION_NAME)) {
        if (features.get_feature("shaderReplicatedComposites")) {
            return true;
        }
    }

    return false;
}

// RoundingModeRTE
bool check_capability_RoundingModeRTE(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_KHR_shader_float_controls)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME)) {
        if ((properties.is_available<vk::PhysicalDeviceFloatControlsProperties>() && properties.get<vk::PhysicalDeviceFloatControlsProperties>().shaderRoundingModeRTEFloat16 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsPropertiesKHR>() && properties.get<vk::PhysicalDeviceFloatControlsPropertiesKHR>().shaderRoundingModeRTEFloat16 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceVulkan12Properties>() && properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderRoundingModeRTEFloat16 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsProperties>() && properties.get<vk::PhysicalDeviceFloatControlsProperties>().shaderRoundingModeRTEFloat32 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsPropertiesKHR>() && properties.get<vk::PhysicalDeviceFloatControlsPropertiesKHR>().shaderRoundingModeRTEFloat32 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceVulkan12Properties>() && properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderRoundingModeRTEFloat32 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsProperties>() && properties.get<vk::PhysicalDeviceFloatControlsProperties>().shaderRoundingModeRTEFloat64 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsPropertiesKHR>() && properties.get<vk::PhysicalDeviceFloatControlsPropertiesKHR>().shaderRoundingModeRTEFloat64 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceVulkan12Properties>() && properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderRoundingModeRTEFloat64 == VK_TRUE)) {
            return true;
        }
    }

    return false;
}

// RoundingModeRTZ
bool check_capability_RoundingModeRTZ(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_KHR_shader_float_controls)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME)) {
        if ((properties.is_available<vk::PhysicalDeviceFloatControlsProperties>() && properties.get<vk::PhysicalDeviceFloatControlsProperties>().shaderRoundingModeRTZFloat16 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsPropertiesKHR>() && properties.get<vk::PhysicalDeviceFloatControlsPropertiesKHR>().shaderRoundingModeRTZFloat16 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceVulkan12Properties>() && properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderRoundingModeRTZFloat16 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsProperties>() && properties.get<vk::PhysicalDeviceFloatControlsProperties>().shaderRoundingModeRTZFloat32 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsPropertiesKHR>() && properties.get<vk::PhysicalDeviceFloatControlsPropertiesKHR>().shaderRoundingModeRTZFloat32 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceVulkan12Properties>() && properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderRoundingModeRTZFloat32 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsProperties>() && properties.get<vk::PhysicalDeviceFloatControlsProperties>().shaderRoundingModeRTZFloat64 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsPropertiesKHR>() && properties.get<vk::PhysicalDeviceFloatControlsPropertiesKHR>().shaderRoundingModeRTZFloat64 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceVulkan12Properties>() && properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderRoundingModeRTZFloat64 == VK_TRUE)) {
            return true;
        }
    }

    return false;
}

// RuntimeDescriptorArray
bool check_capability_RuntimeDescriptorArray(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_EXT_descriptor_indexing)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME)) {
        if (features.get_feature("runtimeDescriptorArray")) {
            return true;
        }
    }

    return false;
}

// SampleMaskOverrideCoverageNV
bool check_capability_SampleMaskOverrideCoverageNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (enabled_extensions.contains(VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// SampleMaskPostDepthCoverage
bool check_capability_SampleMaskPostDepthCoverage(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (enabled_extensions.contains(VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// SampleRateShading
bool check_capability_SampleRateShading(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("sampleRateShading")) {
            return true;
        }
    }

    return false;
}

// Sampled1D
bool check_capability_Sampled1D(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (vk_api_version >= VK_API_VERSION_1_0) {
        return true;
    }

    return false;
}

// SampledBuffer
bool check_capability_SampledBuffer(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (vk_api_version >= VK_API_VERSION_1_0) {
        return true;
    }

    return false;
}

// SampledCubeArray
bool check_capability_SampledCubeArray(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("imageCubeArray")) {
            return true;
        }
    }

    return false;
}

// SampledImageArrayDynamicIndexing
bool check_capability_SampledImageArrayDynamicIndexing(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("shaderSampledImageArrayDynamicIndexing")) {
            return true;
        }
    }

    return false;
}

// SampledImageArrayNonUniformIndexing
bool check_capability_SampledImageArrayNonUniformIndexing(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_EXT_descriptor_indexing)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME)) {
        if (features.get_feature("shaderSampledImageArrayNonUniformIndexing")) {
            return true;
        }
    }

    return false;
}

// Shader
bool check_capability_Shader(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (vk_api_version >= VK_API_VERSION_1_0) {
        return true;
    }

    return false;
}

// Shader64BitIndexingEXT
bool check_capability_Shader64BitIndexingEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_shader_64bit_indexing)
    if (enabled_extensions.contains(VK_EXT_SHADER_64BIT_INDEXING_EXTENSION_NAME)) {
        if (features.get_feature("shader64BitIndexing")) {
            return true;
        }
    }

    return false;
}

// ShaderClockKHR
bool check_capability_ShaderClockKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (enabled_extensions.contains(VK_KHR_SHADER_CLOCK_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// ShaderEnqueueAMDX
bool check_capability_ShaderEnqueueAMDX(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (features.get_feature("shaderEnqueue")) {
        return true;
    }

    return false;
}

// ShaderInvocationReorderEXT
bool check_capability_ShaderInvocationReorderEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (enabled_extensions.contains(VK_EXT_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// ShaderInvocationReorderNV
bool check_capability_ShaderInvocationReorderNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (enabled_extensions.contains(VK_NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// ShaderLayer
bool check_capability_ShaderLayer(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2)
    if (vk_api_version >= VK_API_VERSION_1_2) {
        if (features.get_feature("shaderOutputLayer")) {
            return true;
        }
    }

    return false;
}

// ShaderNonUniform
bool check_capability_ShaderNonUniform(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (vk_api_version >= VK_API_VERSION_1_2 ||
        enabled_extensions.contains(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// ShaderSMBuiltinsNV
bool check_capability_ShaderSMBuiltinsNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_NV_shader_sm_builtins)
    if (enabled_extensions.contains(VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME)) {
        if (features.get_feature("shaderSMBuiltins")) {
            return true;
        }
    }

    return false;
}

// ShaderViewportIndex
bool check_capability_ShaderViewportIndex(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2)
    if (vk_api_version >= VK_API_VERSION_1_2) {
        if (features.get_feature("shaderOutputViewportIndex")) {
            return true;
        }
    }

    return false;
}

// ShaderViewportIndexLayerEXT
bool check_capability_ShaderViewportIndexLayerEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (enabled_extensions.contains(VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME) ||
        enabled_extensions.contains(VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// ShaderViewportMaskNV
bool check_capability_ShaderViewportMaskNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (enabled_extensions.contains(VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// SignedZeroInfNanPreserve
bool check_capability_SignedZeroInfNanPreserve(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_KHR_shader_float_controls)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME)) {
        if ((properties.is_available<vk::PhysicalDeviceFloatControlsProperties>() && properties.get<vk::PhysicalDeviceFloatControlsProperties>().shaderSignedZeroInfNanPreserveFloat16 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsPropertiesKHR>() && properties.get<vk::PhysicalDeviceFloatControlsPropertiesKHR>().shaderSignedZeroInfNanPreserveFloat16 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceVulkan12Properties>() && properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderSignedZeroInfNanPreserveFloat16 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsProperties>() && properties.get<vk::PhysicalDeviceFloatControlsProperties>().shaderSignedZeroInfNanPreserveFloat32 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsPropertiesKHR>() && properties.get<vk::PhysicalDeviceFloatControlsPropertiesKHR>().shaderSignedZeroInfNanPreserveFloat32 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceVulkan12Properties>() && properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderSignedZeroInfNanPreserveFloat32 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsProperties>() && properties.get<vk::PhysicalDeviceFloatControlsProperties>().shaderSignedZeroInfNanPreserveFloat64 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceFloatControlsPropertiesKHR>() && properties.get<vk::PhysicalDeviceFloatControlsPropertiesKHR>().shaderSignedZeroInfNanPreserveFloat64 == VK_TRUE) ||
            (properties.is_available<vk::PhysicalDeviceVulkan12Properties>() && properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderSignedZeroInfNanPreserveFloat64 == VK_TRUE)) {
            return true;
        }
    }

    return false;
}

// SparseResidency
bool check_capability_SparseResidency(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("shaderResourceResidency")) {
            return true;
        }
    }

    return false;
}

// StencilExportEXT
bool check_capability_StencilExportEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (enabled_extensions.contains(VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// StorageBuffer16BitAccess
bool check_capability_StorageBuffer16BitAccess(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2)
    if (vk_api_version >= VK_API_VERSION_1_2) {
        if (features.get_feature("storageBuffer16BitAccess")) {
            return true;
        }
    }

    // Enable: requires (VK_KHR_16bit_storage)
    if (enabled_extensions.contains(VK_KHR_16BIT_STORAGE_EXTENSION_NAME)) {
        if (features.get_feature("storageBuffer16BitAccess")) {
            return true;
        }
    }

    return false;
}

// StorageBuffer8BitAccess
bool check_capability_StorageBuffer8BitAccess(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_KHR_8bit_storage)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_KHR_8BIT_STORAGE_EXTENSION_NAME)) {
        if (features.get_feature("storageBuffer8BitAccess")) {
            return true;
        }
    }

    return false;
}

// StorageBufferArrayDynamicIndexing
bool check_capability_StorageBufferArrayDynamicIndexing(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("shaderStorageBufferArrayDynamicIndexing")) {
            return true;
        }
    }

    return false;
}

// StorageBufferArrayNonUniformIndexing
bool check_capability_StorageBufferArrayNonUniformIndexing(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_EXT_descriptor_indexing)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME)) {
        if (features.get_feature("shaderStorageBufferArrayNonUniformIndexing")) {
            return true;
        }
    }

    return false;
}

// StorageImageArrayDynamicIndexing
bool check_capability_StorageImageArrayDynamicIndexing(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("shaderStorageImageArrayDynamicIndexing")) {
            return true;
        }
    }

    return false;
}

// StorageImageArrayNonUniformIndexing
bool check_capability_StorageImageArrayNonUniformIndexing(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_EXT_descriptor_indexing)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME)) {
        if (features.get_feature("shaderStorageImageArrayNonUniformIndexing")) {
            return true;
        }
    }

    return false;
}

// StorageImageExtendedFormats
bool check_capability_StorageImageExtendedFormats(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (vk_api_version >= VK_API_VERSION_1_0) {
        return true;
    }

    return false;
}

// StorageImageMultisample
bool check_capability_StorageImageMultisample(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("shaderStorageImageMultisample")) {
            return true;
        }
    }

    return false;
}

// StorageImageReadWithoutFormat
bool check_capability_StorageImageReadWithoutFormat(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("shaderStorageImageReadWithoutFormat")) {
            return true;
        }
    }

    // Enable: no requires
    if (vk_api_version >= VK_API_VERSION_1_3 ||
        enabled_extensions.contains(VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// StorageImageWriteWithoutFormat
bool check_capability_StorageImageWriteWithoutFormat(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("shaderStorageImageWriteWithoutFormat")) {
            return true;
        }
    }

    // Enable: no requires
    if (vk_api_version >= VK_API_VERSION_1_3 ||
        enabled_extensions.contains(VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// StorageInputOutput16
bool check_capability_StorageInputOutput16(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2)
    if (vk_api_version >= VK_API_VERSION_1_2) {
        if (features.get_feature("storageInputOutput16")) {
            return true;
        }
    }

    // Enable: requires (VK_KHR_16bit_storage)
    if (enabled_extensions.contains(VK_KHR_16BIT_STORAGE_EXTENSION_NAME)) {
        if (features.get_feature("storageInputOutput16")) {
            return true;
        }
    }

    return false;
}

// StoragePushConstant16
bool check_capability_StoragePushConstant16(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2)
    if (vk_api_version >= VK_API_VERSION_1_2) {
        if (features.get_feature("storagePushConstant16")) {
            return true;
        }
    }

    // Enable: requires (VK_KHR_16bit_storage)
    if (enabled_extensions.contains(VK_KHR_16BIT_STORAGE_EXTENSION_NAME)) {
        if (features.get_feature("storagePushConstant16")) {
            return true;
        }
    }

    return false;
}

// StoragePushConstant8
bool check_capability_StoragePushConstant8(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_KHR_8bit_storage)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_KHR_8BIT_STORAGE_EXTENSION_NAME)) {
        if (features.get_feature("storagePushConstant8")) {
            return true;
        }
    }

    return false;
}

// StorageTensorArrayDynamicIndexingARM
bool check_capability_StorageTensorArrayDynamicIndexingARM(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_ARM_tensors)
    if (enabled_extensions.contains(VK_ARM_TENSORS_EXTENSION_NAME)) {
        if (features.get_feature("shaderStorageTensorArrayDynamicIndexing")) {
            return true;
        }
    }

    return false;
}

// StorageTensorArrayNonUniformIndexingARM
bool check_capability_StorageTensorArrayNonUniformIndexingARM(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_ARM_tensors)
    if (enabled_extensions.contains(VK_ARM_TENSORS_EXTENSION_NAME)) {
        if (features.get_feature("shaderStorageTensorArrayNonUniformIndexing")) {
            return true;
        }
    }

    return false;
}

// StorageTexelBufferArrayDynamicIndexing
bool check_capability_StorageTexelBufferArrayDynamicIndexing(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_EXT_descriptor_indexing)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME)) {
        if (features.get_feature("shaderStorageTexelBufferArrayDynamicIndexing")) {
            return true;
        }
    }

    return false;
}

// StorageTexelBufferArrayNonUniformIndexing
bool check_capability_StorageTexelBufferArrayNonUniformIndexing(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_EXT_descriptor_indexing)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME)) {
        if (features.get_feature("shaderStorageTexelBufferArrayNonUniformIndexing")) {
            return true;
        }
    }

    return false;
}

// SubgroupBallotKHR
bool check_capability_SubgroupBallotKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (enabled_extensions.contains(VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// SubgroupVoteKHR
bool check_capability_SubgroupVoteKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: no requires
    if (enabled_extensions.contains(VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME)) {
        return true;
    }

    return false;
}

// TensorAddressingNV
bool check_capability_TensorAddressingNV(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_NV_cooperative_matrix2)
    if (enabled_extensions.contains(VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME)) {
        if (features.get_feature("cooperativeMatrixTensorAddressing")) {
            return true;
        }
    }

    return false;
}

// TensorsARM
bool check_capability_TensorsARM(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_ARM_tensors)
    if (enabled_extensions.contains(VK_ARM_TENSORS_EXTENSION_NAME)) {
        if (features.get_feature("shaderTensorAccess")) {
            return true;
        }
    }

    return false;
}

// Tessellation
bool check_capability_Tessellation(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("tessellationShader")) {
            return true;
        }
    }

    return false;
}

// TessellationPointSize
bool check_capability_TessellationPointSize(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("shaderTessellationAndGeometryPointSize")) {
            return true;
        }
    }

    return false;
}

// TextureBlockMatch2QCOM
bool check_capability_TextureBlockMatch2QCOM(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_QCOM_image_processing2)
    if (enabled_extensions.contains(VK_QCOM_IMAGE_PROCESSING_2_EXTENSION_NAME)) {
        if (features.get_feature("textureBlockMatch2")) {
            return true;
        }
    }

    return false;
}

// TextureBlockMatchQCOM
bool check_capability_TextureBlockMatchQCOM(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_QCOM_image_processing)
    if (enabled_extensions.contains(VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME)) {
        if (features.get_feature("textureBlockMatch")) {
            return true;
        }
    }

    return false;
}

// TextureBoxFilterQCOM
bool check_capability_TextureBoxFilterQCOM(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_QCOM_image_processing)
    if (enabled_extensions.contains(VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME)) {
        if (features.get_feature("textureBoxFilter")) {
            return true;
        }
    }

    return false;
}

// TextureSampleWeightedQCOM
bool check_capability_TextureSampleWeightedQCOM(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_QCOM_image_processing)
    if (enabled_extensions.contains(VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME)) {
        if (features.get_feature("textureSampleWeighted")) {
            return true;
        }
    }

    return false;
}

// TileImageColorReadAccessEXT
bool check_capability_TileImageColorReadAccessEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_shader_tile_image)
    if (enabled_extensions.contains(VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME)) {
        if (features.get_feature("shaderTileImageColorReadAccess")) {
            return true;
        }
    }

    return false;
}

// TileImageDepthReadAccessEXT
bool check_capability_TileImageDepthReadAccessEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_shader_tile_image)
    if (enabled_extensions.contains(VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME)) {
        if (features.get_feature("shaderTileImageDepthReadAccess")) {
            return true;
        }
    }

    return false;
}

// TileImageStencilReadAccessEXT
bool check_capability_TileImageStencilReadAccessEXT(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_shader_tile_image)
    if (enabled_extensions.contains(VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME)) {
        if (features.get_feature("shaderTileImageStencilReadAccess")) {
            return true;
        }
    }

    return false;
}

// TileShadingQCOM
bool check_capability_TileShadingQCOM(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_QCOM_tile_shading)
    if (enabled_extensions.contains(VK_QCOM_TILE_SHADING_EXTENSION_NAME)) {
        if (features.get_feature("tileShading")) {
            return true;
        }
    }

    return false;
}

// TransformFeedback
bool check_capability_TransformFeedback(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_EXT_transform_feedback)
    if (enabled_extensions.contains(VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME)) {
        if (features.get_feature("transformFeedback")) {
            return true;
        }
    }

    return false;
}

// UniformAndStorageBuffer16BitAccess
bool check_capability_UniformAndStorageBuffer16BitAccess(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2)
    if (vk_api_version >= VK_API_VERSION_1_2) {
        if (features.get_feature("uniformAndStorageBuffer16BitAccess")) {
            return true;
        }
    }

    // Enable: requires (VK_KHR_16bit_storage)
    if (enabled_extensions.contains(VK_KHR_16BIT_STORAGE_EXTENSION_NAME)) {
        if (features.get_feature("uniformAndStorageBuffer16BitAccess")) {
            return true;
        }
    }

    return false;
}

// UniformAndStorageBuffer8BitAccess
bool check_capability_UniformAndStorageBuffer8BitAccess(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_KHR_8bit_storage)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_KHR_8BIT_STORAGE_EXTENSION_NAME)) {
        if (features.get_feature("uniformAndStorageBuffer8BitAccess")) {
            return true;
        }
    }

    return false;
}

// UniformBufferArrayDynamicIndexing
bool check_capability_UniformBufferArrayDynamicIndexing(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_0)
    if (vk_api_version >= VK_API_VERSION_1_0) {
        if (features.get_feature("shaderUniformBufferArrayDynamicIndexing")) {
            return true;
        }
    }

    return false;
}

// UniformBufferArrayNonUniformIndexing
bool check_capability_UniformBufferArrayNonUniformIndexing(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_EXT_descriptor_indexing)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME)) {
        if (features.get_feature("shaderUniformBufferArrayNonUniformIndexing")) {
            return true;
        }
    }

    return false;
}

// UniformTexelBufferArrayDynamicIndexing
bool check_capability_UniformTexelBufferArrayDynamicIndexing(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_EXT_descriptor_indexing)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME)) {
        if (features.get_feature("shaderUniformTexelBufferArrayDynamicIndexing")) {
            return true;
        }
    }

    return false;
}

// UniformTexelBufferArrayNonUniformIndexing
bool check_capability_UniformTexelBufferArrayNonUniformIndexing(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_EXT_descriptor_indexing)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME)) {
        if (features.get_feature("shaderUniformTexelBufferArrayNonUniformIndexing")) {
            return true;
        }
    }

    return false;
}

// UntypedPointersKHR
bool check_capability_UntypedPointersKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_KHR_shader_untyped_pointers)
    if (enabled_extensions.contains(VK_KHR_SHADER_UNTYPED_POINTERS_EXTENSION_NAME)) {
        if (features.get_feature("shaderUntypedPointers")) {
            return true;
        }
    }

    return false;
}

// VariablePointers
bool check_capability_VariablePointers(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2)
    if (vk_api_version >= VK_API_VERSION_1_2) {
        if (features.get_feature("variablePointers")) {
            return true;
        }
    }

    // Enable: requires (VK_KHR_variable_pointers)
    if (enabled_extensions.contains(VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME)) {
        if (features.get_feature("variablePointers")) {
            return true;
        }
    }

    return false;
}

// VariablePointersStorageBuffer
bool check_capability_VariablePointersStorageBuffer(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2)
    if (vk_api_version >= VK_API_VERSION_1_2) {
        if (features.get_feature("variablePointersStorageBuffer")) {
            return true;
        }
    }

    // Enable: requires (VK_KHR_variable_pointers)
    if (enabled_extensions.contains(VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME)) {
        if (features.get_feature("variablePointersStorageBuffer")) {
            return true;
        }
    }

    return false;
}

// VulkanMemoryModel
bool check_capability_VulkanMemoryModel(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_KHR_vulkan_memory_model)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME)) {
        if (features.get_feature("vulkanMemoryModel")) {
            return true;
        }
    }

    return false;
}

// VulkanMemoryModelDeviceScope
bool check_capability_VulkanMemoryModelDeviceScope(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_VERSION_1_2,VK_KHR_vulkan_memory_model)
    if (vk_api_version >= VK_API_VERSION_1_2 || enabled_extensions.contains(VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME)) {
        if (features.get_feature("vulkanMemoryModelDeviceScope")) {
            return true;
        }
    }

    return false;
}

// WorkgroupMemoryExplicitLayout16BitAccessKHR
bool check_capability_WorkgroupMemoryExplicitLayout16BitAccessKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_KHR_workgroup_memory_explicit_layout)
    if (enabled_extensions.contains(VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME)) {
        if (features.get_feature("workgroupMemoryExplicitLayout16BitAccess")) {
            return true;
        }
    }

    return false;
}

// WorkgroupMemoryExplicitLayout8BitAccessKHR
bool check_capability_WorkgroupMemoryExplicitLayout8BitAccessKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_KHR_workgroup_memory_explicit_layout)
    if (enabled_extensions.contains(VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME)) {
        if (features.get_feature("workgroupMemoryExplicitLayout8BitAccess")) {
            return true;
        }
    }

    return false;
}

// WorkgroupMemoryExplicitLayoutKHR
bool check_capability_WorkgroupMemoryExplicitLayoutKHR(
    [[maybe_unused]] uint32_t vk_api_version,
    [[maybe_unused]] const std::unordered_set<std::string>& enabled_extensions,
    [[maybe_unused]] const VulkanFeatures& features,
    [[maybe_unused]] const VulkanProperties& properties) {

    // Enable: requires (VK_KHR_workgroup_memory_explicit_layout)
    if (enabled_extensions.contains(VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME)) {
        if (features.get_feature("workgroupMemoryExplicitLayout")) {
            return true;
        }
    }

    return false;
}

// Capability dispatch map
using CapCheckFn = bool(*)(uint32_t, const std::unordered_set<std::string>&,
                           const VulkanFeatures&, const VulkanProperties&);

// NOLINTNEXTLINE(cert-err58-cpp)
const std::unordered_map<std::string_view, CapCheckFn> capability_check_map = {
    {"AtomicFloat16AddEXT", check_capability_AtomicFloat16AddEXT},
    {"AtomicFloat16MinMaxEXT", check_capability_AtomicFloat16MinMaxEXT},
    {"AtomicFloat16VectorNV", check_capability_AtomicFloat16VectorNV},
    {"AtomicFloat32AddEXT", check_capability_AtomicFloat32AddEXT},
    {"AtomicFloat32MinMaxEXT", check_capability_AtomicFloat32MinMaxEXT},
    {"AtomicFloat64AddEXT", check_capability_AtomicFloat64AddEXT},
    {"AtomicFloat64MinMaxEXT", check_capability_AtomicFloat64MinMaxEXT},
    {"BFloat16CooperativeMatrixKHR", check_capability_BFloat16CooperativeMatrixKHR},
    {"BFloat16DotProductKHR", check_capability_BFloat16DotProductKHR},
    {"BFloat16TypeKHR", check_capability_BFloat16TypeKHR},
    {"ClipDistance", check_capability_ClipDistance},
    {"ClusterCullingShadingHUAWEI", check_capability_ClusterCullingShadingHUAWEI},
    {"ComputeDerivativeGroupLinearKHR", check_capability_ComputeDerivativeGroupLinearKHR},
    {"ComputeDerivativeGroupQuadsKHR", check_capability_ComputeDerivativeGroupQuadsKHR},
    {"CooperativeMatrixBlockLoadsNV", check_capability_CooperativeMatrixBlockLoadsNV},
    {"CooperativeMatrixConversionQCOM", check_capability_CooperativeMatrixConversionQCOM},
    {"CooperativeMatrixConversionsNV", check_capability_CooperativeMatrixConversionsNV},
    {"CooperativeMatrixKHR", check_capability_CooperativeMatrixKHR},
    {"CooperativeMatrixNV", check_capability_CooperativeMatrixNV},
    {"CooperativeMatrixPerElementOperationsNV", check_capability_CooperativeMatrixPerElementOperationsNV},
    {"CooperativeMatrixReductionsNV", check_capability_CooperativeMatrixReductionsNV},
    {"CooperativeMatrixTensorAddressingNV", check_capability_CooperativeMatrixTensorAddressingNV},
    {"CooperativeVectorNV", check_capability_CooperativeVectorNV},
    {"CooperativeVectorTrainingNV", check_capability_CooperativeVectorTrainingNV},
    {"CoreBuiltinsARM", check_capability_CoreBuiltinsARM},
    {"CullDistance", check_capability_CullDistance},
    {"DemoteToHelperInvocation", check_capability_DemoteToHelperInvocation},
    {"DenormFlushToZero", check_capability_DenormFlushToZero},
    {"DenormPreserve", check_capability_DenormPreserve},
    {"DerivativeControl", check_capability_DerivativeControl},
    {"DescriptorHeapEXT", check_capability_DescriptorHeapEXT},
    {"DeviceGroup", check_capability_DeviceGroup},
    {"DotProduct", check_capability_DotProduct},
    {"DotProductInput4x8Bit", check_capability_DotProductInput4x8Bit},
    {"DotProductInput4x8BitPacked", check_capability_DotProductInput4x8BitPacked},
    {"DotProductInputAll", check_capability_DotProductInputAll},
    {"DrawParameters", check_capability_DrawParameters},
    {"ExpectAssumeKHR", check_capability_ExpectAssumeKHR},
    {"FMAKHR", check_capability_FMAKHR},
    {"Float16", check_capability_Float16},
    {"Float64", check_capability_Float64},
    {"Float8CooperativeMatrixEXT", check_capability_Float8CooperativeMatrixEXT},
    {"Float8EXT", check_capability_Float8EXT},
    {"FloatControls2", check_capability_FloatControls2},
    {"FragmentBarycentricKHR", check_capability_FragmentBarycentricKHR},
    {"FragmentDensityEXT", check_capability_FragmentDensityEXT},
    {"FragmentFullyCoveredEXT", check_capability_FragmentFullyCoveredEXT},
    {"FragmentMaskAMD", check_capability_FragmentMaskAMD},
    {"FragmentShaderPixelInterlockEXT", check_capability_FragmentShaderPixelInterlockEXT},
    {"FragmentShaderSampleInterlockEXT", check_capability_FragmentShaderSampleInterlockEXT},
    {"FragmentShaderShadingRateInterlockEXT", check_capability_FragmentShaderShadingRateInterlockEXT},
    {"FragmentShadingRateKHR", check_capability_FragmentShadingRateKHR},
    {"Geometry", check_capability_Geometry},
    {"GeometryPointSize", check_capability_GeometryPointSize},
    {"GeometryShaderPassthroughNV", check_capability_GeometryShaderPassthroughNV},
    {"GeometryStreams", check_capability_GeometryStreams},
    {"GraphARM", check_capability_GraphARM},
    {"GroupNonUniform", check_capability_GroupNonUniform},
    {"GroupNonUniformArithmetic", check_capability_GroupNonUniformArithmetic},
    {"GroupNonUniformBallot", check_capability_GroupNonUniformBallot},
    {"GroupNonUniformClustered", check_capability_GroupNonUniformClustered},
    {"GroupNonUniformPartitionedEXT", check_capability_GroupNonUniformPartitionedEXT},
    {"GroupNonUniformQuad", check_capability_GroupNonUniformQuad},
    {"GroupNonUniformRotateKHR", check_capability_GroupNonUniformRotateKHR},
    {"GroupNonUniformShuffle", check_capability_GroupNonUniformShuffle},
    {"GroupNonUniformShuffleRelative", check_capability_GroupNonUniformShuffleRelative},
    {"GroupNonUniformVote", check_capability_GroupNonUniformVote},
    {"Image1D", check_capability_Image1D},
    {"ImageBuffer", check_capability_ImageBuffer},
    {"ImageCubeArray", check_capability_ImageCubeArray},
    {"ImageFootprintNV", check_capability_ImageFootprintNV},
    {"ImageGatherBiasLodAMD", check_capability_ImageGatherBiasLodAMD},
    {"ImageGatherExtended", check_capability_ImageGatherExtended},
    {"ImageMSArray", check_capability_ImageMSArray},
    {"ImageQuery", check_capability_ImageQuery},
    {"ImageReadWriteLodAMD", check_capability_ImageReadWriteLodAMD},
    {"InputAttachment", check_capability_InputAttachment},
    {"InputAttachmentArrayDynamicIndexing", check_capability_InputAttachmentArrayDynamicIndexing},
    {"InputAttachmentArrayNonUniformIndexing", check_capability_InputAttachmentArrayNonUniformIndexing},
    {"Int16", check_capability_Int16},
    {"Int64", check_capability_Int64},
    {"Int64Atomics", check_capability_Int64Atomics},
    {"Int64ImageEXT", check_capability_Int64ImageEXT},
    {"Int8", check_capability_Int8},
    {"IntegerFunctions2INTEL", check_capability_IntegerFunctions2INTEL},
    {"InterpolationFunction", check_capability_InterpolationFunction},
    {"LongVectorEXT", check_capability_LongVectorEXT},
    {"Matrix", check_capability_Matrix},
    {"MeshShadingEXT", check_capability_MeshShadingEXT},
    {"MeshShadingNV", check_capability_MeshShadingNV},
    {"MinLod", check_capability_MinLod},
    {"MultiView", check_capability_MultiView},
    {"MultiViewport", check_capability_MultiViewport},
    {"PerViewAttributesNV", check_capability_PerViewAttributesNV},
    {"PhysicalStorageBufferAddresses", check_capability_PhysicalStorageBufferAddresses},
    {"PushConstantBanksNV", check_capability_PushConstantBanksNV},
    {"QuadControlKHR", check_capability_QuadControlKHR},
    {"RawAccessChainsNV", check_capability_RawAccessChainsNV},
    {"RayCullMaskKHR", check_capability_RayCullMaskKHR},
    {"RayQueryKHR", check_capability_RayQueryKHR},
    {"RayQueryPositionFetchKHR", check_capability_RayQueryPositionFetchKHR},
    {"RayTracingClusterAccelerationStructureNV", check_capability_RayTracingClusterAccelerationStructureNV},
    {"RayTracingKHR", check_capability_RayTracingKHR},
    {"RayTracingLinearSweptSpheresGeometryNV", check_capability_RayTracingLinearSweptSpheresGeometryNV},
    {"RayTracingMotionBlurNV", check_capability_RayTracingMotionBlurNV},
    {"RayTracingNV", check_capability_RayTracingNV},
    {"RayTracingOpacityMicromapEXT", check_capability_RayTracingOpacityMicromapEXT},
    {"RayTracingPositionFetchKHR", check_capability_RayTracingPositionFetchKHR},
    {"RayTracingSpheresGeometryNV", check_capability_RayTracingSpheresGeometryNV},
    {"RayTraversalPrimitiveCullingKHR", check_capability_RayTraversalPrimitiveCullingKHR},
    {"ReplicatedCompositesEXT", check_capability_ReplicatedCompositesEXT},
    {"RoundingModeRTE", check_capability_RoundingModeRTE},
    {"RoundingModeRTZ", check_capability_RoundingModeRTZ},
    {"RuntimeDescriptorArray", check_capability_RuntimeDescriptorArray},
    {"SampleMaskOverrideCoverageNV", check_capability_SampleMaskOverrideCoverageNV},
    {"SampleMaskPostDepthCoverage", check_capability_SampleMaskPostDepthCoverage},
    {"SampleRateShading", check_capability_SampleRateShading},
    {"Sampled1D", check_capability_Sampled1D},
    {"SampledBuffer", check_capability_SampledBuffer},
    {"SampledCubeArray", check_capability_SampledCubeArray},
    {"SampledImageArrayDynamicIndexing", check_capability_SampledImageArrayDynamicIndexing},
    {"SampledImageArrayNonUniformIndexing", check_capability_SampledImageArrayNonUniformIndexing},
    {"Shader", check_capability_Shader},
    {"Shader64BitIndexingEXT", check_capability_Shader64BitIndexingEXT},
    {"ShaderClockKHR", check_capability_ShaderClockKHR},
    {"ShaderEnqueueAMDX", check_capability_ShaderEnqueueAMDX},
    {"ShaderInvocationReorderEXT", check_capability_ShaderInvocationReorderEXT},
    {"ShaderInvocationReorderNV", check_capability_ShaderInvocationReorderNV},
    {"ShaderLayer", check_capability_ShaderLayer},
    {"ShaderNonUniform", check_capability_ShaderNonUniform},
    {"ShaderSMBuiltinsNV", check_capability_ShaderSMBuiltinsNV},
    {"ShaderViewportIndex", check_capability_ShaderViewportIndex},
    {"ShaderViewportIndexLayerEXT", check_capability_ShaderViewportIndexLayerEXT},
    {"ShaderViewportMaskNV", check_capability_ShaderViewportMaskNV},
    {"SignedZeroInfNanPreserve", check_capability_SignedZeroInfNanPreserve},
    {"SparseResidency", check_capability_SparseResidency},
    {"StencilExportEXT", check_capability_StencilExportEXT},
    {"StorageBuffer16BitAccess", check_capability_StorageBuffer16BitAccess},
    {"StorageBuffer8BitAccess", check_capability_StorageBuffer8BitAccess},
    {"StorageBufferArrayDynamicIndexing", check_capability_StorageBufferArrayDynamicIndexing},
    {"StorageBufferArrayNonUniformIndexing", check_capability_StorageBufferArrayNonUniformIndexing},
    {"StorageImageArrayDynamicIndexing", check_capability_StorageImageArrayDynamicIndexing},
    {"StorageImageArrayNonUniformIndexing", check_capability_StorageImageArrayNonUniformIndexing},
    {"StorageImageExtendedFormats", check_capability_StorageImageExtendedFormats},
    {"StorageImageMultisample", check_capability_StorageImageMultisample},
    {"StorageImageReadWithoutFormat", check_capability_StorageImageReadWithoutFormat},
    {"StorageImageWriteWithoutFormat", check_capability_StorageImageWriteWithoutFormat},
    {"StorageInputOutput16", check_capability_StorageInputOutput16},
    {"StoragePushConstant16", check_capability_StoragePushConstant16},
    {"StoragePushConstant8", check_capability_StoragePushConstant8},
    {"StorageTensorArrayDynamicIndexingARM", check_capability_StorageTensorArrayDynamicIndexingARM},
    {"StorageTensorArrayNonUniformIndexingARM", check_capability_StorageTensorArrayNonUniformIndexingARM},
    {"StorageTexelBufferArrayDynamicIndexing", check_capability_StorageTexelBufferArrayDynamicIndexing},
    {"StorageTexelBufferArrayNonUniformIndexing", check_capability_StorageTexelBufferArrayNonUniformIndexing},
    {"SubgroupBallotKHR", check_capability_SubgroupBallotKHR},
    {"SubgroupVoteKHR", check_capability_SubgroupVoteKHR},
    {"TensorAddressingNV", check_capability_TensorAddressingNV},
    {"TensorsARM", check_capability_TensorsARM},
    {"Tessellation", check_capability_Tessellation},
    {"TessellationPointSize", check_capability_TessellationPointSize},
    {"TextureBlockMatch2QCOM", check_capability_TextureBlockMatch2QCOM},
    {"TextureBlockMatchQCOM", check_capability_TextureBlockMatchQCOM},
    {"TextureBoxFilterQCOM", check_capability_TextureBoxFilterQCOM},
    {"TextureSampleWeightedQCOM", check_capability_TextureSampleWeightedQCOM},
    {"TileImageColorReadAccessEXT", check_capability_TileImageColorReadAccessEXT},
    {"TileImageDepthReadAccessEXT", check_capability_TileImageDepthReadAccessEXT},
    {"TileImageStencilReadAccessEXT", check_capability_TileImageStencilReadAccessEXT},
    {"TileShadingQCOM", check_capability_TileShadingQCOM},
    {"TransformFeedback", check_capability_TransformFeedback},
    {"UniformAndStorageBuffer16BitAccess", check_capability_UniformAndStorageBuffer16BitAccess},
    {"UniformAndStorageBuffer8BitAccess", check_capability_UniformAndStorageBuffer8BitAccess},
    {"UniformBufferArrayDynamicIndexing", check_capability_UniformBufferArrayDynamicIndexing},
    {"UniformBufferArrayNonUniformIndexing", check_capability_UniformBufferArrayNonUniformIndexing},
    {"UniformTexelBufferArrayDynamicIndexing", check_capability_UniformTexelBufferArrayDynamicIndexing},
    {"UniformTexelBufferArrayNonUniformIndexing", check_capability_UniformTexelBufferArrayNonUniformIndexing},
    {"UntypedPointersKHR", check_capability_UntypedPointersKHR},
    {"VariablePointers", check_capability_VariablePointers},
    {"VariablePointersStorageBuffer", check_capability_VariablePointersStorageBuffer},
    {"VulkanMemoryModel", check_capability_VulkanMemoryModel},
    {"VulkanMemoryModelDeviceScope", check_capability_VulkanMemoryModelDeviceScope},
    {"WorkgroupMemoryExplicitLayout16BitAccessKHR", check_capability_WorkgroupMemoryExplicitLayout16BitAccessKHR},
    {"WorkgroupMemoryExplicitLayout8BitAccessKHR", check_capability_WorkgroupMemoryExplicitLayout8BitAccessKHR},
    {"WorkgroupMemoryExplicitLayoutKHR", check_capability_WorkgroupMemoryExplicitLayoutKHR},
};

} // namespace

bool is_spirv_capability_supported(
    const char* capability,
    uint32_t vk_api_version,
    const std::unordered_set<std::string>& enabled_extensions,
    const VulkanFeatures& features,
    const VulkanProperties& properties) {

    const auto it = capability_check_map.find(capability);
    if (it == capability_check_map.end()) {
        return false;
    }
    return it->second(vk_api_version, enabled_extensions, features, properties);
}

namespace {
struct CapExtEntry {
    const char* ext;
    uint32_t below_version;
};

// NOLINTNEXTLINE(cert-err58-cpp)
const std::unordered_map<std::string_view, std::vector<CapExtEntry>> cap_ext_map = {
    {"AtomicFloat16AddEXT", {{VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME, 0}}},
    {"AtomicFloat16MinMaxEXT", {{VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME, 0}}},
    {"AtomicFloat16VectorNV", {{VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_EXTENSION_NAME, 0}}},
    {"AtomicFloat32AddEXT", {{VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME, 0}}},
    {"AtomicFloat32MinMaxEXT", {{VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME, 0}}},
    {"AtomicFloat64AddEXT", {{VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME, 0}}},
    {"AtomicFloat64MinMaxEXT", {{VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME, 0}}},
    {"BFloat16CooperativeMatrixKHR", {{VK_KHR_SHADER_BFLOAT16_EXTENSION_NAME, 0}}},
    {"BFloat16DotProductKHR", {{VK_KHR_SHADER_BFLOAT16_EXTENSION_NAME, 0}}},
    {"BFloat16TypeKHR", {{VK_KHR_SHADER_BFLOAT16_EXTENSION_NAME, 0}}},
    {"ClusterCullingShadingHUAWEI", {{VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME, 0}}},
    {"ComputeDerivativeGroupLinearKHR", {{VK_KHR_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME, 0}, {VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME, 0}}},
    {"ComputeDerivativeGroupQuadsKHR", {{VK_KHR_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME, 0}, {VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME, 0}}},
    {"CooperativeMatrixBlockLoadsNV", {{VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME, 0}}},
    {"CooperativeMatrixConversionQCOM", {{VK_QCOM_COOPERATIVE_MATRIX_CONVERSION_EXTENSION_NAME, 0}}},
    {"CooperativeMatrixConversionsNV", {{VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME, 0}}},
    {"CooperativeMatrixKHR", {{VK_KHR_COOPERATIVE_MATRIX_EXTENSION_NAME, 0}}},
    {"CooperativeMatrixNV", {{VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME, 0}}},
    {"CooperativeMatrixPerElementOperationsNV", {{VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME, 0}}},
    {"CooperativeMatrixReductionsNV", {{VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME, 0}}},
    {"CooperativeMatrixTensorAddressingNV", {{VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME, 0}}},
    {"CooperativeVectorNV", {{VK_NV_COOPERATIVE_VECTOR_EXTENSION_NAME, 0}}},
    {"CooperativeVectorTrainingNV", {{VK_NV_COOPERATIVE_VECTOR_EXTENSION_NAME, 0}}},
    {"CoreBuiltinsARM", {{VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME, 0}}},
    {"DemoteToHelperInvocation", {{VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME, VK_API_VERSION_1_3}}},
    {"DenormFlushToZero", {{VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME, VK_API_VERSION_1_2}}},
    {"DenormPreserve", {{VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME, VK_API_VERSION_1_2}}},
    {"DescriptorHeapEXT", {{VK_EXT_DESCRIPTOR_HEAP_EXTENSION_NAME, 0}}},
    {"DeviceGroup", {{VK_KHR_DEVICE_GROUP_EXTENSION_NAME, 0}}},
    {"DotProduct", {{VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME, VK_API_VERSION_1_3}}},
    {"DotProductInput4x8Bit", {{VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME, VK_API_VERSION_1_3}}},
    {"DotProductInput4x8BitPacked", {{VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME, VK_API_VERSION_1_3}}},
    {"DotProductInputAll", {{VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME, VK_API_VERSION_1_3}}},
    {"DrawParameters", {{VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME, 0}}},
    {"ExpectAssumeKHR", {{VK_KHR_SHADER_EXPECT_ASSUME_EXTENSION_NAME, VK_API_VERSION_1_4}}},
    {"FMAKHR", {{VK_KHR_SHADER_FMA_EXTENSION_NAME, 0}}},
    {"Float16", {{VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME, VK_API_VERSION_1_2}, {VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME, 0}}},
    {"Float8CooperativeMatrixEXT", {{VK_EXT_SHADER_FLOAT8_EXTENSION_NAME, 0}}},
    {"Float8EXT", {{VK_EXT_SHADER_FLOAT8_EXTENSION_NAME, 0}}},
    {"FloatControls2", {{VK_KHR_SHADER_FLOAT_CONTROLS_2_EXTENSION_NAME, VK_API_VERSION_1_4}}},
    {"FragmentBarycentricKHR", {{VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME, 0}, {VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME, 0}}},
    {"FragmentDensityEXT", {{VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME, 0}, {VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME, 0}}},
    {"FragmentFullyCoveredEXT", {{VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME, 0}}},
    {"FragmentMaskAMD", {{VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME, 0}}},
    {"FragmentShaderPixelInterlockEXT", {{VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME, 0}}},
    {"FragmentShaderSampleInterlockEXT", {{VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME, 0}}},
    {"FragmentShaderShadingRateInterlockEXT", {{VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME, 0}, {VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME, 0}}},
    {"FragmentShadingRateKHR", {{VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME, 0}}},
    {"GeometryShaderPassthroughNV", {{VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME, 0}}},
    {"GeometryStreams", {{VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME, 0}}},
    {"GraphARM", {{VK_ARM_DATA_GRAPH_EXTENSION_NAME, 0}}},
    {"GroupNonUniformPartitionedEXT", {{VK_EXT_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME, 0}, {VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME, 0}}},
    {"GroupNonUniformRotateKHR", {{VK_KHR_SHADER_SUBGROUP_ROTATE_EXTENSION_NAME, VK_API_VERSION_1_4}}},
    {"ImageFootprintNV", {{VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME, 0}}},
    {"ImageGatherBiasLodAMD", {{VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME, 0}}},
    {"ImageReadWriteLodAMD", {{VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME, 0}}},
    {"InputAttachmentArrayDynamicIndexing", {{VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME, VK_API_VERSION_1_2}}},
    {"InputAttachmentArrayNonUniformIndexing", {{VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME, VK_API_VERSION_1_2}}},
    {"Int64Atomics", {{VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME, VK_API_VERSION_1_2}, {VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME, 0}}},
    {"Int64ImageEXT", {{VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME, 0}}},
    {"Int8", {{VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME, VK_API_VERSION_1_2}}},
    {"IntegerFunctions2INTEL", {{VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME, 0}}},
    {"LongVectorEXT", {{VK_EXT_SHADER_LONG_VECTOR_EXTENSION_NAME, 0}}},
    {"MeshShadingEXT", {{VK_EXT_MESH_SHADER_EXTENSION_NAME, 0}}},
    {"MeshShadingNV", {{VK_NV_MESH_SHADER_EXTENSION_NAME, 0}}},
    {"MultiView", {{VK_KHR_MULTIVIEW_EXTENSION_NAME, 0}}},
    {"PerViewAttributesNV", {{VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME, 0}}},
    {"PhysicalStorageBufferAddresses", {{VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME, VK_API_VERSION_1_2}, {VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME, 0}}},
    {"PushConstantBanksNV", {{VK_NV_PUSH_CONSTANT_BANK_EXTENSION_NAME, 0}}},
    {"QuadControlKHR", {{VK_KHR_SHADER_QUAD_CONTROL_EXTENSION_NAME, 0}}},
    {"RawAccessChainsNV", {{VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME, 0}}},
    {"RayCullMaskKHR", {{VK_KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME, 0}}},
    {"RayQueryKHR", {{VK_KHR_RAY_QUERY_EXTENSION_NAME, 0}}},
    {"RayQueryPositionFetchKHR", {{VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME, 0}}},
    {"RayTracingClusterAccelerationStructureNV", {{VK_NV_CLUSTER_ACCELERATION_STRUCTURE_EXTENSION_NAME, 0}}},
    {"RayTracingKHR", {{VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME, 0}}},
    {"RayTracingLinearSweptSpheresGeometryNV", {{VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_EXTENSION_NAME, 0}}},
    {"RayTracingMotionBlurNV", {{VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME, 0}}},
    {"RayTracingNV", {{VK_NV_RAY_TRACING_EXTENSION_NAME, 0}}},
    {"RayTracingOpacityMicromapEXT", {{VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME, 0}}},
    {"RayTracingPositionFetchKHR", {{VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME, 0}}},
    {"RayTracingSpheresGeometryNV", {{VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_EXTENSION_NAME, 0}}},
    {"RayTraversalPrimitiveCullingKHR", {{VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME, 0}, {VK_KHR_RAY_QUERY_EXTENSION_NAME, 0}}},
    {"ReplicatedCompositesEXT", {{VK_EXT_SHADER_REPLICATED_COMPOSITES_EXTENSION_NAME, 0}}},
    {"RoundingModeRTE", {{VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME, VK_API_VERSION_1_2}}},
    {"RoundingModeRTZ", {{VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME, VK_API_VERSION_1_2}}},
    {"RuntimeDescriptorArray", {{VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME, VK_API_VERSION_1_2}}},
    {"SampleMaskOverrideCoverageNV", {{VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME, 0}}},
    {"SampleMaskPostDepthCoverage", {{VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME, 0}}},
    {"SampledImageArrayNonUniformIndexing", {{VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME, VK_API_VERSION_1_2}}},
    {"Shader64BitIndexingEXT", {{VK_EXT_SHADER_64BIT_INDEXING_EXTENSION_NAME, 0}}},
    {"ShaderClockKHR", {{VK_KHR_SHADER_CLOCK_EXTENSION_NAME, 0}}},
    {"ShaderInvocationReorderEXT", {{VK_EXT_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME, 0}}},
    {"ShaderInvocationReorderNV", {{VK_NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME, 0}}},
    {"ShaderNonUniform", {{VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME, 0}}},
    {"ShaderSMBuiltinsNV", {{VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME, 0}}},
    {"ShaderViewportIndexLayerEXT", {{VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME, 0}, {VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME, 0}}},
    {"ShaderViewportMaskNV", {{VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME, 0}}},
    {"SignedZeroInfNanPreserve", {{VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME, VK_API_VERSION_1_2}}},
    {"StencilExportEXT", {{VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME, 0}}},
    {"StorageBuffer16BitAccess", {{VK_KHR_16BIT_STORAGE_EXTENSION_NAME, 0}}},
    {"StorageBuffer8BitAccess", {{VK_KHR_8BIT_STORAGE_EXTENSION_NAME, VK_API_VERSION_1_2}}},
    {"StorageBufferArrayNonUniformIndexing", {{VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME, VK_API_VERSION_1_2}}},
    {"StorageImageArrayNonUniformIndexing", {{VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME, VK_API_VERSION_1_2}}},
    {"StorageImageReadWithoutFormat", {{VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME, 0}}},
    {"StorageImageWriteWithoutFormat", {{VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME, 0}}},
    {"StorageInputOutput16", {{VK_KHR_16BIT_STORAGE_EXTENSION_NAME, 0}}},
    {"StoragePushConstant16", {{VK_KHR_16BIT_STORAGE_EXTENSION_NAME, 0}}},
    {"StoragePushConstant8", {{VK_KHR_8BIT_STORAGE_EXTENSION_NAME, VK_API_VERSION_1_2}}},
    {"StorageTensorArrayDynamicIndexingARM", {{VK_ARM_TENSORS_EXTENSION_NAME, 0}}},
    {"StorageTensorArrayNonUniformIndexingARM", {{VK_ARM_TENSORS_EXTENSION_NAME, 0}}},
    {"StorageTexelBufferArrayDynamicIndexing", {{VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME, VK_API_VERSION_1_2}}},
    {"StorageTexelBufferArrayNonUniformIndexing", {{VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME, VK_API_VERSION_1_2}}},
    {"SubgroupBallotKHR", {{VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME, 0}}},
    {"SubgroupVoteKHR", {{VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME, 0}}},
    {"TensorAddressingNV", {{VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME, 0}}},
    {"TensorsARM", {{VK_ARM_TENSORS_EXTENSION_NAME, 0}}},
    {"TextureBlockMatch2QCOM", {{VK_QCOM_IMAGE_PROCESSING_2_EXTENSION_NAME, 0}}},
    {"TextureBlockMatchQCOM", {{VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME, 0}}},
    {"TextureBoxFilterQCOM", {{VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME, 0}}},
    {"TextureSampleWeightedQCOM", {{VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME, 0}}},
    {"TileImageColorReadAccessEXT", {{VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME, 0}}},
    {"TileImageDepthReadAccessEXT", {{VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME, 0}}},
    {"TileImageStencilReadAccessEXT", {{VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME, 0}}},
    {"TileShadingQCOM", {{VK_QCOM_TILE_SHADING_EXTENSION_NAME, 0}}},
    {"TransformFeedback", {{VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME, 0}}},
    {"UniformAndStorageBuffer16BitAccess", {{VK_KHR_16BIT_STORAGE_EXTENSION_NAME, 0}}},
    {"UniformAndStorageBuffer8BitAccess", {{VK_KHR_8BIT_STORAGE_EXTENSION_NAME, VK_API_VERSION_1_2}}},
    {"UniformBufferArrayNonUniformIndexing", {{VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME, VK_API_VERSION_1_2}}},
    {"UniformTexelBufferArrayDynamicIndexing", {{VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME, VK_API_VERSION_1_2}}},
    {"UniformTexelBufferArrayNonUniformIndexing", {{VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME, VK_API_VERSION_1_2}}},
    {"UntypedPointersKHR", {{VK_KHR_SHADER_UNTYPED_POINTERS_EXTENSION_NAME, 0}}},
    {"VariablePointers", {{VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME, 0}}},
    {"VariablePointersStorageBuffer", {{VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME, 0}}},
    {"VulkanMemoryModel", {{VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME, VK_API_VERSION_1_2}}},
    {"VulkanMemoryModelDeviceScope", {{VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME, VK_API_VERSION_1_2}}},
    {"WorkgroupMemoryExplicitLayout16BitAccessKHR", {{VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME, 0}}},
    {"WorkgroupMemoryExplicitLayout8BitAccessKHR", {{VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME, 0}}},
    {"WorkgroupMemoryExplicitLayoutKHR", {{VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME, 0}}},
};
} // namespace

std::vector<const char*> get_spirv_capability_extensions(
    const char* capability,
    uint32_t vk_api_version) {

    const auto it = cap_ext_map.find(capability);
    if (it == cap_ext_map.end()) {
        return {};
    }
    std::vector<const char*> result;
    for (const auto& entry : it->second) {
        if (entry.below_version == 0 || vk_api_version < entry.below_version) {
            result.push_back(entry.ext);
        }
    }
    return result;
}

namespace {
// NOLINTNEXTLINE(cert-err58-cpp)
const std::unordered_map<std::string_view, std::vector<const char*>> cap_feature_map = {
    {"AtomicFloat16AddEXT", {"shaderBufferFloat16AtomicAdd", "shaderSharedFloat16AtomicAdd"}},
    {"AtomicFloat16MinMaxEXT", {"shaderBufferFloat16AtomicMinMax", "shaderSharedFloat16AtomicMinMax"}},
    {"AtomicFloat16VectorNV", {"shaderFloat16VectorAtomics"}},
    {"AtomicFloat32AddEXT", {"shaderBufferFloat32AtomicAdd", "shaderSharedFloat32AtomicAdd", "shaderImageFloat32AtomicAdd"}},
    {"AtomicFloat32MinMaxEXT", {"shaderBufferFloat32AtomicMinMax", "shaderSharedFloat32AtomicMinMax", "shaderImageFloat32AtomicMinMax"}},
    {"AtomicFloat64AddEXT", {"shaderBufferFloat64AtomicAdd", "shaderSharedFloat64AtomicAdd"}},
    {"AtomicFloat64MinMaxEXT", {"shaderBufferFloat64AtomicMinMax", "shaderSharedFloat64AtomicMinMax"}},
    {"BFloat16CooperativeMatrixKHR", {"shaderBFloat16CooperativeMatrix"}},
    {"BFloat16DotProductKHR", {"shaderBFloat16DotProduct"}},
    {"BFloat16TypeKHR", {"shaderBFloat16Type"}},
    {"ClipDistance", {"shaderClipDistance"}},
    {"ClusterCullingShadingHUAWEI", {"clustercullingShader"}},
    {"ComputeDerivativeGroupLinearKHR", {"computeDerivativeGroupLinear"}},
    {"ComputeDerivativeGroupQuadsKHR", {"computeDerivativeGroupQuads"}},
    {"CooperativeMatrixBlockLoadsNV", {"cooperativeMatrixBlockLoads"}},
    {"CooperativeMatrixConversionQCOM", {"cooperativeMatrixConversion"}},
    {"CooperativeMatrixConversionsNV", {"cooperativeMatrixConversions"}},
    {"CooperativeMatrixKHR", {"cooperativeMatrix"}},
    {"CooperativeMatrixNV", {"cooperativeMatrix"}},
    {"CooperativeMatrixPerElementOperationsNV", {"cooperativeMatrixPerElementOperations"}},
    {"CooperativeMatrixReductionsNV", {"cooperativeMatrixReductions"}},
    {"CooperativeMatrixTensorAddressingNV", {"cooperativeMatrixTensorAddressing"}},
    {"CooperativeVectorNV", {"cooperativeVector"}},
    {"CooperativeVectorTrainingNV", {"cooperativeVectorTraining"}},
    {"CoreBuiltinsARM", {"shaderCoreBuiltins"}},
    {"CullDistance", {"shaderCullDistance"}},
    {"DemoteToHelperInvocation", {"shaderDemoteToHelperInvocation"}},
    {"DescriptorHeapEXT", {"descriptorHeap"}},
    {"DotProduct", {"shaderIntegerDotProduct"}},
    {"DotProductInput4x8Bit", {"shaderIntegerDotProduct"}},
    {"DotProductInput4x8BitPacked", {"shaderIntegerDotProduct"}},
    {"DotProductInputAll", {"shaderIntegerDotProduct"}},
    {"DrawParameters", {"shaderDrawParameters"}},
    {"ExpectAssumeKHR", {"shaderExpectAssume"}},
    {"FMAKHR", {"shaderFmaFloat16", "shaderFmaFloat32", "shaderFmaFloat64"}},
    {"Float16", {"shaderFloat16"}},
    {"Float64", {"shaderFloat64"}},
    {"Float8CooperativeMatrixEXT", {"shaderFloat8CooperativeMatrix"}},
    {"Float8EXT", {"shaderFloat8"}},
    {"FloatControls2", {"shaderFloatControls2"}},
    {"FragmentBarycentricKHR", {"fragmentShaderBarycentric"}},
    {"FragmentDensityEXT", {"fragmentDensityMap", "shadingRateImage"}},
    {"FragmentShaderPixelInterlockEXT", {"fragmentShaderPixelInterlock"}},
    {"FragmentShaderSampleInterlockEXT", {"fragmentShaderSampleInterlock"}},
    {"FragmentShaderShadingRateInterlockEXT", {"fragmentShaderShadingRateInterlock", "shadingRateImage"}},
    {"FragmentShadingRateKHR", {"pipelineFragmentShadingRate", "primitiveFragmentShadingRate", "attachmentFragmentShadingRate"}},
    {"Geometry", {"geometryShader"}},
    {"GeometryPointSize", {"shaderTessellationAndGeometryPointSize"}},
    {"GeometryStreams", {"geometryStreams"}},
    {"GraphARM", {"dataGraph"}},
    {"GroupNonUniformPartitionedEXT", {"shaderSubgroupPartitioned"}},
    {"GroupNonUniformRotateKHR", {"shaderSubgroupRotate"}},
    {"ImageCubeArray", {"imageCubeArray"}},
    {"ImageFootprintNV", {"imageFootprint"}},
    {"ImageGatherExtended", {"shaderImageGatherExtended"}},
    {"ImageMSArray", {"shaderStorageImageMultisample"}},
    {"InputAttachmentArrayDynamicIndexing", {"shaderInputAttachmentArrayDynamicIndexing"}},
    {"InputAttachmentArrayNonUniformIndexing", {"shaderInputAttachmentArrayNonUniformIndexing"}},
    {"Int16", {"shaderInt16"}},
    {"Int64", {"shaderInt64"}},
    {"Int64Atomics", {"shaderBufferInt64Atomics", "shaderSharedInt64Atomics", "shaderImageInt64Atomics"}},
    {"Int64ImageEXT", {"shaderImageInt64Atomics"}},
    {"Int8", {"shaderInt8"}},
    {"IntegerFunctions2INTEL", {"shaderIntegerFunctions2"}},
    {"InterpolationFunction", {"sampleRateShading"}},
    {"LongVectorEXT", {"longVector"}},
    {"MinLod", {"shaderResourceMinLod"}},
    {"MultiView", {"multiview"}},
    {"MultiViewport", {"multiViewport"}},
    {"PhysicalStorageBufferAddresses", {"bufferDeviceAddress"}},
    {"PushConstantBanksNV", {"pushConstantBank"}},
    {"QuadControlKHR", {"shaderQuadControl"}},
    {"RawAccessChainsNV", {"shaderRawAccessChains"}},
    {"RayCullMaskKHR", {"rayTracingMaintenance1"}},
    {"RayQueryKHR", {"rayQuery"}},
    {"RayQueryPositionFetchKHR", {"rayTracingPositionFetch"}},
    {"RayTracingClusterAccelerationStructureNV", {"clusterAccelerationStructure"}},
    {"RayTracingKHR", {"rayTracingPipeline"}},
    {"RayTracingLinearSweptSpheresGeometryNV", {"linearSweptSpheres"}},
    {"RayTracingMotionBlurNV", {"rayTracingMotionBlur"}},
    {"RayTracingPositionFetchKHR", {"rayTracingPositionFetch"}},
    {"RayTracingSpheresGeometryNV", {"spheres"}},
    {"RayTraversalPrimitiveCullingKHR", {"rayTraversalPrimitiveCulling", "rayQuery"}},
    {"ReplicatedCompositesEXT", {"shaderReplicatedComposites"}},
    {"RuntimeDescriptorArray", {"runtimeDescriptorArray"}},
    {"SampleRateShading", {"sampleRateShading"}},
    {"SampledCubeArray", {"imageCubeArray"}},
    {"SampledImageArrayDynamicIndexing", {"shaderSampledImageArrayDynamicIndexing"}},
    {"SampledImageArrayNonUniformIndexing", {"shaderSampledImageArrayNonUniformIndexing"}},
    {"Shader64BitIndexingEXT", {"shader64BitIndexing"}},
    {"ShaderEnqueueAMDX", {"shaderEnqueue"}},
    {"ShaderLayer", {"shaderOutputLayer"}},
    {"ShaderSMBuiltinsNV", {"shaderSMBuiltins"}},
    {"ShaderViewportIndex", {"shaderOutputViewportIndex"}},
    {"SparseResidency", {"shaderResourceResidency"}},
    {"StorageBuffer16BitAccess", {"storageBuffer16BitAccess"}},
    {"StorageBuffer8BitAccess", {"storageBuffer8BitAccess"}},
    {"StorageBufferArrayDynamicIndexing", {"shaderStorageBufferArrayDynamicIndexing"}},
    {"StorageBufferArrayNonUniformIndexing", {"shaderStorageBufferArrayNonUniformIndexing"}},
    {"StorageImageArrayDynamicIndexing", {"shaderStorageImageArrayDynamicIndexing"}},
    {"StorageImageArrayNonUniformIndexing", {"shaderStorageImageArrayNonUniformIndexing"}},
    {"StorageImageMultisample", {"shaderStorageImageMultisample"}},
    {"StorageImageReadWithoutFormat", {"shaderStorageImageReadWithoutFormat"}},
    {"StorageImageWriteWithoutFormat", {"shaderStorageImageWriteWithoutFormat"}},
    {"StorageInputOutput16", {"storageInputOutput16"}},
    {"StoragePushConstant16", {"storagePushConstant16"}},
    {"StoragePushConstant8", {"storagePushConstant8"}},
    {"StorageTensorArrayDynamicIndexingARM", {"shaderStorageTensorArrayDynamicIndexing"}},
    {"StorageTensorArrayNonUniformIndexingARM", {"shaderStorageTensorArrayNonUniformIndexing"}},
    {"StorageTexelBufferArrayDynamicIndexing", {"shaderStorageTexelBufferArrayDynamicIndexing"}},
    {"StorageTexelBufferArrayNonUniformIndexing", {"shaderStorageTexelBufferArrayNonUniformIndexing"}},
    {"TensorAddressingNV", {"cooperativeMatrixTensorAddressing"}},
    {"TensorsARM", {"shaderTensorAccess"}},
    {"Tessellation", {"tessellationShader"}},
    {"TessellationPointSize", {"shaderTessellationAndGeometryPointSize"}},
    {"TextureBlockMatch2QCOM", {"textureBlockMatch2"}},
    {"TextureBlockMatchQCOM", {"textureBlockMatch"}},
    {"TextureBoxFilterQCOM", {"textureBoxFilter"}},
    {"TextureSampleWeightedQCOM", {"textureSampleWeighted"}},
    {"TileImageColorReadAccessEXT", {"shaderTileImageColorReadAccess"}},
    {"TileImageDepthReadAccessEXT", {"shaderTileImageDepthReadAccess"}},
    {"TileImageStencilReadAccessEXT", {"shaderTileImageStencilReadAccess"}},
    {"TileShadingQCOM", {"tileShading"}},
    {"TransformFeedback", {"transformFeedback"}},
    {"UniformAndStorageBuffer16BitAccess", {"uniformAndStorageBuffer16BitAccess"}},
    {"UniformAndStorageBuffer8BitAccess", {"uniformAndStorageBuffer8BitAccess"}},
    {"UniformBufferArrayDynamicIndexing", {"shaderUniformBufferArrayDynamicIndexing"}},
    {"UniformBufferArrayNonUniformIndexing", {"shaderUniformBufferArrayNonUniformIndexing"}},
    {"UniformTexelBufferArrayDynamicIndexing", {"shaderUniformTexelBufferArrayDynamicIndexing"}},
    {"UniformTexelBufferArrayNonUniformIndexing", {"shaderUniformTexelBufferArrayNonUniformIndexing"}},
    {"UntypedPointersKHR", {"shaderUntypedPointers"}},
    {"VariablePointers", {"variablePointers"}},
    {"VariablePointersStorageBuffer", {"variablePointersStorageBuffer"}},
    {"VulkanMemoryModel", {"vulkanMemoryModel"}},
    {"VulkanMemoryModelDeviceScope", {"vulkanMemoryModelDeviceScope"}},
    {"WorkgroupMemoryExplicitLayout16BitAccessKHR", {"workgroupMemoryExplicitLayout16BitAccess"}},
    {"WorkgroupMemoryExplicitLayout8BitAccessKHR", {"workgroupMemoryExplicitLayout8BitAccess"}},
    {"WorkgroupMemoryExplicitLayoutKHR", {"workgroupMemoryExplicitLayout"}},
};
} // namespace

std::vector<std::string> get_spirv_capability_features(
    const char* capability,
    [[maybe_unused]] uint32_t vk_api_version) {

    const auto it = cap_feature_map.find(capability);
    if (it == cap_feature_map.end()) {
        return {};
    }
    return {it->second.begin(), it->second.end()};
}

} // namespace merian
