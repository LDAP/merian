// This file was autogenerated for Vulkan v1.4.342.
// Do not edit manually!

#include "merian/vk/utils/vulkan_spirv.hpp"

#include <string_view>

namespace merian {

std::vector<const char*> get_spirv_extensions() {
    return {
        "SPV_AMD_gcn_shader",
        "SPV_AMD_gpu_shader_half_float",
        "SPV_AMD_gpu_shader_int16",
        "SPV_AMD_shader_ballot",
        "SPV_AMD_shader_early_and_late_fragment_tests",
        "SPV_AMD_shader_explicit_vertex_parameter",
        "SPV_AMD_shader_fragment_mask",
        "SPV_AMD_shader_image_load_store_lod",
        "SPV_AMD_shader_trinary_minmax",
        "SPV_AMD_texture_gather_bias_lod",
        "SPV_ARM_core_builtins",
        "SPV_ARM_graph",
        "SPV_ARM_tensors",
        "SPV_EXT_demote_to_helper_invocation",
        "SPV_EXT_descriptor_heap",
        "SPV_EXT_descriptor_indexing",
        "SPV_EXT_float8",
        "SPV_EXT_fragment_fully_covered",
        "SPV_EXT_fragment_invocation_density",
        "SPV_EXT_fragment_shader_interlock",
        "SPV_EXT_long_vector",
        "SPV_EXT_mesh_shader",
        "SPV_EXT_opacity_micromap",
        "SPV_EXT_physical_storage_buffer",
        "SPV_EXT_replicated_composites",
        "SPV_EXT_shader_64bit_indexing",
        "SPV_EXT_shader_atomic_float16_add",
        "SPV_EXT_shader_atomic_float_add",
        "SPV_EXT_shader_atomic_float_min_max",
        "SPV_EXT_shader_image_int64",
        "SPV_EXT_shader_invocation_reorder",
        "SPV_EXT_shader_stencil_export",
        "SPV_EXT_shader_subgroup_partitioned",
        "SPV_EXT_shader_tile_image",
        "SPV_EXT_shader_viewport_index_layer",
        "SPV_GOOGLE_decorate_string",
        "SPV_GOOGLE_hlsl_functionality1",
        "SPV_GOOGLE_user_type",
        "SPV_HUAWEI_cluster_culling_shader",
        "SPV_HUAWEI_subpass_shading",
        "SPV_INTEL_shader_integer_functions2",
        "SPV_KHR_16bit_storage",
        "SPV_KHR_8bit_storage",
        "SPV_KHR_bfloat16",
        "SPV_KHR_compute_shader_derivatives",
        "SPV_KHR_cooperative_matrix",
        "SPV_KHR_device_group",
        "SPV_KHR_expect_assume",
        "SPV_KHR_float_controls",
        "SPV_KHR_float_controls2",
        "SPV_KHR_fma",
        "SPV_KHR_fragment_shader_barycentric",
        "SPV_KHR_fragment_shading_rate",
        "SPV_KHR_integer_dot_product",
        "SPV_KHR_maximal_reconvergence",
        "SPV_KHR_multiview",
        "SPV_KHR_non_semantic_info",
        "SPV_KHR_physical_storage_buffer",
        "SPV_KHR_post_depth_coverage",
        "SPV_KHR_quad_control",
        "SPV_KHR_ray_cull_mask",
        "SPV_KHR_ray_query",
        "SPV_KHR_ray_tracing",
        "SPV_KHR_ray_tracing_position_fetch",
        "SPV_KHR_relaxed_extended_instruction",
        "SPV_KHR_shader_ballot",
        "SPV_KHR_shader_clock",
        "SPV_KHR_shader_draw_parameters",
        "SPV_KHR_storage_buffer_storage_class",
        "SPV_KHR_subgroup_rotate",
        "SPV_KHR_subgroup_uniform_control_flow",
        "SPV_KHR_subgroup_vote",
        "SPV_KHR_terminate_invocation",
        "SPV_KHR_untyped_pointers",
        "SPV_KHR_variable_pointers",
        "SPV_KHR_vulkan_memory_model",
        "SPV_KHR_workgroup_memory_explicit_layout",
        "SPV_NVX_multiview_per_view_attributes",
        "SPV_NV_cluster_acceleration_structure",
        "SPV_NV_compute_shader_derivatives",
        "SPV_NV_cooperative_matrix",
        "SPV_NV_cooperative_matrix2",
        "SPV_NV_cooperative_vector",
        "SPV_NV_fragment_shader_barycentric",
        "SPV_NV_geometry_shader_passthrough",
        "SPV_NV_linear_swept_spheres",
        "SPV_NV_mesh_shader",
        "SPV_NV_push_constant_bank",
        "SPV_NV_raw_access_chains",
        "SPV_NV_ray_tracing",
        "SPV_NV_ray_tracing_motion_blur",
        "SPV_NV_sample_mask_override_coverage",
        "SPV_NV_shader_atomic_fp16_vector",
        "SPV_NV_shader_image_footprint",
        "SPV_NV_shader_invocation_reorder",
        "SPV_NV_shader_sm_builtins",
        "SPV_NV_shader_subgroup_partitioned",
        "SPV_NV_shading_rate",
        "SPV_NV_tensor_addressing",
        "SPV_NV_viewport_array2",
        "SPV_QCOM_image_processing",
        "SPV_QCOM_image_processing2",
        "SPV_QCOM_tile_shading",
    };
}

std::vector<const char*> get_spirv_extension_requirements(
    const char* spirv_extension,
    uint32_t vk_api_version) {
    
    const std::string_view ext_name{spirv_extension};
    
    if (ext_name == "SPV_AMD_gcn_shader") {
        return {VK_AMD_GCN_SHADER_EXTENSION_NAME};
    } else if (ext_name == "SPV_AMD_gpu_shader_half_float") {
        return {VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME};
    } else if (ext_name == "SPV_AMD_gpu_shader_int16") {
        return {VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME};
    } else if (ext_name == "SPV_AMD_shader_ballot") {
        return {VK_AMD_SHADER_BALLOT_EXTENSION_NAME};
    } else if (ext_name == "SPV_AMD_shader_early_and_late_fragment_tests") {
        return {VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION_NAME};
    } else if (ext_name == "SPV_AMD_shader_explicit_vertex_parameter") {
        return {VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME};
    } else if (ext_name == "SPV_AMD_shader_fragment_mask") {
        return {VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME};
    } else if (ext_name == "SPV_AMD_shader_image_load_store_lod") {
        return {VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME};
    } else if (ext_name == "SPV_AMD_shader_trinary_minmax") {
        return {VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME};
    } else if (ext_name == "SPV_AMD_texture_gather_bias_lod") {
        return {VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME};
    } else if (ext_name == "SPV_ARM_core_builtins") {
        return {VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME};
    } else if (ext_name == "SPV_ARM_graph") {
        return {VK_ARM_DATA_GRAPH_EXTENSION_NAME};
    } else if (ext_name == "SPV_ARM_tensors") {
        return {VK_ARM_TENSORS_EXTENSION_NAME};
    } else if (ext_name == "SPV_EXT_demote_to_helper_invocation") {
        if (vk_api_version >= VK_API_VERSION_1_3) {
            return {};
        }
        return {VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME};
    } else if (ext_name == "SPV_EXT_descriptor_heap") {
        return {VK_EXT_DESCRIPTOR_HEAP_EXTENSION_NAME};
    } else if (ext_name == "SPV_EXT_descriptor_indexing") {
        if (vk_api_version >= VK_API_VERSION_1_2) {
            return {};
        }
        return {VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME};
    } else if (ext_name == "SPV_EXT_float8") {
        return {VK_EXT_SHADER_FLOAT8_EXTENSION_NAME};
    } else if (ext_name == "SPV_EXT_fragment_fully_covered") {
        return {VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME};
    } else if (ext_name == "SPV_EXT_fragment_invocation_density") {
        return {VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME};
    } else if (ext_name == "SPV_EXT_fragment_shader_interlock") {
        return {VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME};
    } else if (ext_name == "SPV_EXT_long_vector") {
        return {VK_EXT_SHADER_LONG_VECTOR_EXTENSION_NAME};
    } else if (ext_name == "SPV_EXT_mesh_shader") {
        return {VK_EXT_MESH_SHADER_EXTENSION_NAME};
    } else if (ext_name == "SPV_EXT_opacity_micromap") {
        return {VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME};
    } else if (ext_name == "SPV_EXT_physical_storage_buffer") {
        return {VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME};
    } else if (ext_name == "SPV_EXT_replicated_composites") {
        return {VK_EXT_SHADER_REPLICATED_COMPOSITES_EXTENSION_NAME};
    } else if (ext_name == "SPV_EXT_shader_64bit_indexing") {
        return {VK_EXT_SHADER_64BIT_INDEXING_EXTENSION_NAME};
    } else if (ext_name == "SPV_EXT_shader_atomic_float16_add") {
        return {VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME};
    } else if (ext_name == "SPV_EXT_shader_atomic_float_add") {
        return {VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME};
    } else if (ext_name == "SPV_EXT_shader_atomic_float_min_max") {
        return {VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME};
    } else if (ext_name == "SPV_EXT_shader_image_int64") {
        return {VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME};
    } else if (ext_name == "SPV_EXT_shader_invocation_reorder") {
        return {VK_EXT_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME};
    } else if (ext_name == "SPV_EXT_shader_stencil_export") {
        return {VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME};
    } else if (ext_name == "SPV_EXT_shader_subgroup_partitioned") {
        return {VK_EXT_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME};
    } else if (ext_name == "SPV_EXT_shader_tile_image") {
        return {VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME};
    } else if (ext_name == "SPV_EXT_shader_viewport_index_layer") {
        if (vk_api_version >= VK_API_VERSION_1_2) {
            return {};
        }
        return {VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME};
    } else if (ext_name == "SPV_GOOGLE_decorate_string") {
        return {VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME};
    } else if (ext_name == "SPV_GOOGLE_hlsl_functionality1") {
        return {VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME};
    } else if (ext_name == "SPV_GOOGLE_user_type") {
        return {VK_GOOGLE_USER_TYPE_EXTENSION_NAME};
    } else if (ext_name == "SPV_HUAWEI_cluster_culling_shader") {
        return {VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME};
    } else if (ext_name == "SPV_HUAWEI_subpass_shading") {
        return {VK_HUAWEI_SUBPASS_SHADING_EXTENSION_NAME};
    } else if (ext_name == "SPV_INTEL_shader_integer_functions2") {
        return {VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_16bit_storage") {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_16BIT_STORAGE_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_8bit_storage") {
        if (vk_api_version >= VK_API_VERSION_1_2) {
            return {};
        }
        return {VK_KHR_8BIT_STORAGE_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_bfloat16") {
        return {VK_KHR_SHADER_BFLOAT16_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_compute_shader_derivatives") {
        return {VK_KHR_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_cooperative_matrix") {
        return {VK_KHR_COOPERATIVE_MATRIX_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_device_group") {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_DEVICE_GROUP_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_expect_assume") {
        if (vk_api_version >= VK_API_VERSION_1_4) {
            return {};
        }
        return {VK_KHR_SHADER_EXPECT_ASSUME_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_float_controls") {
        if (vk_api_version >= VK_API_VERSION_1_2) {
            return {};
        }
        return {VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_float_controls2") {
        if (vk_api_version >= VK_API_VERSION_1_4) {
            return {};
        }
        return {VK_KHR_SHADER_FLOAT_CONTROLS_2_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_fma") {
        return {VK_KHR_SHADER_FMA_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_fragment_shader_barycentric") {
        return {VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_fragment_shading_rate") {
        return {VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_integer_dot_product") {
        if (vk_api_version >= VK_API_VERSION_1_3) {
            return {};
        }
        return {VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_maximal_reconvergence") {
        return {VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_multiview") {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_MULTIVIEW_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_non_semantic_info") {
        if (vk_api_version >= VK_API_VERSION_1_3) {
            return {};
        }
        return {VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_physical_storage_buffer") {
        if (vk_api_version >= VK_API_VERSION_1_2) {
            return {};
        }
        return {VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_post_depth_coverage") {
        return {VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_quad_control") {
        return {VK_KHR_SHADER_QUAD_CONTROL_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_ray_cull_mask") {
        return {VK_KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_ray_query") {
        return {VK_KHR_RAY_QUERY_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_ray_tracing") {
        return {VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_ray_tracing_position_fetch") {
        return {VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_relaxed_extended_instruction") {
        return {VK_KHR_SHADER_RELAXED_EXTENDED_INSTRUCTION_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_shader_ballot") {
        return {VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_shader_clock") {
        return {VK_KHR_SHADER_CLOCK_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_shader_draw_parameters") {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_storage_buffer_storage_class") {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_subgroup_rotate") {
        if (vk_api_version >= VK_API_VERSION_1_4) {
            return {};
        }
        return {VK_KHR_SHADER_SUBGROUP_ROTATE_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_subgroup_uniform_control_flow") {
        return {VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_subgroup_vote") {
        return {VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_terminate_invocation") {
        if (vk_api_version >= VK_API_VERSION_1_3) {
            return {};
        }
        return {VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_untyped_pointers") {
        return {VK_KHR_SHADER_UNTYPED_POINTERS_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_variable_pointers") {
        if (vk_api_version >= VK_API_VERSION_1_1) {
            return {};
        }
        return {VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_vulkan_memory_model") {
        if (vk_api_version >= VK_API_VERSION_1_2) {
            return {};
        }
        return {VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME};
    } else if (ext_name == "SPV_KHR_workgroup_memory_explicit_layout") {
        return {VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME};
    } else if (ext_name == "SPV_NVX_multiview_per_view_attributes") {
        return {VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME};
    } else if (ext_name == "SPV_NV_cluster_acceleration_structure") {
        return {VK_NV_CLUSTER_ACCELERATION_STRUCTURE_EXTENSION_NAME};
    } else if (ext_name == "SPV_NV_compute_shader_derivatives") {
        return {VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME};
    } else if (ext_name == "SPV_NV_cooperative_matrix") {
        return {VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME};
    } else if (ext_name == "SPV_NV_cooperative_matrix2") {
        return {VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME};
    } else if (ext_name == "SPV_NV_cooperative_vector") {
        return {VK_NV_COOPERATIVE_VECTOR_EXTENSION_NAME};
    } else if (ext_name == "SPV_NV_fragment_shader_barycentric") {
        return {VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME};
    } else if (ext_name == "SPV_NV_geometry_shader_passthrough") {
        return {VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME};
    } else if (ext_name == "SPV_NV_linear_swept_spheres") {
        return {VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_EXTENSION_NAME};
    } else if (ext_name == "SPV_NV_mesh_shader") {
        return {VK_NV_MESH_SHADER_EXTENSION_NAME};
    } else if (ext_name == "SPV_NV_push_constant_bank") {
        return {VK_NV_PUSH_CONSTANT_BANK_EXTENSION_NAME};
    } else if (ext_name == "SPV_NV_raw_access_chains") {
        return {VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME};
    } else if (ext_name == "SPV_NV_ray_tracing") {
        return {VK_NV_RAY_TRACING_EXTENSION_NAME};
    } else if (ext_name == "SPV_NV_ray_tracing_motion_blur") {
        return {VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME};
    } else if (ext_name == "SPV_NV_sample_mask_override_coverage") {
        return {VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME};
    } else if (ext_name == "SPV_NV_shader_atomic_fp16_vector") {
        return {VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_EXTENSION_NAME};
    } else if (ext_name == "SPV_NV_shader_image_footprint") {
        return {VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME};
    } else if (ext_name == "SPV_NV_shader_invocation_reorder") {
        return {VK_NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME};
    } else if (ext_name == "SPV_NV_shader_sm_builtins") {
        return {VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME};
    } else if (ext_name == "SPV_NV_shader_subgroup_partitioned") {
        return {VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME, VK_EXT_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME};
    } else if (ext_name == "SPV_NV_shading_rate") {
        return {VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME};
    } else if (ext_name == "SPV_NV_tensor_addressing") {
        return {VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME};
    } else if (ext_name == "SPV_NV_viewport_array2") {
        return {VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME};
    } else if (ext_name == "SPV_QCOM_image_processing") {
        return {VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME};
    } else if (ext_name == "SPV_QCOM_image_processing2") {
        return {VK_QCOM_IMAGE_PROCESSING_2_EXTENSION_NAME};
    } else if (ext_name == "SPV_QCOM_tile_shading") {
        return {VK_QCOM_TILE_SHADING_EXTENSION_NAME};
    }
    
    return {};
}

std::vector<const char*> get_spirv_capabilities() {
    return {
        "AtomicFloat16AddEXT",
        "AtomicFloat16MinMaxEXT",
        "AtomicFloat16VectorNV",
        "AtomicFloat32AddEXT",
        "AtomicFloat32MinMaxEXT",
        "AtomicFloat64AddEXT",
        "AtomicFloat64MinMaxEXT",
        "BFloat16CooperativeMatrixKHR",
        "BFloat16DotProductKHR",
        "BFloat16TypeKHR",
        "ClipDistance",
        "ClusterCullingShadingHUAWEI",
        "ComputeDerivativeGroupLinearKHR",
        "ComputeDerivativeGroupQuadsKHR",
        "CooperativeMatrixBlockLoadsNV",
        "CooperativeMatrixConversionQCOM",
        "CooperativeMatrixConversionsNV",
        "CooperativeMatrixKHR",
        "CooperativeMatrixNV",
        "CooperativeMatrixPerElementOperationsNV",
        "CooperativeMatrixReductionsNV",
        "CooperativeMatrixTensorAddressingNV",
        "CooperativeVectorNV",
        "CooperativeVectorTrainingNV",
        "CoreBuiltinsARM",
        "CullDistance",
        "DemoteToHelperInvocation",
        "DenormFlushToZero",
        "DenormPreserve",
        "DerivativeControl",
        "DescriptorHeapEXT",
        "DeviceGroup",
        "DotProduct",
        "DotProductInput4x8Bit",
        "DotProductInput4x8BitPacked",
        "DotProductInputAll",
        "DrawParameters",
        "ExpectAssumeKHR",
        "FMAKHR",
        "Float16",
        "Float64",
        "Float8CooperativeMatrixEXT",
        "Float8EXT",
        "FloatControls2",
        "FragmentBarycentricKHR",
        "FragmentDensityEXT",
        "FragmentFullyCoveredEXT",
        "FragmentMaskAMD",
        "FragmentShaderPixelInterlockEXT",
        "FragmentShaderSampleInterlockEXT",
        "FragmentShaderShadingRateInterlockEXT",
        "FragmentShadingRateKHR",
        "Geometry",
        "GeometryPointSize",
        "GeometryShaderPassthroughNV",
        "GeometryStreams",
        "GraphARM",
        "GroupNonUniform",
        "GroupNonUniformArithmetic",
        "GroupNonUniformBallot",
        "GroupNonUniformClustered",
        "GroupNonUniformPartitionedEXT",
        "GroupNonUniformQuad",
        "GroupNonUniformRotateKHR",
        "GroupNonUniformShuffle",
        "GroupNonUniformShuffleRelative",
        "GroupNonUniformVote",
        "Image1D",
        "ImageBuffer",
        "ImageCubeArray",
        "ImageFootprintNV",
        "ImageGatherBiasLodAMD",
        "ImageGatherExtended",
        "ImageMSArray",
        "ImageQuery",
        "ImageReadWriteLodAMD",
        "InputAttachment",
        "InputAttachmentArrayDynamicIndexing",
        "InputAttachmentArrayNonUniformIndexing",
        "Int16",
        "Int64",
        "Int64Atomics",
        "Int64ImageEXT",
        "Int8",
        "IntegerFunctions2INTEL",
        "InterpolationFunction",
        "LongVectorEXT",
        "Matrix",
        "MeshShadingEXT",
        "MeshShadingNV",
        "MinLod",
        "MultiView",
        "MultiViewport",
        "PerViewAttributesNV",
        "PhysicalStorageBufferAddresses",
        "PushConstantBanksNV",
        "QuadControlKHR",
        "RawAccessChainsNV",
        "RayCullMaskKHR",
        "RayQueryKHR",
        "RayQueryPositionFetchKHR",
        "RayTracingClusterAccelerationStructureNV",
        "RayTracingKHR",
        "RayTracingLinearSweptSpheresGeometryNV",
        "RayTracingMotionBlurNV",
        "RayTracingNV",
        "RayTracingOpacityMicromapEXT",
        "RayTracingPositionFetchKHR",
        "RayTracingSpheresGeometryNV",
        "RayTraversalPrimitiveCullingKHR",
        "ReplicatedCompositesEXT",
        "RoundingModeRTE",
        "RoundingModeRTZ",
        "RuntimeDescriptorArray",
        "SampleMaskOverrideCoverageNV",
        "SampleMaskPostDepthCoverage",
        "SampleRateShading",
        "Sampled1D",
        "SampledBuffer",
        "SampledCubeArray",
        "SampledImageArrayDynamicIndexing",
        "SampledImageArrayNonUniformIndexing",
        "Shader",
        "Shader64BitIndexingEXT",
        "ShaderClockKHR",
        "ShaderEnqueueAMDX",
        "ShaderInvocationReorderEXT",
        "ShaderInvocationReorderNV",
        "ShaderLayer",
        "ShaderNonUniform",
        "ShaderSMBuiltinsNV",
        "ShaderViewportIndex",
        "ShaderViewportIndexLayerEXT",
        "ShaderViewportMaskNV",
        "SignedZeroInfNanPreserve",
        "SparseResidency",
        "StencilExportEXT",
        "StorageBuffer16BitAccess",
        "StorageBuffer8BitAccess",
        "StorageBufferArrayDynamicIndexing",
        "StorageBufferArrayNonUniformIndexing",
        "StorageImageArrayDynamicIndexing",
        "StorageImageArrayNonUniformIndexing",
        "StorageImageExtendedFormats",
        "StorageImageMultisample",
        "StorageImageReadWithoutFormat",
        "StorageImageWriteWithoutFormat",
        "StorageInputOutput16",
        "StoragePushConstant16",
        "StoragePushConstant8",
        "StorageTensorArrayDynamicIndexingARM",
        "StorageTensorArrayNonUniformIndexingARM",
        "StorageTexelBufferArrayDynamicIndexing",
        "StorageTexelBufferArrayNonUniformIndexing",
        "SubgroupBallotKHR",
        "SubgroupVoteKHR",
        "TensorAddressingNV",
        "TensorsARM",
        "Tessellation",
        "TessellationPointSize",
        "TextureBlockMatch2QCOM",
        "TextureBlockMatchQCOM",
        "TextureBoxFilterQCOM",
        "TextureSampleWeightedQCOM",
        "TileImageColorReadAccessEXT",
        "TileImageDepthReadAccessEXT",
        "TileImageStencilReadAccessEXT",
        "TileShadingQCOM",
        "TransformFeedback",
        "UniformAndStorageBuffer16BitAccess",
        "UniformAndStorageBuffer8BitAccess",
        "UniformBufferArrayDynamicIndexing",
        "UniformBufferArrayNonUniformIndexing",
        "UniformTexelBufferArrayDynamicIndexing",
        "UniformTexelBufferArrayNonUniformIndexing",
        "UntypedPointersKHR",
        "VariablePointers",
        "VariablePointersStorageBuffer",
        "VulkanMemoryModel",
        "VulkanMemoryModelDeviceScope",
        "WorkgroupMemoryExplicitLayout16BitAccessKHR",
        "WorkgroupMemoryExplicitLayout8BitAccessKHR",
        "WorkgroupMemoryExplicitLayoutKHR",
    };
}

bool is_spirv_capability_supported(
    const char* capability,
    uint32_t vk_api_version,
    const VulkanFeatures& features,
    const VulkanProperties& properties) {
    
    const std::string_view cap_name{capability};
    
    if (cap_name == "AtomicFloat16AddEXT") {
        return features.get_feature("shaderBufferFloat16AtomicAdd") ||
            features.get_feature("shaderSharedFloat16AtomicAdd");
    } else if (cap_name == "AtomicFloat16MinMaxEXT") {
        return features.get_feature("shaderBufferFloat16AtomicMinMax") ||
            features.get_feature("shaderSharedFloat16AtomicMinMax");
    } else if (cap_name == "AtomicFloat16VectorNV") {
        return features.get_feature("shaderFloat16VectorAtomics");
    } else if (cap_name == "AtomicFloat32AddEXT") {
        return features.get_feature("shaderBufferFloat32AtomicAdd") ||
            features.get_feature("shaderSharedFloat32AtomicAdd") ||
            features.get_feature("shaderImageFloat32AtomicAdd");
    } else if (cap_name == "AtomicFloat32MinMaxEXT") {
        return features.get_feature("shaderBufferFloat32AtomicMinMax") ||
            features.get_feature("shaderSharedFloat32AtomicMinMax") ||
            features.get_feature("shaderImageFloat32AtomicMinMax");
    } else if (cap_name == "AtomicFloat64AddEXT") {
        return features.get_feature("shaderBufferFloat64AtomicAdd") ||
            features.get_feature("shaderSharedFloat64AtomicAdd");
    } else if (cap_name == "AtomicFloat64MinMaxEXT") {
        return features.get_feature("shaderBufferFloat64AtomicMinMax") ||
            features.get_feature("shaderSharedFloat64AtomicMinMax");
    } else if (cap_name == "BFloat16CooperativeMatrixKHR") {
        return features.get_feature("shaderBFloat16CooperativeMatrix");
    } else if (cap_name == "BFloat16DotProductKHR") {
        return features.get_feature("shaderBFloat16DotProduct");
    } else if (cap_name == "BFloat16TypeKHR") {
        return features.get_feature("shaderBFloat16Type");
    } else if (cap_name == "ClipDistance") {
        return features.get_feature("shaderClipDistance");
    } else if (cap_name == "ClusterCullingShadingHUAWEI") {
        return features.get_feature("clustercullingShader");
    } else if (cap_name == "ComputeDerivativeGroupLinearKHR") {
        return features.get_feature("computeDerivativeGroupLinear") ||
            features.get_feature("computeDerivativeGroupLinear");
    } else if (cap_name == "ComputeDerivativeGroupQuadsKHR") {
        return features.get_feature("computeDerivativeGroupQuads") ||
            features.get_feature("computeDerivativeGroupQuads");
    } else if (cap_name == "CooperativeMatrixBlockLoadsNV") {
        return features.get_feature("cooperativeMatrixBlockLoads");
    } else if (cap_name == "CooperativeMatrixConversionQCOM") {
        return features.get_feature("cooperativeMatrixConversion");
    } else if (cap_name == "CooperativeMatrixConversionsNV") {
        return features.get_feature("cooperativeMatrixConversions");
    } else if (cap_name == "CooperativeMatrixKHR") {
        return features.get_feature("cooperativeMatrix");
    } else if (cap_name == "CooperativeMatrixNV") {
        return features.get_feature("cooperativeMatrix");
    } else if (cap_name == "CooperativeMatrixPerElementOperationsNV") {
        return features.get_feature("cooperativeMatrixPerElementOperations");
    } else if (cap_name == "CooperativeMatrixReductionsNV") {
        return features.get_feature("cooperativeMatrixReductions");
    } else if (cap_name == "CooperativeMatrixTensorAddressingNV") {
        return features.get_feature("cooperativeMatrixTensorAddressing");
    } else if (cap_name == "CooperativeVectorNV") {
        return features.get_feature("cooperativeVector");
    } else if (cap_name == "CooperativeVectorTrainingNV") {
        return features.get_feature("cooperativeVectorTraining");
    } else if (cap_name == "CoreBuiltinsARM") {
        return features.get_feature("shaderCoreBuiltins");
    } else if (cap_name == "CullDistance") {
        return features.get_feature("shaderCullDistance");
    } else if (cap_name == "DemoteToHelperInvocation") {
        return features.get_feature("shaderDemoteToHelperInvocation") ||
            features.get_feature("shaderDemoteToHelperInvocation");
    } else if (cap_name == "DenormFlushToZero") {
        return (properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderDenormFlushToZeroFloat16 == VK_TRUE) ||
            (properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderDenormFlushToZeroFloat32 == VK_TRUE) ||
            (properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderDenormFlushToZeroFloat64 == VK_TRUE);
    } else if (cap_name == "DenormPreserve") {
        return (properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderDenormPreserveFloat16 == VK_TRUE) ||
            (properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderDenormPreserveFloat32 == VK_TRUE) ||
            (properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderDenormPreserveFloat64 == VK_TRUE);
    } else if (cap_name == "DerivativeControl") {
        return (vk_api_version >= VK_API_VERSION_1_0);
    } else if (cap_name == "DescriptorHeapEXT") {
        return features.get_feature("descriptorHeap");
    } else if (cap_name == "DeviceGroup") {
        return (vk_api_version >= VK_API_VERSION_1_1);
    } else if (cap_name == "DotProduct") {
        return features.get_feature("shaderIntegerDotProduct") ||
            features.get_feature("shaderIntegerDotProduct");
    } else if (cap_name == "DotProductInput4x8Bit") {
        return features.get_feature("shaderIntegerDotProduct") ||
            features.get_feature("shaderIntegerDotProduct");
    } else if (cap_name == "DotProductInput4x8BitPacked") {
        return features.get_feature("shaderIntegerDotProduct") ||
            features.get_feature("shaderIntegerDotProduct");
    } else if (cap_name == "DotProductInputAll") {
        return features.get_feature("shaderIntegerDotProduct") ||
            features.get_feature("shaderIntegerDotProduct");
    } else if (cap_name == "DrawParameters") {
        return features.get_feature("shaderDrawParameters") ||
            features.get_feature("shaderDrawParameters");
    } else if (cap_name == "ExpectAssumeKHR") {
        return features.get_feature("shaderExpectAssume") ||
            features.get_feature("shaderExpectAssume");
    } else if (cap_name == "FMAKHR") {
        return features.get_feature("shaderFmaFloat16") ||
            features.get_feature("shaderFmaFloat32") ||
            features.get_feature("shaderFmaFloat64");
    } else if (cap_name == "Float16") {
        return features.get_feature("shaderFloat16");
    } else if (cap_name == "Float64") {
        return features.get_feature("shaderFloat64");
    } else if (cap_name == "Float8CooperativeMatrixEXT") {
        return features.get_feature("shaderFloat8CooperativeMatrix");
    } else if (cap_name == "Float8EXT") {
        return features.get_feature("shaderFloat8");
    } else if (cap_name == "FloatControls2") {
        return features.get_feature("shaderFloatControls2") ||
            features.get_feature("shaderFloatControls2");
    } else if (cap_name == "FragmentBarycentricKHR") {
        return features.get_feature("fragmentShaderBarycentric") ||
            features.get_feature("fragmentShaderBarycentric");
    } else if (cap_name == "FragmentDensityEXT") {
        return features.get_feature("fragmentDensityMap") ||
            features.get_feature("shadingRateImage");
    } else if (cap_name == "FragmentFullyCoveredEXT") {
        return false;
    } else if (cap_name == "FragmentMaskAMD") {
        return false;
    } else if (cap_name == "FragmentShaderPixelInterlockEXT") {
        return features.get_feature("fragmentShaderPixelInterlock");
    } else if (cap_name == "FragmentShaderSampleInterlockEXT") {
        return features.get_feature("fragmentShaderSampleInterlock");
    } else if (cap_name == "FragmentShaderShadingRateInterlockEXT") {
        return features.get_feature("fragmentShaderShadingRateInterlock") ||
            features.get_feature("shadingRateImage");
    } else if (cap_name == "FragmentShadingRateKHR") {
        return features.get_feature("pipelineFragmentShadingRate") ||
            features.get_feature("primitiveFragmentShadingRate") ||
            features.get_feature("attachmentFragmentShadingRate");
    } else if (cap_name == "Geometry") {
        return features.get_feature("geometryShader");
    } else if (cap_name == "GeometryPointSize") {
        return features.get_feature("shaderTessellationAndGeometryPointSize");
    } else if (cap_name == "GeometryShaderPassthroughNV") {
        return false;
    } else if (cap_name == "GeometryStreams") {
        return features.get_feature("geometryStreams");
    } else if (cap_name == "GraphARM") {
        return features.get_feature("dataGraph");
    } else if (cap_name == "GroupNonUniform") {
        return (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceVulkan11Properties>().subgroupSupportedOperations) & VK_SUBGROUP_FEATURE_BASIC_BIT);
    } else if (cap_name == "GroupNonUniformArithmetic") {
        return (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceVulkan11Properties>().subgroupSupportedOperations) & VK_SUBGROUP_FEATURE_ARITHMETIC_BIT);
    } else if (cap_name == "GroupNonUniformBallot") {
        return (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceVulkan11Properties>().subgroupSupportedOperations) & VK_SUBGROUP_FEATURE_BALLOT_BIT);
    } else if (cap_name == "GroupNonUniformClustered") {
        return (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceVulkan11Properties>().subgroupSupportedOperations) & VK_SUBGROUP_FEATURE_CLUSTERED_BIT);
    } else if (cap_name == "GroupNonUniformPartitionedEXT") {
        return features.get_feature("shaderSubgroupPartitioned") ||
            (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceVulkan11Properties>().subgroupSupportedOperations) & VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV);
    } else if (cap_name == "GroupNonUniformQuad") {
        return (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceVulkan11Properties>().subgroupSupportedOperations) & VK_SUBGROUP_FEATURE_QUAD_BIT);
    } else if (cap_name == "GroupNonUniformRotateKHR") {
        return features.get_feature("shaderSubgroupRotate") ||
            features.get_feature("shaderSubgroupRotate");
    } else if (cap_name == "GroupNonUniformShuffle") {
        return (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceVulkan11Properties>().subgroupSupportedOperations) & VK_SUBGROUP_FEATURE_SHUFFLE_BIT);
    } else if (cap_name == "GroupNonUniformShuffleRelative") {
        return (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceVulkan11Properties>().subgroupSupportedOperations) & VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT);
    } else if (cap_name == "GroupNonUniformVote") {
        return (static_cast<uint32_t>(properties.get<vk::PhysicalDeviceVulkan11Properties>().subgroupSupportedOperations) & VK_SUBGROUP_FEATURE_VOTE_BIT);
    } else if (cap_name == "Image1D") {
        return (vk_api_version >= VK_API_VERSION_1_0);
    } else if (cap_name == "ImageBuffer") {
        return (vk_api_version >= VK_API_VERSION_1_0);
    } else if (cap_name == "ImageCubeArray") {
        return features.get_feature("imageCubeArray");
    } else if (cap_name == "ImageFootprintNV") {
        return features.get_feature("imageFootprint");
    } else if (cap_name == "ImageGatherBiasLodAMD") {
        return false;
    } else if (cap_name == "ImageGatherExtended") {
        return features.get_feature("shaderImageGatherExtended");
    } else if (cap_name == "ImageMSArray") {
        return features.get_feature("shaderStorageImageMultisample");
    } else if (cap_name == "ImageQuery") {
        return (vk_api_version >= VK_API_VERSION_1_0);
    } else if (cap_name == "ImageReadWriteLodAMD") {
        return false;
    } else if (cap_name == "InputAttachment") {
        return (vk_api_version >= VK_API_VERSION_1_0);
    } else if (cap_name == "InputAttachmentArrayDynamicIndexing") {
        return features.get_feature("shaderInputAttachmentArrayDynamicIndexing");
    } else if (cap_name == "InputAttachmentArrayNonUniformIndexing") {
        return features.get_feature("shaderInputAttachmentArrayNonUniformIndexing");
    } else if (cap_name == "Int16") {
        return features.get_feature("shaderInt16");
    } else if (cap_name == "Int64") {
        return features.get_feature("shaderInt64");
    } else if (cap_name == "Int64Atomics") {
        return features.get_feature("shaderBufferInt64Atomics") ||
            features.get_feature("shaderSharedInt64Atomics") ||
            features.get_feature("shaderImageInt64Atomics");
    } else if (cap_name == "Int64ImageEXT") {
        return features.get_feature("shaderImageInt64Atomics");
    } else if (cap_name == "Int8") {
        return features.get_feature("shaderInt8");
    } else if (cap_name == "IntegerFunctions2INTEL") {
        return features.get_feature("shaderIntegerFunctions2");
    } else if (cap_name == "InterpolationFunction") {
        return features.get_feature("sampleRateShading");
    } else if (cap_name == "LongVectorEXT") {
        return features.get_feature("longVector");
    } else if (cap_name == "Matrix") {
        return (vk_api_version >= VK_API_VERSION_1_0);
    } else if (cap_name == "MeshShadingEXT") {
        return false;
    } else if (cap_name == "MeshShadingNV") {
        return false;
    } else if (cap_name == "MinLod") {
        return features.get_feature("shaderResourceMinLod");
    } else if (cap_name == "MultiView") {
        return features.get_feature("multiview") ||
            features.get_feature("multiview");
    } else if (cap_name == "MultiViewport") {
        return features.get_feature("multiViewport");
    } else if (cap_name == "PerViewAttributesNV") {
        return false;
    } else if (cap_name == "PhysicalStorageBufferAddresses") {
        return features.get_feature("bufferDeviceAddress") ||
            features.get_feature("bufferDeviceAddress");
    } else if (cap_name == "PushConstantBanksNV") {
        return features.get_feature("pushConstantBank");
    } else if (cap_name == "QuadControlKHR") {
        return features.get_feature("shaderQuadControl");
    } else if (cap_name == "RawAccessChainsNV") {
        return features.get_feature("shaderRawAccessChains");
    } else if (cap_name == "RayCullMaskKHR") {
        return features.get_feature("rayTracingMaintenance1");
    } else if (cap_name == "RayQueryKHR") {
        return features.get_feature("rayQuery");
    } else if (cap_name == "RayQueryPositionFetchKHR") {
        return features.get_feature("rayTracingPositionFetch");
    } else if (cap_name == "RayTracingClusterAccelerationStructureNV") {
        return features.get_feature("clusterAccelerationStructure");
    } else if (cap_name == "RayTracingKHR") {
        return features.get_feature("rayTracingPipeline");
    } else if (cap_name == "RayTracingLinearSweptSpheresGeometryNV") {
        return features.get_feature("linearSweptSpheres");
    } else if (cap_name == "RayTracingMotionBlurNV") {
        return features.get_feature("rayTracingMotionBlur");
    } else if (cap_name == "RayTracingNV") {
        return false;
    } else if (cap_name == "RayTracingOpacityMicromapEXT") {
        return false;
    } else if (cap_name == "RayTracingPositionFetchKHR") {
        return features.get_feature("rayTracingPositionFetch");
    } else if (cap_name == "RayTracingSpheresGeometryNV") {
        return features.get_feature("spheres");
    } else if (cap_name == "RayTraversalPrimitiveCullingKHR") {
        return features.get_feature("rayTraversalPrimitiveCulling") ||
            features.get_feature("rayQuery");
    } else if (cap_name == "ReplicatedCompositesEXT") {
        return features.get_feature("shaderReplicatedComposites");
    } else if (cap_name == "RoundingModeRTE") {
        return (properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderRoundingModeRTEFloat16 == VK_TRUE) ||
            (properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderRoundingModeRTEFloat32 == VK_TRUE) ||
            (properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderRoundingModeRTEFloat64 == VK_TRUE);
    } else if (cap_name == "RoundingModeRTZ") {
        return (properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderRoundingModeRTZFloat16 == VK_TRUE) ||
            (properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderRoundingModeRTZFloat32 == VK_TRUE) ||
            (properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderRoundingModeRTZFloat64 == VK_TRUE);
    } else if (cap_name == "RuntimeDescriptorArray") {
        return features.get_feature("runtimeDescriptorArray");
    } else if (cap_name == "SampleMaskOverrideCoverageNV") {
        return false;
    } else if (cap_name == "SampleMaskPostDepthCoverage") {
        return false;
    } else if (cap_name == "SampleRateShading") {
        return features.get_feature("sampleRateShading");
    } else if (cap_name == "Sampled1D") {
        return (vk_api_version >= VK_API_VERSION_1_0);
    } else if (cap_name == "SampledBuffer") {
        return (vk_api_version >= VK_API_VERSION_1_0);
    } else if (cap_name == "SampledCubeArray") {
        return features.get_feature("imageCubeArray");
    } else if (cap_name == "SampledImageArrayDynamicIndexing") {
        return features.get_feature("shaderSampledImageArrayDynamicIndexing");
    } else if (cap_name == "SampledImageArrayNonUniformIndexing") {
        return features.get_feature("shaderSampledImageArrayNonUniformIndexing");
    } else if (cap_name == "Shader") {
        return (vk_api_version >= VK_API_VERSION_1_0);
    } else if (cap_name == "Shader64BitIndexingEXT") {
        return features.get_feature("shader64BitIndexing");
    } else if (cap_name == "ShaderClockKHR") {
        return false;
    } else if (cap_name == "ShaderEnqueueAMDX") {
        return features.get_feature("shaderEnqueue");
    } else if (cap_name == "ShaderInvocationReorderEXT") {
        return false;
    } else if (cap_name == "ShaderInvocationReorderNV") {
        return false;
    } else if (cap_name == "ShaderLayer") {
        return features.get_feature("shaderOutputLayer");
    } else if (cap_name == "ShaderNonUniform") {
        return (vk_api_version >= VK_API_VERSION_1_2);
    } else if (cap_name == "ShaderSMBuiltinsNV") {
        return features.get_feature("shaderSMBuiltins");
    } else if (cap_name == "ShaderViewportIndex") {
        return features.get_feature("shaderOutputViewportIndex");
    } else if (cap_name == "ShaderViewportIndexLayerEXT") {
        return false;
    } else if (cap_name == "ShaderViewportMaskNV") {
        return false;
    } else if (cap_name == "SignedZeroInfNanPreserve") {
        return (properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderSignedZeroInfNanPreserveFloat16 == VK_TRUE) ||
            (properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderSignedZeroInfNanPreserveFloat32 == VK_TRUE) ||
            (properties.get<vk::PhysicalDeviceVulkan12Properties>().shaderSignedZeroInfNanPreserveFloat64 == VK_TRUE);
    } else if (cap_name == "SparseResidency") {
        return features.get_feature("shaderResourceResidency");
    } else if (cap_name == "StencilExportEXT") {
        return false;
    } else if (cap_name == "StorageBuffer16BitAccess") {
        return features.get_feature("storageBuffer16BitAccess") ||
            features.get_feature("storageBuffer16BitAccess");
    } else if (cap_name == "StorageBuffer8BitAccess") {
        return features.get_feature("storageBuffer8BitAccess");
    } else if (cap_name == "StorageBufferArrayDynamicIndexing") {
        return features.get_feature("shaderStorageBufferArrayDynamicIndexing");
    } else if (cap_name == "StorageBufferArrayNonUniformIndexing") {
        return features.get_feature("shaderStorageBufferArrayNonUniformIndexing");
    } else if (cap_name == "StorageImageArrayDynamicIndexing") {
        return features.get_feature("shaderStorageImageArrayDynamicIndexing");
    } else if (cap_name == "StorageImageArrayNonUniformIndexing") {
        return features.get_feature("shaderStorageImageArrayNonUniformIndexing");
    } else if (cap_name == "StorageImageExtendedFormats") {
        return (vk_api_version >= VK_API_VERSION_1_0);
    } else if (cap_name == "StorageImageMultisample") {
        return features.get_feature("shaderStorageImageMultisample");
    } else if (cap_name == "StorageImageReadWithoutFormat") {
        return features.get_feature("shaderStorageImageReadWithoutFormat") ||
            (vk_api_version >= VK_API_VERSION_1_3);
    } else if (cap_name == "StorageImageWriteWithoutFormat") {
        return features.get_feature("shaderStorageImageWriteWithoutFormat") ||
            (vk_api_version >= VK_API_VERSION_1_3);
    } else if (cap_name == "StorageInputOutput16") {
        return features.get_feature("storageInputOutput16") ||
            features.get_feature("storageInputOutput16");
    } else if (cap_name == "StoragePushConstant16") {
        return features.get_feature("storagePushConstant16") ||
            features.get_feature("storagePushConstant16");
    } else if (cap_name == "StoragePushConstant8") {
        return features.get_feature("storagePushConstant8");
    } else if (cap_name == "StorageTensorArrayDynamicIndexingARM") {
        return features.get_feature("shaderStorageTensorArrayDynamicIndexing");
    } else if (cap_name == "StorageTensorArrayNonUniformIndexingARM") {
        return features.get_feature("shaderStorageTensorArrayNonUniformIndexing");
    } else if (cap_name == "StorageTexelBufferArrayDynamicIndexing") {
        return features.get_feature("shaderStorageTexelBufferArrayDynamicIndexing");
    } else if (cap_name == "StorageTexelBufferArrayNonUniformIndexing") {
        return features.get_feature("shaderStorageTexelBufferArrayNonUniformIndexing");
    } else if (cap_name == "SubgroupBallotKHR") {
        return false;
    } else if (cap_name == "SubgroupVoteKHR") {
        return false;
    } else if (cap_name == "TensorAddressingNV") {
        return features.get_feature("cooperativeMatrixTensorAddressing");
    } else if (cap_name == "TensorsARM") {
        return features.get_feature("shaderTensorAccess");
    } else if (cap_name == "Tessellation") {
        return features.get_feature("tessellationShader");
    } else if (cap_name == "TessellationPointSize") {
        return features.get_feature("shaderTessellationAndGeometryPointSize");
    } else if (cap_name == "TextureBlockMatch2QCOM") {
        return features.get_feature("textureBlockMatch2");
    } else if (cap_name == "TextureBlockMatchQCOM") {
        return features.get_feature("textureBlockMatch");
    } else if (cap_name == "TextureBoxFilterQCOM") {
        return features.get_feature("textureBoxFilter");
    } else if (cap_name == "TextureSampleWeightedQCOM") {
        return features.get_feature("textureSampleWeighted");
    } else if (cap_name == "TileImageColorReadAccessEXT") {
        return features.get_feature("shaderTileImageColorReadAccess");
    } else if (cap_name == "TileImageDepthReadAccessEXT") {
        return features.get_feature("shaderTileImageDepthReadAccess");
    } else if (cap_name == "TileImageStencilReadAccessEXT") {
        return features.get_feature("shaderTileImageStencilReadAccess");
    } else if (cap_name == "TileShadingQCOM") {
        return features.get_feature("tileShading");
    } else if (cap_name == "TransformFeedback") {
        return features.get_feature("transformFeedback");
    } else if (cap_name == "UniformAndStorageBuffer16BitAccess") {
        return features.get_feature("uniformAndStorageBuffer16BitAccess") ||
            features.get_feature("uniformAndStorageBuffer16BitAccess");
    } else if (cap_name == "UniformAndStorageBuffer8BitAccess") {
        return features.get_feature("uniformAndStorageBuffer8BitAccess");
    } else if (cap_name == "UniformBufferArrayDynamicIndexing") {
        return features.get_feature("shaderUniformBufferArrayDynamicIndexing");
    } else if (cap_name == "UniformBufferArrayNonUniformIndexing") {
        return features.get_feature("shaderUniformBufferArrayNonUniformIndexing");
    } else if (cap_name == "UniformTexelBufferArrayDynamicIndexing") {
        return features.get_feature("shaderUniformTexelBufferArrayDynamicIndexing");
    } else if (cap_name == "UniformTexelBufferArrayNonUniformIndexing") {
        return features.get_feature("shaderUniformTexelBufferArrayNonUniformIndexing");
    } else if (cap_name == "UntypedPointersKHR") {
        return features.get_feature("shaderUntypedPointers");
    } else if (cap_name == "VariablePointers") {
        return features.get_feature("variablePointers") ||
            features.get_feature("variablePointers");
    } else if (cap_name == "VariablePointersStorageBuffer") {
        return features.get_feature("variablePointersStorageBuffer") ||
            features.get_feature("variablePointersStorageBuffer");
    } else if (cap_name == "VulkanMemoryModel") {
        return features.get_feature("vulkanMemoryModel");
    } else if (cap_name == "VulkanMemoryModelDeviceScope") {
        return features.get_feature("vulkanMemoryModelDeviceScope");
    } else if (cap_name == "WorkgroupMemoryExplicitLayout16BitAccessKHR") {
        return features.get_feature("workgroupMemoryExplicitLayout16BitAccess");
    } else if (cap_name == "WorkgroupMemoryExplicitLayout8BitAccessKHR") {
        return features.get_feature("workgroupMemoryExplicitLayout8BitAccess");
    } else if (cap_name == "WorkgroupMemoryExplicitLayoutKHR") {
        return features.get_feature("workgroupMemoryExplicitLayout");
    }
    
    return false;
}

std::vector<const char*> get_spirv_capability_extensions(
    const char* capability,
    uint32_t vk_api_version) {
    
    const std::string_view cap_name{capability};
    std::vector<const char*> result;
    
    if (cap_name == "AtomicFloat16AddEXT") {
        result.push_back(VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME);
    } else if (cap_name == "AtomicFloat16MinMaxEXT") {
        result.push_back(VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME);
    } else if (cap_name == "AtomicFloat16VectorNV") {
        result.push_back(VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_EXTENSION_NAME);
    } else if (cap_name == "AtomicFloat32AddEXT") {
        result.push_back(VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME);
    } else if (cap_name == "AtomicFloat32MinMaxEXT") {
        result.push_back(VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME);
    } else if (cap_name == "AtomicFloat64AddEXT") {
        result.push_back(VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME);
    } else if (cap_name == "AtomicFloat64MinMaxEXT") {
        result.push_back(VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME);
    } else if (cap_name == "BFloat16CooperativeMatrixKHR") {
        result.push_back(VK_KHR_SHADER_BFLOAT16_EXTENSION_NAME);
    } else if (cap_name == "BFloat16DotProductKHR") {
        result.push_back(VK_KHR_SHADER_BFLOAT16_EXTENSION_NAME);
    } else if (cap_name == "BFloat16TypeKHR") {
        result.push_back(VK_KHR_SHADER_BFLOAT16_EXTENSION_NAME);
    } else if (cap_name == "ClipDistance") {
    } else if (cap_name == "ClusterCullingShadingHUAWEI") {
        result.push_back(VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME);
    } else if (cap_name == "ComputeDerivativeGroupLinearKHR") {
        result.push_back(VK_KHR_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME);
        result.push_back(VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME);
    } else if (cap_name == "ComputeDerivativeGroupQuadsKHR") {
        result.push_back(VK_KHR_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME);
        result.push_back(VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME);
    } else if (cap_name == "CooperativeMatrixBlockLoadsNV") {
        result.push_back(VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME);
    } else if (cap_name == "CooperativeMatrixConversionQCOM") {
        result.push_back(VK_QCOM_COOPERATIVE_MATRIX_CONVERSION_EXTENSION_NAME);
    } else if (cap_name == "CooperativeMatrixConversionsNV") {
        result.push_back(VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME);
    } else if (cap_name == "CooperativeMatrixKHR") {
        result.push_back(VK_KHR_COOPERATIVE_MATRIX_EXTENSION_NAME);
    } else if (cap_name == "CooperativeMatrixNV") {
        result.push_back(VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME);
    } else if (cap_name == "CooperativeMatrixPerElementOperationsNV") {
        result.push_back(VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME);
    } else if (cap_name == "CooperativeMatrixReductionsNV") {
        result.push_back(VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME);
    } else if (cap_name == "CooperativeMatrixTensorAddressingNV") {
        result.push_back(VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME);
    } else if (cap_name == "CooperativeVectorNV") {
        result.push_back(VK_NV_COOPERATIVE_VECTOR_EXTENSION_NAME);
    } else if (cap_name == "CooperativeVectorTrainingNV") {
        result.push_back(VK_NV_COOPERATIVE_VECTOR_EXTENSION_NAME);
    } else if (cap_name == "CoreBuiltinsARM") {
        result.push_back(VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME);
    } else if (cap_name == "CullDistance") {
    } else if (cap_name == "DemoteToHelperInvocation") {
        if (vk_api_version < VK_API_VERSION_1_3) {
            result.push_back(VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME);
        }
    } else if (cap_name == "DenormFlushToZero") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME);
        }
    } else if (cap_name == "DenormPreserve") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME);
        }
    } else if (cap_name == "DerivativeControl") {
    } else if (cap_name == "DescriptorHeapEXT") {
        result.push_back(VK_EXT_DESCRIPTOR_HEAP_EXTENSION_NAME);
    } else if (cap_name == "DeviceGroup") {
        result.push_back(VK_KHR_DEVICE_GROUP_EXTENSION_NAME);
    } else if (cap_name == "DotProduct") {
        if (vk_api_version < VK_API_VERSION_1_3) {
            result.push_back(VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME);
        }
    } else if (cap_name == "DotProductInput4x8Bit") {
        if (vk_api_version < VK_API_VERSION_1_3) {
            result.push_back(VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME);
        }
    } else if (cap_name == "DotProductInput4x8BitPacked") {
        if (vk_api_version < VK_API_VERSION_1_3) {
            result.push_back(VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME);
        }
    } else if (cap_name == "DotProductInputAll") {
        if (vk_api_version < VK_API_VERSION_1_3) {
            result.push_back(VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME);
        }
    } else if (cap_name == "DrawParameters") {
        result.push_back(VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME);
    } else if (cap_name == "ExpectAssumeKHR") {
        if (vk_api_version < VK_API_VERSION_1_4) {
            result.push_back(VK_KHR_SHADER_EXPECT_ASSUME_EXTENSION_NAME);
        }
    } else if (cap_name == "FMAKHR") {
        result.push_back(VK_KHR_SHADER_FMA_EXTENSION_NAME);
    } else if (cap_name == "Float16") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME);
        }
        result.push_back(VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME);
    } else if (cap_name == "Float64") {
    } else if (cap_name == "Float8CooperativeMatrixEXT") {
        result.push_back(VK_EXT_SHADER_FLOAT8_EXTENSION_NAME);
    } else if (cap_name == "Float8EXT") {
        result.push_back(VK_EXT_SHADER_FLOAT8_EXTENSION_NAME);
    } else if (cap_name == "FloatControls2") {
        if (vk_api_version < VK_API_VERSION_1_4) {
            result.push_back(VK_KHR_SHADER_FLOAT_CONTROLS_2_EXTENSION_NAME);
        }
    } else if (cap_name == "FragmentBarycentricKHR") {
        result.push_back(VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME);
        result.push_back(VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME);
    } else if (cap_name == "FragmentDensityEXT") {
        result.push_back(VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME);
        result.push_back(VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME);
    } else if (cap_name == "FragmentFullyCoveredEXT") {
        result.push_back(VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME);
    } else if (cap_name == "FragmentMaskAMD") {
        result.push_back(VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME);
    } else if (cap_name == "FragmentShaderPixelInterlockEXT") {
        result.push_back(VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME);
    } else if (cap_name == "FragmentShaderSampleInterlockEXT") {
        result.push_back(VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME);
    } else if (cap_name == "FragmentShaderShadingRateInterlockEXT") {
        result.push_back(VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME);
        result.push_back(VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME);
    } else if (cap_name == "FragmentShadingRateKHR") {
        result.push_back(VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME);
    } else if (cap_name == "Geometry") {
    } else if (cap_name == "GeometryPointSize") {
    } else if (cap_name == "GeometryShaderPassthroughNV") {
        result.push_back(VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME);
    } else if (cap_name == "GeometryStreams") {
        result.push_back(VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME);
    } else if (cap_name == "GraphARM") {
        result.push_back(VK_ARM_DATA_GRAPH_EXTENSION_NAME);
    } else if (cap_name == "GroupNonUniform") {
    } else if (cap_name == "GroupNonUniformArithmetic") {
    } else if (cap_name == "GroupNonUniformBallot") {
    } else if (cap_name == "GroupNonUniformClustered") {
    } else if (cap_name == "GroupNonUniformPartitionedEXT") {
        result.push_back(VK_EXT_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME);
        result.push_back(VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME);
    } else if (cap_name == "GroupNonUniformQuad") {
    } else if (cap_name == "GroupNonUniformRotateKHR") {
        if (vk_api_version < VK_API_VERSION_1_4) {
            result.push_back(VK_KHR_SHADER_SUBGROUP_ROTATE_EXTENSION_NAME);
        }
    } else if (cap_name == "GroupNonUniformShuffle") {
    } else if (cap_name == "GroupNonUniformShuffleRelative") {
    } else if (cap_name == "GroupNonUniformVote") {
    } else if (cap_name == "Image1D") {
    } else if (cap_name == "ImageBuffer") {
    } else if (cap_name == "ImageCubeArray") {
    } else if (cap_name == "ImageFootprintNV") {
        result.push_back(VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME);
    } else if (cap_name == "ImageGatherBiasLodAMD") {
        result.push_back(VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME);
    } else if (cap_name == "ImageGatherExtended") {
    } else if (cap_name == "ImageMSArray") {
    } else if (cap_name == "ImageQuery") {
    } else if (cap_name == "ImageReadWriteLodAMD") {
        result.push_back(VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME);
    } else if (cap_name == "InputAttachment") {
    } else if (cap_name == "InputAttachmentArrayDynamicIndexing") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME);
        }
    } else if (cap_name == "InputAttachmentArrayNonUniformIndexing") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME);
        }
    } else if (cap_name == "Int16") {
    } else if (cap_name == "Int64") {
    } else if (cap_name == "Int64Atomics") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME);
        }
        result.push_back(VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME);
    } else if (cap_name == "Int64ImageEXT") {
        result.push_back(VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME);
    } else if (cap_name == "Int8") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME);
        }
    } else if (cap_name == "IntegerFunctions2INTEL") {
        result.push_back(VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME);
    } else if (cap_name == "InterpolationFunction") {
    } else if (cap_name == "LongVectorEXT") {
        result.push_back(VK_EXT_SHADER_LONG_VECTOR_EXTENSION_NAME);
    } else if (cap_name == "Matrix") {
    } else if (cap_name == "MeshShadingEXT") {
        result.push_back(VK_EXT_MESH_SHADER_EXTENSION_NAME);
    } else if (cap_name == "MeshShadingNV") {
        result.push_back(VK_NV_MESH_SHADER_EXTENSION_NAME);
    } else if (cap_name == "MinLod") {
    } else if (cap_name == "MultiView") {
        result.push_back(VK_KHR_MULTIVIEW_EXTENSION_NAME);
    } else if (cap_name == "MultiViewport") {
    } else if (cap_name == "PerViewAttributesNV") {
        result.push_back(VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME);
    } else if (cap_name == "PhysicalStorageBufferAddresses") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME);
        }
        result.push_back(VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME);
    } else if (cap_name == "PushConstantBanksNV") {
        result.push_back(VK_NV_PUSH_CONSTANT_BANK_EXTENSION_NAME);
    } else if (cap_name == "QuadControlKHR") {
        result.push_back(VK_KHR_SHADER_QUAD_CONTROL_EXTENSION_NAME);
    } else if (cap_name == "RawAccessChainsNV") {
        result.push_back(VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME);
    } else if (cap_name == "RayCullMaskKHR") {
        result.push_back(VK_KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME);
    } else if (cap_name == "RayQueryKHR") {
        result.push_back(VK_KHR_RAY_QUERY_EXTENSION_NAME);
    } else if (cap_name == "RayQueryPositionFetchKHR") {
        result.push_back(VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME);
    } else if (cap_name == "RayTracingClusterAccelerationStructureNV") {
        result.push_back(VK_NV_CLUSTER_ACCELERATION_STRUCTURE_EXTENSION_NAME);
    } else if (cap_name == "RayTracingKHR") {
        result.push_back(VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME);
    } else if (cap_name == "RayTracingLinearSweptSpheresGeometryNV") {
        result.push_back(VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_EXTENSION_NAME);
    } else if (cap_name == "RayTracingMotionBlurNV") {
        result.push_back(VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME);
    } else if (cap_name == "RayTracingNV") {
        result.push_back(VK_NV_RAY_TRACING_EXTENSION_NAME);
    } else if (cap_name == "RayTracingOpacityMicromapEXT") {
        result.push_back(VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME);
    } else if (cap_name == "RayTracingPositionFetchKHR") {
        result.push_back(VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME);
    } else if (cap_name == "RayTracingSpheresGeometryNV") {
        result.push_back(VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_EXTENSION_NAME);
    } else if (cap_name == "RayTraversalPrimitiveCullingKHR") {
        result.push_back(VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME);
        result.push_back(VK_KHR_RAY_QUERY_EXTENSION_NAME);
    } else if (cap_name == "ReplicatedCompositesEXT") {
        result.push_back(VK_EXT_SHADER_REPLICATED_COMPOSITES_EXTENSION_NAME);
    } else if (cap_name == "RoundingModeRTE") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME);
        }
    } else if (cap_name == "RoundingModeRTZ") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME);
        }
    } else if (cap_name == "RuntimeDescriptorArray") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME);
        }
    } else if (cap_name == "SampleMaskOverrideCoverageNV") {
        result.push_back(VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME);
    } else if (cap_name == "SampleMaskPostDepthCoverage") {
        result.push_back(VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME);
    } else if (cap_name == "SampleRateShading") {
    } else if (cap_name == "Sampled1D") {
    } else if (cap_name == "SampledBuffer") {
    } else if (cap_name == "SampledCubeArray") {
    } else if (cap_name == "SampledImageArrayDynamicIndexing") {
    } else if (cap_name == "SampledImageArrayNonUniformIndexing") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME);
        }
    } else if (cap_name == "Shader") {
    } else if (cap_name == "Shader64BitIndexingEXT") {
        result.push_back(VK_EXT_SHADER_64BIT_INDEXING_EXTENSION_NAME);
    } else if (cap_name == "ShaderClockKHR") {
        result.push_back(VK_KHR_SHADER_CLOCK_EXTENSION_NAME);
    } else if (cap_name == "ShaderEnqueueAMDX") {
    } else if (cap_name == "ShaderInvocationReorderEXT") {
        result.push_back(VK_EXT_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME);
    } else if (cap_name == "ShaderInvocationReorderNV") {
        result.push_back(VK_NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME);
    } else if (cap_name == "ShaderLayer") {
    } else if (cap_name == "ShaderNonUniform") {
        result.push_back(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME);
    } else if (cap_name == "ShaderSMBuiltinsNV") {
        result.push_back(VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME);
    } else if (cap_name == "ShaderViewportIndex") {
    } else if (cap_name == "ShaderViewportIndexLayerEXT") {
        result.push_back(VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME);
        result.push_back(VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME);
    } else if (cap_name == "ShaderViewportMaskNV") {
        result.push_back(VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME);
    } else if (cap_name == "SignedZeroInfNanPreserve") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME);
        }
    } else if (cap_name == "SparseResidency") {
    } else if (cap_name == "StencilExportEXT") {
        result.push_back(VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME);
    } else if (cap_name == "StorageBuffer16BitAccess") {
        result.push_back(VK_KHR_16BIT_STORAGE_EXTENSION_NAME);
    } else if (cap_name == "StorageBuffer8BitAccess") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_KHR_8BIT_STORAGE_EXTENSION_NAME);
        }
    } else if (cap_name == "StorageBufferArrayDynamicIndexing") {
    } else if (cap_name == "StorageBufferArrayNonUniformIndexing") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME);
        }
    } else if (cap_name == "StorageImageArrayDynamicIndexing") {
    } else if (cap_name == "StorageImageArrayNonUniformIndexing") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME);
        }
    } else if (cap_name == "StorageImageExtendedFormats") {
    } else if (cap_name == "StorageImageMultisample") {
    } else if (cap_name == "StorageImageReadWithoutFormat") {
        result.push_back(VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME);
    } else if (cap_name == "StorageImageWriteWithoutFormat") {
        result.push_back(VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME);
    } else if (cap_name == "StorageInputOutput16") {
        result.push_back(VK_KHR_16BIT_STORAGE_EXTENSION_NAME);
    } else if (cap_name == "StoragePushConstant16") {
        result.push_back(VK_KHR_16BIT_STORAGE_EXTENSION_NAME);
    } else if (cap_name == "StoragePushConstant8") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_KHR_8BIT_STORAGE_EXTENSION_NAME);
        }
    } else if (cap_name == "StorageTensorArrayDynamicIndexingARM") {
        result.push_back(VK_ARM_TENSORS_EXTENSION_NAME);
    } else if (cap_name == "StorageTensorArrayNonUniformIndexingARM") {
        result.push_back(VK_ARM_TENSORS_EXTENSION_NAME);
    } else if (cap_name == "StorageTexelBufferArrayDynamicIndexing") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME);
        }
    } else if (cap_name == "StorageTexelBufferArrayNonUniformIndexing") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME);
        }
    } else if (cap_name == "SubgroupBallotKHR") {
        result.push_back(VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME);
    } else if (cap_name == "SubgroupVoteKHR") {
        result.push_back(VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME);
    } else if (cap_name == "TensorAddressingNV") {
        result.push_back(VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME);
    } else if (cap_name == "TensorsARM") {
        result.push_back(VK_ARM_TENSORS_EXTENSION_NAME);
    } else if (cap_name == "Tessellation") {
    } else if (cap_name == "TessellationPointSize") {
    } else if (cap_name == "TextureBlockMatch2QCOM") {
        result.push_back(VK_QCOM_IMAGE_PROCESSING_2_EXTENSION_NAME);
    } else if (cap_name == "TextureBlockMatchQCOM") {
        result.push_back(VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME);
    } else if (cap_name == "TextureBoxFilterQCOM") {
        result.push_back(VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME);
    } else if (cap_name == "TextureSampleWeightedQCOM") {
        result.push_back(VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME);
    } else if (cap_name == "TileImageColorReadAccessEXT") {
        result.push_back(VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME);
    } else if (cap_name == "TileImageDepthReadAccessEXT") {
        result.push_back(VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME);
    } else if (cap_name == "TileImageStencilReadAccessEXT") {
        result.push_back(VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME);
    } else if (cap_name == "TileShadingQCOM") {
        result.push_back(VK_QCOM_TILE_SHADING_EXTENSION_NAME);
    } else if (cap_name == "TransformFeedback") {
        result.push_back(VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME);
    } else if (cap_name == "UniformAndStorageBuffer16BitAccess") {
        result.push_back(VK_KHR_16BIT_STORAGE_EXTENSION_NAME);
    } else if (cap_name == "UniformAndStorageBuffer8BitAccess") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_KHR_8BIT_STORAGE_EXTENSION_NAME);
        }
    } else if (cap_name == "UniformBufferArrayDynamicIndexing") {
    } else if (cap_name == "UniformBufferArrayNonUniformIndexing") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME);
        }
    } else if (cap_name == "UniformTexelBufferArrayDynamicIndexing") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME);
        }
    } else if (cap_name == "UniformTexelBufferArrayNonUniformIndexing") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME);
        }
    } else if (cap_name == "UntypedPointersKHR") {
        result.push_back(VK_KHR_SHADER_UNTYPED_POINTERS_EXTENSION_NAME);
    } else if (cap_name == "VariablePointers") {
        result.push_back(VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME);
    } else if (cap_name == "VariablePointersStorageBuffer") {
        result.push_back(VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME);
    } else if (cap_name == "VulkanMemoryModel") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME);
        }
    } else if (cap_name == "VulkanMemoryModelDeviceScope") {
        if (vk_api_version < VK_API_VERSION_1_2) {
            result.push_back(VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME);
        }
    } else if (cap_name == "WorkgroupMemoryExplicitLayout16BitAccessKHR") {
        result.push_back(VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME);
    } else if (cap_name == "WorkgroupMemoryExplicitLayout8BitAccessKHR") {
        result.push_back(VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME);
    } else if (cap_name == "WorkgroupMemoryExplicitLayoutKHR") {
        result.push_back(VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME);
    }
    
    return result;
}

std::vector<std::string> get_spirv_capability_features(
    const char* capability,
    [[maybe_unused]] uint32_t vk_api_version) {
    
    const std::string_view cap_name{capability};
    
    if (cap_name == "AtomicFloat16AddEXT") {
        return {
            "shaderBufferFloat16AtomicAdd",
            "shaderSharedFloat16AtomicAdd",
        };
    } else if (cap_name == "AtomicFloat16MinMaxEXT") {
        return {
            "shaderBufferFloat16AtomicMinMax",
            "shaderSharedFloat16AtomicMinMax",
        };
    } else if (cap_name == "AtomicFloat16VectorNV") {
        return {
            "shaderFloat16VectorAtomics",
        };
    } else if (cap_name == "AtomicFloat32AddEXT") {
        return {
            "shaderBufferFloat32AtomicAdd",
            "shaderSharedFloat32AtomicAdd",
            "shaderImageFloat32AtomicAdd",
        };
    } else if (cap_name == "AtomicFloat32MinMaxEXT") {
        return {
            "shaderBufferFloat32AtomicMinMax",
            "shaderSharedFloat32AtomicMinMax",
            "shaderImageFloat32AtomicMinMax",
        };
    } else if (cap_name == "AtomicFloat64AddEXT") {
        return {
            "shaderBufferFloat64AtomicAdd",
            "shaderSharedFloat64AtomicAdd",
        };
    } else if (cap_name == "AtomicFloat64MinMaxEXT") {
        return {
            "shaderBufferFloat64AtomicMinMax",
            "shaderSharedFloat64AtomicMinMax",
        };
    } else if (cap_name == "BFloat16CooperativeMatrixKHR") {
        return {
            "shaderBFloat16CooperativeMatrix",
        };
    } else if (cap_name == "BFloat16DotProductKHR") {
        return {
            "shaderBFloat16DotProduct",
        };
    } else if (cap_name == "BFloat16TypeKHR") {
        return {
            "shaderBFloat16Type",
        };
    } else if (cap_name == "ClipDistance") {
        return {
            "shaderClipDistance",
        };
    } else if (cap_name == "ClusterCullingShadingHUAWEI") {
        return {
            "clustercullingShader",
        };
    } else if (cap_name == "ComputeDerivativeGroupLinearKHR") {
        return {
            "computeDerivativeGroupLinear",
            "computeDerivativeGroupLinear",
        };
    } else if (cap_name == "ComputeDerivativeGroupQuadsKHR") {
        return {
            "computeDerivativeGroupQuads",
            "computeDerivativeGroupQuads",
        };
    } else if (cap_name == "CooperativeMatrixBlockLoadsNV") {
        return {
            "cooperativeMatrixBlockLoads",
        };
    } else if (cap_name == "CooperativeMatrixConversionQCOM") {
        return {
            "cooperativeMatrixConversion",
        };
    } else if (cap_name == "CooperativeMatrixConversionsNV") {
        return {
            "cooperativeMatrixConversions",
        };
    } else if (cap_name == "CooperativeMatrixKHR") {
        return {
            "cooperativeMatrix",
        };
    } else if (cap_name == "CooperativeMatrixNV") {
        return {
            "cooperativeMatrix",
        };
    } else if (cap_name == "CooperativeMatrixPerElementOperationsNV") {
        return {
            "cooperativeMatrixPerElementOperations",
        };
    } else if (cap_name == "CooperativeMatrixReductionsNV") {
        return {
            "cooperativeMatrixReductions",
        };
    } else if (cap_name == "CooperativeMatrixTensorAddressingNV") {
        return {
            "cooperativeMatrixTensorAddressing",
        };
    } else if (cap_name == "CooperativeVectorNV") {
        return {
            "cooperativeVector",
        };
    } else if (cap_name == "CooperativeVectorTrainingNV") {
        return {
            "cooperativeVectorTraining",
        };
    } else if (cap_name == "CoreBuiltinsARM") {
        return {
            "shaderCoreBuiltins",
        };
    } else if (cap_name == "CullDistance") {
        return {
            "shaderCullDistance",
        };
    } else if (cap_name == "DemoteToHelperInvocation") {
        return {
            "shaderDemoteToHelperInvocation",
            "shaderDemoteToHelperInvocation",
        };
    } else if (cap_name == "DescriptorHeapEXT") {
        return {
            "descriptorHeap",
        };
    } else if (cap_name == "DotProduct") {
        return {
            "shaderIntegerDotProduct",
            "shaderIntegerDotProduct",
        };
    } else if (cap_name == "DotProductInput4x8Bit") {
        return {
            "shaderIntegerDotProduct",
            "shaderIntegerDotProduct",
        };
    } else if (cap_name == "DotProductInput4x8BitPacked") {
        return {
            "shaderIntegerDotProduct",
            "shaderIntegerDotProduct",
        };
    } else if (cap_name == "DotProductInputAll") {
        return {
            "shaderIntegerDotProduct",
            "shaderIntegerDotProduct",
        };
    } else if (cap_name == "DrawParameters") {
        return {
            "shaderDrawParameters",
            "shaderDrawParameters",
        };
    } else if (cap_name == "ExpectAssumeKHR") {
        return {
            "shaderExpectAssume",
            "shaderExpectAssume",
        };
    } else if (cap_name == "FMAKHR") {
        return {
            "shaderFmaFloat16",
            "shaderFmaFloat32",
            "shaderFmaFloat64",
        };
    } else if (cap_name == "Float16") {
        return {
            "shaderFloat16",
        };
    } else if (cap_name == "Float64") {
        return {
            "shaderFloat64",
        };
    } else if (cap_name == "Float8CooperativeMatrixEXT") {
        return {
            "shaderFloat8CooperativeMatrix",
        };
    } else if (cap_name == "Float8EXT") {
        return {
            "shaderFloat8",
        };
    } else if (cap_name == "FloatControls2") {
        return {
            "shaderFloatControls2",
            "shaderFloatControls2",
        };
    } else if (cap_name == "FragmentBarycentricKHR") {
        return {
            "fragmentShaderBarycentric",
            "fragmentShaderBarycentric",
        };
    } else if (cap_name == "FragmentDensityEXT") {
        return {
            "fragmentDensityMap",
            "shadingRateImage",
        };
    } else if (cap_name == "FragmentShaderPixelInterlockEXT") {
        return {
            "fragmentShaderPixelInterlock",
        };
    } else if (cap_name == "FragmentShaderSampleInterlockEXT") {
        return {
            "fragmentShaderSampleInterlock",
        };
    } else if (cap_name == "FragmentShaderShadingRateInterlockEXT") {
        return {
            "fragmentShaderShadingRateInterlock",
            "shadingRateImage",
        };
    } else if (cap_name == "FragmentShadingRateKHR") {
        return {
            "pipelineFragmentShadingRate",
            "primitiveFragmentShadingRate",
            "attachmentFragmentShadingRate",
        };
    } else if (cap_name == "Geometry") {
        return {
            "geometryShader",
        };
    } else if (cap_name == "GeometryPointSize") {
        return {
            "shaderTessellationAndGeometryPointSize",
        };
    } else if (cap_name == "GeometryStreams") {
        return {
            "geometryStreams",
        };
    } else if (cap_name == "GraphARM") {
        return {
            "dataGraph",
        };
    } else if (cap_name == "GroupNonUniformPartitionedEXT") {
        return {
            "shaderSubgroupPartitioned",
        };
    } else if (cap_name == "GroupNonUniformRotateKHR") {
        return {
            "shaderSubgroupRotate",
            "shaderSubgroupRotate",
        };
    } else if (cap_name == "ImageCubeArray") {
        return {
            "imageCubeArray",
        };
    } else if (cap_name == "ImageFootprintNV") {
        return {
            "imageFootprint",
        };
    } else if (cap_name == "ImageGatherExtended") {
        return {
            "shaderImageGatherExtended",
        };
    } else if (cap_name == "ImageMSArray") {
        return {
            "shaderStorageImageMultisample",
        };
    } else if (cap_name == "InputAttachmentArrayDynamicIndexing") {
        return {
            "shaderInputAttachmentArrayDynamicIndexing",
        };
    } else if (cap_name == "InputAttachmentArrayNonUniformIndexing") {
        return {
            "shaderInputAttachmentArrayNonUniformIndexing",
        };
    } else if (cap_name == "Int16") {
        return {
            "shaderInt16",
        };
    } else if (cap_name == "Int64") {
        return {
            "shaderInt64",
        };
    } else if (cap_name == "Int64Atomics") {
        return {
            "shaderBufferInt64Atomics",
            "shaderSharedInt64Atomics",
            "shaderImageInt64Atomics",
        };
    } else if (cap_name == "Int64ImageEXT") {
        return {
            "shaderImageInt64Atomics",
        };
    } else if (cap_name == "Int8") {
        return {
            "shaderInt8",
        };
    } else if (cap_name == "IntegerFunctions2INTEL") {
        return {
            "shaderIntegerFunctions2",
        };
    } else if (cap_name == "InterpolationFunction") {
        return {
            "sampleRateShading",
        };
    } else if (cap_name == "LongVectorEXT") {
        return {
            "longVector",
        };
    } else if (cap_name == "MinLod") {
        return {
            "shaderResourceMinLod",
        };
    } else if (cap_name == "MultiView") {
        return {
            "multiview",
            "multiview",
        };
    } else if (cap_name == "MultiViewport") {
        return {
            "multiViewport",
        };
    } else if (cap_name == "PhysicalStorageBufferAddresses") {
        return {
            "bufferDeviceAddress",
            "bufferDeviceAddress",
        };
    } else if (cap_name == "PushConstantBanksNV") {
        return {
            "pushConstantBank",
        };
    } else if (cap_name == "QuadControlKHR") {
        return {
            "shaderQuadControl",
        };
    } else if (cap_name == "RawAccessChainsNV") {
        return {
            "shaderRawAccessChains",
        };
    } else if (cap_name == "RayCullMaskKHR") {
        return {
            "rayTracingMaintenance1",
        };
    } else if (cap_name == "RayQueryKHR") {
        return {
            "rayQuery",
        };
    } else if (cap_name == "RayQueryPositionFetchKHR") {
        return {
            "rayTracingPositionFetch",
        };
    } else if (cap_name == "RayTracingClusterAccelerationStructureNV") {
        return {
            "clusterAccelerationStructure",
        };
    } else if (cap_name == "RayTracingKHR") {
        return {
            "rayTracingPipeline",
        };
    } else if (cap_name == "RayTracingLinearSweptSpheresGeometryNV") {
        return {
            "linearSweptSpheres",
        };
    } else if (cap_name == "RayTracingMotionBlurNV") {
        return {
            "rayTracingMotionBlur",
        };
    } else if (cap_name == "RayTracingPositionFetchKHR") {
        return {
            "rayTracingPositionFetch",
        };
    } else if (cap_name == "RayTracingSpheresGeometryNV") {
        return {
            "spheres",
        };
    } else if (cap_name == "RayTraversalPrimitiveCullingKHR") {
        return {
            "rayTraversalPrimitiveCulling",
            "rayQuery",
        };
    } else if (cap_name == "ReplicatedCompositesEXT") {
        return {
            "shaderReplicatedComposites",
        };
    } else if (cap_name == "RuntimeDescriptorArray") {
        return {
            "runtimeDescriptorArray",
        };
    } else if (cap_name == "SampleRateShading") {
        return {
            "sampleRateShading",
        };
    } else if (cap_name == "SampledCubeArray") {
        return {
            "imageCubeArray",
        };
    } else if (cap_name == "SampledImageArrayDynamicIndexing") {
        return {
            "shaderSampledImageArrayDynamicIndexing",
        };
    } else if (cap_name == "SampledImageArrayNonUniformIndexing") {
        return {
            "shaderSampledImageArrayNonUniformIndexing",
        };
    } else if (cap_name == "Shader64BitIndexingEXT") {
        return {
            "shader64BitIndexing",
        };
    } else if (cap_name == "ShaderEnqueueAMDX") {
        return {
            "shaderEnqueue",
        };
    } else if (cap_name == "ShaderLayer") {
        return {
            "shaderOutputLayer",
        };
    } else if (cap_name == "ShaderSMBuiltinsNV") {
        return {
            "shaderSMBuiltins",
        };
    } else if (cap_name == "ShaderViewportIndex") {
        return {
            "shaderOutputViewportIndex",
        };
    } else if (cap_name == "SparseResidency") {
        return {
            "shaderResourceResidency",
        };
    } else if (cap_name == "StorageBuffer16BitAccess") {
        return {
            "storageBuffer16BitAccess",
            "storageBuffer16BitAccess",
        };
    } else if (cap_name == "StorageBuffer8BitAccess") {
        return {
            "storageBuffer8BitAccess",
        };
    } else if (cap_name == "StorageBufferArrayDynamicIndexing") {
        return {
            "shaderStorageBufferArrayDynamicIndexing",
        };
    } else if (cap_name == "StorageBufferArrayNonUniformIndexing") {
        return {
            "shaderStorageBufferArrayNonUniformIndexing",
        };
    } else if (cap_name == "StorageImageArrayDynamicIndexing") {
        return {
            "shaderStorageImageArrayDynamicIndexing",
        };
    } else if (cap_name == "StorageImageArrayNonUniformIndexing") {
        return {
            "shaderStorageImageArrayNonUniformIndexing",
        };
    } else if (cap_name == "StorageImageMultisample") {
        return {
            "shaderStorageImageMultisample",
        };
    } else if (cap_name == "StorageImageReadWithoutFormat") {
        return {
            "shaderStorageImageReadWithoutFormat",
        };
    } else if (cap_name == "StorageImageWriteWithoutFormat") {
        return {
            "shaderStorageImageWriteWithoutFormat",
        };
    } else if (cap_name == "StorageInputOutput16") {
        return {
            "storageInputOutput16",
            "storageInputOutput16",
        };
    } else if (cap_name == "StoragePushConstant16") {
        return {
            "storagePushConstant16",
            "storagePushConstant16",
        };
    } else if (cap_name == "StoragePushConstant8") {
        return {
            "storagePushConstant8",
        };
    } else if (cap_name == "StorageTensorArrayDynamicIndexingARM") {
        return {
            "shaderStorageTensorArrayDynamicIndexing",
        };
    } else if (cap_name == "StorageTensorArrayNonUniformIndexingARM") {
        return {
            "shaderStorageTensorArrayNonUniformIndexing",
        };
    } else if (cap_name == "StorageTexelBufferArrayDynamicIndexing") {
        return {
            "shaderStorageTexelBufferArrayDynamicIndexing",
        };
    } else if (cap_name == "StorageTexelBufferArrayNonUniformIndexing") {
        return {
            "shaderStorageTexelBufferArrayNonUniformIndexing",
        };
    } else if (cap_name == "TensorAddressingNV") {
        return {
            "cooperativeMatrixTensorAddressing",
        };
    } else if (cap_name == "TensorsARM") {
        return {
            "shaderTensorAccess",
        };
    } else if (cap_name == "Tessellation") {
        return {
            "tessellationShader",
        };
    } else if (cap_name == "TessellationPointSize") {
        return {
            "shaderTessellationAndGeometryPointSize",
        };
    } else if (cap_name == "TextureBlockMatch2QCOM") {
        return {
            "textureBlockMatch2",
        };
    } else if (cap_name == "TextureBlockMatchQCOM") {
        return {
            "textureBlockMatch",
        };
    } else if (cap_name == "TextureBoxFilterQCOM") {
        return {
            "textureBoxFilter",
        };
    } else if (cap_name == "TextureSampleWeightedQCOM") {
        return {
            "textureSampleWeighted",
        };
    } else if (cap_name == "TileImageColorReadAccessEXT") {
        return {
            "shaderTileImageColorReadAccess",
        };
    } else if (cap_name == "TileImageDepthReadAccessEXT") {
        return {
            "shaderTileImageDepthReadAccess",
        };
    } else if (cap_name == "TileImageStencilReadAccessEXT") {
        return {
            "shaderTileImageStencilReadAccess",
        };
    } else if (cap_name == "TileShadingQCOM") {
        return {
            "tileShading",
        };
    } else if (cap_name == "TransformFeedback") {
        return {
            "transformFeedback",
        };
    } else if (cap_name == "UniformAndStorageBuffer16BitAccess") {
        return {
            "uniformAndStorageBuffer16BitAccess",
            "uniformAndStorageBuffer16BitAccess",
        };
    } else if (cap_name == "UniformAndStorageBuffer8BitAccess") {
        return {
            "uniformAndStorageBuffer8BitAccess",
        };
    } else if (cap_name == "UniformBufferArrayDynamicIndexing") {
        return {
            "shaderUniformBufferArrayDynamicIndexing",
        };
    } else if (cap_name == "UniformBufferArrayNonUniformIndexing") {
        return {
            "shaderUniformBufferArrayNonUniformIndexing",
        };
    } else if (cap_name == "UniformTexelBufferArrayDynamicIndexing") {
        return {
            "shaderUniformTexelBufferArrayDynamicIndexing",
        };
    } else if (cap_name == "UniformTexelBufferArrayNonUniformIndexing") {
        return {
            "shaderUniformTexelBufferArrayNonUniformIndexing",
        };
    } else if (cap_name == "UntypedPointersKHR") {
        return {
            "shaderUntypedPointers",
        };
    } else if (cap_name == "VariablePointers") {
        return {
            "variablePointers",
            "variablePointers",
        };
    } else if (cap_name == "VariablePointersStorageBuffer") {
        return {
            "variablePointersStorageBuffer",
            "variablePointersStorageBuffer",
        };
    } else if (cap_name == "VulkanMemoryModel") {
        return {
            "vulkanMemoryModel",
        };
    } else if (cap_name == "VulkanMemoryModelDeviceScope") {
        return {
            "vulkanMemoryModelDeviceScope",
        };
    } else if (cap_name == "WorkgroupMemoryExplicitLayout16BitAccessKHR") {
        return {
            "workgroupMemoryExplicitLayout16BitAccess",
        };
    } else if (cap_name == "WorkgroupMemoryExplicitLayout8BitAccessKHR") {
        return {
            "workgroupMemoryExplicitLayout8BitAccess",
        };
    } else if (cap_name == "WorkgroupMemoryExplicitLayoutKHR") {
        return {
            "workgroupMemoryExplicitLayout",
        };
    }
    
    return {};
}

} // namespace merian
