#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_control_flow_attributes : enable

#include "svgf_graph_layout.glsl"
#include "common/colors_yuv.glsl"

layout(set = 1, binding = 0) uniform sampler2D img_filter_in;
layout(set = 1, binding = 1) uniform writeonly image2D img_filter_out;

layout(push_constant, std140) uniform push_t {
    int gap;
    float param_z;
    float param_n;
    float param_l;
    int filter_variance;
} params;

vec3 filter_irr;
float filter_var;
float filter_w;
vec3 c_n;
float c_z;
float c_l;

float get_sigma_l(float center, ivec2 ipos) {
  const float gaussian_kernel[3][3] = {
    { 1.0 / 16.0, 1.0 / 8.0, 1.0 / 16.0 },
    { 1.0 / 8.0,  1.0 / 4.0, 1.0 / 8.0  },
    { 1.0 / 16.0, 1.0 / 8.0, 1.0 / 16.0 }
  };

  float sum = center * gaussian_kernel[1][1];
  const int r = 1;
  for(int yy = -r; yy <= r; yy++) {
    for(int xx = -r; xx <= r; xx++) {
      if(xx != 0 || yy != 0) {
        const ivec2 p = ipos + ivec2(xx, yy);
        const float v = texelFetch(img_filter_in, p, 0).a;
        const float w = gaussian_kernel[xx + 1][yy + 1];
        sum += v * w;
      }
    }
  }

  return sqrt(max(sum, 0.0));
}

void tap(const ivec2 p,
         const float kernel_weight,
         const float sigma_l) {
  const vec4  p_irr_var   = texelFetch(img_filter_in,  p, 0); 
  const vec4  p_gbuf      = texelFetch(img_gbuf, p, 0); 
  const vec3  p_n         = p_gbuf.rgb;
  const float p_z         = p_gbuf.a;
  const float p_l         = yuv_luminance(p_irr_var.rgb); 

  const float w_l = abs(p_l - c_l) / (sigma_l + 1e-10);
  // This is different to the paper version which uses
  // 3.0 * abs(z_p - z_center.x) / (z_center.y * length(vec2(offset) * step_size) + 1e-2); 
  const float w_z = (200 * abs(p_z - c_z) / max(p_z, c_z)) / (params.param_z); 
  const float w_n = pow(max(0, dot(p_n, c_n)), params.param_n); 

  const float w = exp(-w_l * w_l - w_z) * w_n * kernel_weight; 

  filter_irr += p_irr_var.rgb * w; 
  filter_var += p_irr_var.a * w * w; 
  filter_w   += w; 
}

void
main() {
  const ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if (any(greaterThanEqual(ipos, imageSize(img_filter_out)))) return;

  const vec4 gbuf = texelFetch(img_gbuf, ipos, 0);
  c_n = gbuf.rgb;
  c_z = gbuf.a;
  const vec4 filter_in = texelFetch(img_filter_in, ipos, 0);
  c_l = yuv_luminance(filter_in.rgb);

  float sigma_l = 0;
  if (params.filter_variance == 1) {
    // the reference implementation does that
    // but it looks better without
    sigma_l = get_sigma_l(filter_in.a, ipos) * params.param_l;
  } else {
    sigma_l = sqrt(filter_in.a) * params.param_l;
  }

  filter_irr = filter_in.rgb;
  filter_var = filter_in.a;
  filter_w = 1.0;

  if (c_z > 0) {
    float kernel[] = {1., 2. / 3., 1. / 6.};
    [[unroll]]
    for (int j = -2; j <= 2; j++) {
      [[unroll]]
      for (int i = -2; i <= 2; i++) {
        if (i != 0 || j != 0) {
          const float weight = kernel[abs(i)] * kernel[abs(j)];
          tap(ivec2(i,  j) * params.gap + ipos, weight, sigma_l);
        }
      }
    }

    filter_irr /= filter_w;
    filter_var /= (filter_w * filter_w);
  }

  imageStore(img_filter_out, ipos, vec4(filter_irr, filter_var));
}

