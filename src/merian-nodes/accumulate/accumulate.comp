#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable
#extension GL_EXT_control_flow_attributes : enable

layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z = 1) in;
layout (constant_id = 2) const int FILTER_MODE = 1;
layout (constant_id = 3) const int EXTENDED_SEARCH = 1;

layout(set = 0, binding = 0) uniform sampler2D img_prev_accum;
layout(set = 0, binding = 1) uniform sampler2D img_prev_moments;

layout(set = 0, binding = 2) uniform sampler2D img_irr;
layout(set = 0, binding = 3) uniform sampler2D img_gbuf;
layout(set = 0, binding = 4) uniform sampler2D img_prev_gbuf;

layout(set = 0, binding = 5) uniform sampler2D img_mv;


layout(set = 0, binding = 6) uniform writeonly image2D img_accum;
layout(set = 0, binding = 7) uniform writeonly image2D img_moments;


#include "common/colors_yuv.glsl"
#include "common/normal_encode.glsl"
#include "common/reprojection.glsl"

layout(push_constant, std140) uniform params_t { 
    float accum_alpha;
    float accum_max_hist;
    float normal_reject_cos;
    float z_reject_percent;
    uint clear;
} params;

void
main() {
  const ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_accum)))) return;

  const vec4 curr_irr_samples = texelFetch(img_irr, ipos, 0);
  const vec4 curr_normal_z = texelFetch(img_gbuf, ipos, 0);
  const vec3 curr_normal = geo_decode_normal_float(curr_normal_z.r);
  const float curr_z = curr_normal_z.g;
  const vec2 curr_moments = curr_normal_z.ba;

  const vec2 mv = texelFetch(img_mv, ipos, 0).rg;
  const vec2 prev_pos = ipos + mv;

  vec4 prev_irr_histlen = vec4(0);
  vec2 prev_moments     = vec2(0);
  float sum_w           = 0.0;

  if (params.clear == 1) {
    imageStore(img_accum, ipos, curr_irr_samples);
    imageStore(img_moments, ipos, vec4(curr_moments,  0, 0));
    return;
  }

  if (FILTER_MODE == 0) {
    const ivec2 prev_ipos = ivec2(round(prev_pos));
    const vec2 prev_gbuf = texelFetch(img_prev_gbuf, prev_ipos, 0).rg;
    const vec3 prev_normal = geo_decode_normal_float(prev_gbuf.r);
    const float prev_z = prev_gbuf.g;

    const float w = reprojection_weight(curr_normal, prev_normal, params.normal_reject_cos,
                          curr_z, prev_z, params.z_reject_percent);

    prev_irr_histlen = w * texelFetch(img_prev_accum, prev_ipos, 0);
    prev_moments     = w * texelFetch(img_prev_moments, prev_ipos, 0).rg;
    sum_w            = w;

  } else if (FILTER_MODE == 1) {
    const ivec2 prev_ipos = ivec2(floor(prev_pos));
    const vec2 inter_w = fract(prev_pos); // bilinear interpolation weight

    // Bilinear interpolation of previous data
    [[unroll]]
    for(int yy = 0; yy <= 1; yy++) {
      [[unroll]]
      for(int xx = 0; xx <= 1; xx++) {
        const ivec2 tc = prev_ipos + ivec2(xx, yy);
        if(any(greaterThanEqual(tc, textureSize(img_prev_accum, 0))) || any(lessThan(tc, ivec2(0))))
          continue;

        const vec2 prev_normal_z = texelFetch(img_prev_gbuf, tc, 0).rg;
        const vec3 prev_normal = geo_decode_normal_float(prev_normal_z.r);
        const float prev_z = prev_normal_z.g;

        // Bilinear interpolation weight
        const float w = (xx == 0 ? (1.0 - inter_w.x) : inter_w.x) * (yy == 0 ? (1.0 - inter_w.y) : inter_w.y)
                  * reprojection_weight(curr_normal, prev_normal, params.normal_reject_cos,
                          curr_z, prev_z, params.z_reject_percent);

        prev_irr_histlen        += w * texelFetch(img_prev_accum, tc, 0);
        prev_moments            += w * texelFetch(img_prev_moments, tc, 0).rg;
        sum_w                   += w;
      }
    }
  }

  if (EXTENDED_SEARCH == 1)
  if (sum_w <= 0.01) {
    prev_irr_histlen = vec4(0);
    prev_moments     = vec2(0);
    sum_w            = 0.0;

    const ivec2 prev_ipos = ivec2(round(prev_pos));

    [[unroll]]
    for(int yy = -1; yy <= 1; yy++) {
      [[unroll]]
      for(int xx = -1; xx <= 1; xx++) {
        const ivec2 tc = prev_ipos + ivec2(xx, yy);
        if(any(greaterThanEqual(tc, textureSize(img_prev_accum, 0))) || any(lessThan(tc, ivec2(0))))
          continue;

        const vec2 prev_normal_z = texelFetch(img_prev_gbuf, tc, 0).rg;
        const vec3 prev_normal = geo_decode_normal_float(prev_normal_z.r);
        const float prev_z = prev_normal_z.g;

        const float w = reprojection_weight(curr_normal, prev_normal, params.normal_reject_cos,
                          curr_z, prev_z, params.z_reject_percent);

        prev_irr_histlen        += w * texelFetch(img_prev_accum, tc, 0);
        prev_moments            += w * texelFetch(img_prev_moments, tc, 0).rg;
        sum_w                   += w;
      }
    }
  }

  vec4 accum = curr_irr_samples; // samples/histlen in a
  vec2 moments = curr_moments;

  if (sum_w > 0.01) {
    // make sure the prev values are reliable
    prev_irr_histlen /= sum_w;
    prev_moments     /= sum_w;

    // With params == 1, this would be a regular average.
    // The params can be used to allow to adapt to new lighting conditions
    const float alpha_corrected = min(params.accum_alpha, prev_irr_histlen.a / (prev_irr_histlen.a + curr_irr_samples.a));

    accum.rgb = mix(curr_irr_samples.rgb, prev_irr_histlen.rgb,                    alpha_corrected);
    moments   = mix(curr_moments,         prev_moments,                            alpha_corrected);
    accum.a = min(prev_irr_histlen.a + curr_irr_samples.a, params.accum_max_hist);
  }

  imageStore(img_accum, ipos, accum);
  imageStore(img_moments, ipos, vec4(moments,  0, 0));
}

