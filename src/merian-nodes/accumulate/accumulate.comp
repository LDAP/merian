#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z = 1) in;


layout(set = 0, binding = 0) uniform sampler2D img_prev_accum;
layout(set = 0, binding = 1) uniform sampler2D img_prev_moments;

layout(set = 0, binding = 2) uniform sampler2D img_irr;
layout(set = 0, binding = 3) uniform sampler2D img_gbuf;
layout(set = 0, binding = 4) uniform sampler2D img_prev_gbuf;

layout(set = 0, binding = 5) uniform sampler2D img_mv;


layout(set = 0, binding = 6) uniform writeonly image2D img_accum;
layout(set = 0, binding = 7) uniform writeonly image2D img_moments;


#include "common/colors_yuv.glsl"

layout(push_constant, std140) uniform params_t { 
    float accum_alpha;
    float accum_max_hist;
    float normal_reject_rad;
    float depth_reject_percent;
    int filter_mode;
    uint clear;
} params;

void
main() {
  const ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_accum)))) return;

  const vec4 curr_irr_samples = texelFetch(img_irr, ipos, 0);
  const vec4 curr_normal_z = texelFetch(img_gbuf, ipos, 0);
  const vec3 curr_normal = curr_normal_z.rgb;
  const float curr_z = curr_normal_z.a;
  const float curr_l = yuv_luminance(curr_irr_samples.rgb);
  const vec2 curr_moments = vec2(curr_l, curr_l * curr_l);

  const vec2 mv = texelFetch(img_mv, ipos, 0).rg;
  const vec2 prev_pos = ipos + mv;

  vec4 prev_irr_histlen = vec4(0);
  vec2 prev_moments     = vec2(0);
  float sum_w           = 0.0;

  if (params.clear == 1) {
    // Make sure sum_w is 0. That means no previous information is used.
  } else if (params.filter_mode == 0) {
    const ivec2 prev_ipos = ivec2(round(prev_pos));
    const vec4 prev_normal_z = texelFetch(img_prev_gbuf, prev_ipos, 0);
    const vec3 prev_normal = prev_normal_z.rgb;
    const float prev_z = prev_normal_z.a;

    float w = 1.0;
    // Similar normals
    w *= smoothstep(params.normal_reject_rad, 1.0, dot(curr_normal, prev_normal));
    // Similar depth
    w *= 1.0 - smoothstep(0.0, params.depth_reject_percent * max(curr_z, prev_z), abs(curr_z - prev_z));

    prev_irr_histlen = w * texelFetch(img_prev_accum, prev_ipos, 0);
    prev_moments     = w * texelFetch(img_prev_moments, prev_ipos, 0).rg;
    sum_w            = w;

  } else if (params.filter_mode == 1) {
    const ivec2 prev_ipos = ivec2(floor(prev_pos));
    const vec2 inter_w = fract(prev_pos); // bilinear interpolation weight

    // Bilinear interpolation of previous data
    for(int yy = 0; yy <= 1; yy++) {
      for(int xx = 0; xx <= 1; xx++) {

        const ivec2 tc = prev_ipos + ivec2(xx, yy);
        if(any(greaterThanEqual(tc, textureSize(img_prev_accum, 0))) || any(lessThan(tc, ivec2(0))))
          continue;

        const vec4 prev_normal_z = texelFetch(img_prev_gbuf, tc, 0);
        const vec3 prev_normal = prev_normal_z.rgb;
        const float prev_z = prev_normal_z.a;

        // Bilinear interpolation weight
        float w = (xx == 0 ? (1.0 - inter_w.x) : inter_w.x) * (yy == 0 ? (1.0 - inter_w.y) : inter_w.y);
        // Similar normals
        w *= smoothstep(params.normal_reject_rad, 1.0, dot(curr_normal, prev_normal));
        // Similar depth
        w *= 1.0 - smoothstep(0.0, params.depth_reject_percent * max(curr_z, prev_z), abs(curr_z - prev_z));

        prev_irr_histlen        += w * texelFetch(img_prev_accum, tc, 0);
        prev_moments            += w * texelFetch(img_prev_moments, tc, 0).rg;
        sum_w                   += w;
      }
    }
  }

  vec4 accum = curr_irr_samples; // samples/histlen in a
  vec2 moments = curr_moments;

  if (sum_w > 0.01) {
    // make sure the prev values are reliable
    prev_irr_histlen /= sum_w;
    prev_moments     /= sum_w;

    // With params == 1, this would be a regular average.
    // The params can be used to allow to adapt to new lighting conditions
    const float alpha_corrected = params.accum_alpha * prev_irr_histlen.a / (prev_irr_histlen.a + curr_irr_samples.a);

    accum.rgb = mix(curr_irr_samples.rgb, prev_irr_histlen.rgb,                    alpha_corrected);
    moments   = mix(curr_moments,         prev_moments,                            alpha_corrected);
    accum.a = min(prev_irr_histlen.a + curr_irr_samples.a, params.accum_max_hist);
  }

  imageStore(img_accum, ipos, accum);
  imageStore(img_moments, ipos, vec4(moments,  0, 0));
}

