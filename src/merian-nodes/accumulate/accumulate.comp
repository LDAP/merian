#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_control_flow_attributes : require

#include "graph_layout.glsl"
#include "common/interpolate.glsl"

#define FILTER_MODE_NEAREST 0
#define FILTER_MODE_BILINEAR 1

layout(constant_id = 2) const uint WG_ROUNDED_IRR_SIZE_X = 1;
layout(constant_id = 3) const uint WG_ROUNDED_IRR_SIZE_Y = 1;

layout (constant_id = 4) const int FILTER_MODE = FILTER_MODE_NEAREST;
layout (constant_id = 5) const int EXTENDED_SEARCH = 1;
layout (constant_id = 6) const int REUSE_BORDER = 0;

layout(set = 1, binding = 0) uniform sampler2D img_quartiles;

layout(push_constant, std140) uniform pc_t { 
    int firefly_filter_enable;
    float firefly_bias;
    float firefly_ipr_factor;
    float firefly_hard_clamp;

    float accum_alpha;
    float accum_max_hist;
    float normal_reject_cos;
    float z_reject_percent;
    int clear;

    float adaptive_alpha_reduction;
    float adaptive_alpha_ipr_factor;
} pc;

#include "common/normal_encode.glsl"
#include "common/reprojection.glsl"
#include "common/colors_yuv.glsl"

void get_prev_nearest(const vec2 prev_pos,
                      const float linear_z,
                      const float vel_z,
                      const vec3 normal,
                      inout vec4 prev_irr_histlen,
                      inout vec2 prev_moments,
                      inout float sum_w) {
  const ivec2 prev_ipos = ivec2(round(prev_pos));
  if(any(greaterThanEqual(prev_ipos, textureSize(img_prev_accum, 0))) || any(lessThan(prev_ipos, ivec2(0))))
    return;

  const GBuffer prev_gbuf = prev_gbuffer[gbuffer_index(prev_ipos, imageSize(img_accum))];
  const vec3 prev_normal = geo_decode_normal(prev_gbuf.enc_normal);
  const float w = reprojection_weight(normal, prev_normal, pc.normal_reject_cos,
                        linear_z, vel_z, prev_gbuf.linear_z, pc.z_reject_percent);

  prev_irr_histlen = w * texelFetch(img_prev_accum, prev_ipos, 0);
  prev_moments     = w * texelFetch(img_prev_moments, prev_ipos, 0).rg;
  sum_w            = w;
}

void get_prev_bilinear(const vec2 prev_pos,
                       const float linear_z,
                       const float vel_z,
                       const vec3 normal,
                       inout vec4 prev_irr_histlen,
                       inout vec2 prev_moments,
                       inout float sum_w) {
  const ivec2 prev_ipos = ivec2(floor(prev_pos));
  // bilinear interpolation weight
  const vec2 inter_w = fract(prev_pos);

  [[unroll]]
  for(int yy = 0; yy <= 1; yy++) {
    [[unroll]]
    for(int xx = 0; xx <= 1; xx++) {
      const ivec2 tc = prev_ipos + ivec2(xx, yy);
      if(any(greaterThanEqual(tc, textureSize(img_prev_accum, 0))) || any(lessThan(tc, ivec2(0))))
        continue;

      const GBuffer prev_gbuf = prev_gbuffer[gbuffer_index(tc, imageSize(img_accum))];
      const vec3 prev_normal = geo_decode_normal(prev_gbuf.enc_normal);

      // Bilinear interpolation weight
      const float w = (xx == 0 ? (1.0 - inter_w.x) : inter_w.x) * (yy == 0 ? (1.0 - inter_w.y) : inter_w.y)
                * reprojection_weight(normal, prev_normal, pc.normal_reject_cos,
                        linear_z, vel_z, prev_gbuf.linear_z, pc.z_reject_percent);

      prev_irr_histlen        += w * texelFetch(img_prev_accum, tc, 0);
      prev_moments            += w * texelFetch(img_prev_moments, tc, 0).rg;
      sum_w                   += w;
    }
  }
}

void get_prev_extended_search(const vec2 prev_pos,
                              const float linear_z,
                              const float vel_z,
                              const vec2 grad_z,
                              const vec3 normal,
                              inout vec4 prev_irr_histlen,
                              inout vec2 prev_moments,
                              inout float sum_w) {
  const ivec2 prev_ipos = ivec2(round(prev_pos));

  [[unroll]]
  for(int yy = -1; yy <= 1; yy++) {
    [[unroll]]
    for(int xx = -1; xx <= 1; xx++) {
      const ivec2 tc = prev_ipos + ivec2(xx, yy);
      if(any(greaterThanEqual(tc, textureSize(img_prev_accum, 0))) || any(lessThan(tc, ivec2(0))))
        continue;

      const GBuffer prev_gbuf = prev_gbuffer[gbuffer_index(tc, imageSize(img_accum))];
      const vec3 prev_normal = geo_decode_normal(prev_gbuf.enc_normal);
      const float w = reprojection_weight(normal, prev_normal, pc.normal_reject_cos * 0.8,
                        linear_z, vel_z, ivec2(xx, yy), grad_z, prev_gbuf.linear_z, pc.z_reject_percent * 2.);

      prev_irr_histlen        += w * texelFetch(img_prev_accum, tc, 0);
      prev_moments            += w * texelFetch(img_prev_moments, tc, 0).rg;
      sum_w                   += w;
    }
  }
}


void main() {
  const ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if (any(greaterThanEqual(ipos, imageSize(img_accum)))) return;

  vec3 irr = texelFetch(img_irr, ipos, 0).rgb;
  vec2 moments = texelFetch(img_moments, ipos, 0).rg;
  vec4 percentiles;

  if (pc.firefly_filter_enable != 0 || pc.adaptive_alpha_reduction > 0.0) {
    const uvec2 rounded_size = uvec2(WG_ROUNDED_IRR_SIZE_X, WG_ROUNDED_IRR_SIZE_Y);
    percentiles = texture(img_quartiles, (vec2(ipos) + 0.5) / rounded_size);
  }
  
  // FIREFLY CLAMPING/SUPPRESSION
  {
    float max_l = pc.firefly_hard_clamp;
    if (pc.firefly_filter_enable != 0) {
      max_l = min(max_l, pc.firefly_bias + percentiles.y + pc.firefly_ipr_factor * (percentiles.y - percentiles.x));
    }

    if (moments.x /* = yuv_luminance(irr)*/ > max_l) {
      const float factor = max_l / moments.x;
      irr *= factor;
      moments *= vec2(factor, factor * factor);
    }
  }

  if (pc.clear == 1 || pc.accum_alpha == 0) {
    imageStore(img_accum, ipos, vec4(irr, 1));
    imageStore(img_moments_accum, ipos, vec4(moments,  0, 0));
    return;
  }

  const vec2 mv = texelFetch(img_mv, ipos, 0).rg;

  // REPROJECTION
  vec2 prev_pos = ipos + mv;;
  float max_history = pc.accum_max_hist;
  if (REUSE_BORDER == 1) {
    // Attemp to reuse information at the image border.
    // This results in minor smearing but looks a lot better than
    // noise / SVGF blotches.
    const vec2 bmax = imageSize(img_accum) - 1;
    if (any(greaterThan(prev_pos, bmax)) || any(lessThan(prev_pos, vec2(0)))) {
      // Intersect motion vector with image:
      float tmin = min(prev_pos.x / mv.x, (prev_pos.x - bmax.x) / mv.x);
      tmin = max(tmin, min(prev_pos.y / mv.y, (prev_pos.y - bmax.y) / mv.y));
      prev_pos = prev_pos - mv * tmin;
      // reset history to converge faster
      max_history = 2.0;
    }
  }

  vec4 prev_irr_histlen = vec4(0);
  vec2 prev_moments     = vec2(0);
  float sum_w           = 0.0;

  // ACCUMULATE
  {
    const GBuffer gbuf = gbuffer[gbuffer_index(ipos, imageSize(img_accum))];
    const vec3 normal = geo_decode_normal(gbuf.enc_normal);

    if (FILTER_MODE == FILTER_MODE_NEAREST)
      get_prev_nearest(prev_pos,
                       gbuf.linear_z,
                       gbuf.vel_z,
                       normal,
                       prev_irr_histlen,
                       prev_moments,
                       sum_w);
    else if (FILTER_MODE == FILTER_MODE_BILINEAR)
      get_prev_bilinear(prev_pos,
                        gbuf.linear_z,
                        gbuf.vel_z,
                        normal,
                        prev_irr_histlen,
                        prev_moments,
                        sum_w);

    if (EXTENDED_SEARCH == 1) {
      if (sum_w <= 0.01) {
        // only if data is not already reliable
        prev_irr_histlen = vec4(0);
        prev_moments     = vec2(0);
        sum_w            = 0.0;

        get_prev_extended_search(prev_pos,
                                 gbuf.linear_z,
                                 gbuf.vel_z,
                                 gbuf.grad_z,
                                 normal,
                                 prev_irr_histlen,
                                 prev_moments,
                                 sum_w);
      }
    }
  }

  if (sum_w > 0.001 // make sure the prev values are somewhat reliable
      && !any(isnan(prev_irr_histlen))
      && !any(isinf(prev_irr_histlen))
      && !any(isnan(prev_moments))
      && !any(isinf(prev_moments))) {
    prev_irr_histlen /= sum_w;
    prev_moments     /= sum_w;

    prev_irr_histlen.a = min(prev_irr_histlen.a + 1, max_history);
    float alpha = min(pc.accum_alpha, 1. - 1. / prev_irr_histlen.a);

    if (pc.adaptive_alpha_reduction > 0.0) {
      const float ipr = pc.adaptive_alpha_ipr_factor * (percentiles.w - percentiles.z);
      alpha *= (1.0 - pc.adaptive_alpha_reduction * linearstep(percentiles.w, percentiles.w + ipr, prev_moments.x));
      alpha *= (1.0 - pc.adaptive_alpha_reduction * (1.0 - linearstep(percentiles.z - ipr, percentiles.z, prev_moments.x)));

      // update history length to match reduced alpha:
      // prev_irr_histlen.a = 1.0 / (1.0 - alpha + 1e-9);
    }

    irr     = mix(irr, prev_irr_histlen.rgb, alpha);
    moments = mix(moments,         prev_moments, alpha);

    imageStore(img_accum, ipos, vec4(irr, prev_irr_histlen.a));
    imageStore(img_moments_accum, ipos, vec4(moments, 0, 0));
  } else {
    imageStore(img_accum, ipos, vec4(irr, 1));
    imageStore(img_moments_accum, ipos, vec4(moments, 0, 0));
  }


  
} 
